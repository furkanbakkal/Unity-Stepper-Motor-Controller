CCS PCH C Compiler, Version 5.101, 61971               05-Eki-22 21:13

               Filename:   C:\Users\furka\OneDrive\Masaüstü\stepper-control-final\main.lst

               ROM used:   9154 bytes (14%)
                           Largest free fragment is 56378
               RAM used:   118 (3%) at main() level
                           143 (4%) worst case
               Stack used: 10 locations (8 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   13DE
*
00008:  GOTO   0128
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  F9D.0
00066:  GOTO   0070
0006A:  BTFSC  F9E.0
0006C:  GOTO   01A2
00070:  BTFSS  FA0.2
00072:  GOTO   007C
00076:  BTFSC  FA1.2
00078:  GOTO   0370
0007C:  MOVFF  0E,00
00080:  MOVFF  0F,01
00084:  MOVFF  10,02
00088:  MOVFF  11,03
0008C:  MOVFF  0C,FE9
00090:  MOVFF  07,FEA
00094:  BSF    07.7
00096:  MOVFF  08,FE1
0009A:  MOVFF  09,FE2
0009E:  MOVFF  0A,FD9
000A2:  MOVFF  0B,FDA
000A6:  MOVFF  12,FF3
000AA:  MOVFF  13,FF4
000AE:  MOVFF  14,FFA
000B2:  MOVFF  15,FF5
000B6:  MOVFF  16,FF6
000BA:  MOVFF  17,FF7
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
000CA:  CLRF   FF7
000CC:  ADDLW  DA
000CE:  MOVWF  FF6
000D0:  MOVLW  00
000D2:  ADDWFC FF7,F
000D4:  TBLRD*+
000D6:  MOVF   FF5,W
000D8:  RETURN 0
000DA:  DATA 28,0C
000DC:  DATA 01,06
000DE:  CLRF   FF7
000E0:  ADDLW  EE
000E2:  MOVWF  FF6
000E4:  MOVLW  00
000E6:  ADDWFC FF7,F
000E8:  TBLRD*+
000EA:  MOVF   FF5,W
000EC:  RETURN 0
000EE:  DATA 00,00
000F0:  DATA 15,15
000F2:  DATA 15,15
000F4:  DATA 15,00
000F6:  DATA 1F,1F
000F8:  DATA 1F,1F
000FA:  DATA 1F,1F
000FC:  DATA 1F,1F
000FE:  DATA 1F,11
00100:  DATA 11,11
00102:  DATA 11,11
00104:  DATA 11,1F
00106:  DATA 20,00
00108:  DATA 20,00
0010A:  DATA 20,00
0010C:  DATA 20,20
0010E:  DATA 00,00
00110:  DATA 3C,43
00112:  DATA 65,6E
00114:  DATA 74,65
00116:  DATA 72,3E
00118:  DATA 00,00
0011A:  DATA 0C,00
0011C:  DATA 63,6F
0011E:  DATA 75,6E
00120:  DATA 74,3A
00122:  DATA 20,25
00124:  DATA 4C,75
00126:  DATA 00,00
*
00568:  DATA 45,65
0056A:  DATA 70,72
0056C:  DATA 6F,6D
0056E:  DATA 20,46
00570:  DATA 61,69
00572:  DATA 6C,00
00574:  DATA 43,65
00576:  DATA 6E,74
00578:  DATA 65,65
0057A:  DATA 20,4D
0057C:  DATA 61,63
0057E:  DATA 68,69
00580:  DATA 6E,65
00582:  DATA 00,00
00584:  DATA 53,70
00586:  DATA 65,65
00588:  DATA 64,3A
0058A:  DATA 20,25
0058C:  DATA 20,20
0058E:  DATA 20,00
00590:  DATA 3C,4D
00592:  DATA 61,6E
00594:  DATA 75,65
00596:  DATA 6C,3E
00598:  DATA 00,00
0059A:  DATA 3C,20
0059C:  DATA 41,75
0059E:  DATA 74,6F
005A0:  DATA 20,3E
005A2:  DATA 00,00
005A4:  DATA 41,63
005A6:  DATA 63,65
005A8:  DATA 6C,3A
005AA:  DATA 20,25
005AC:  DATA 20,20
005AE:  DATA 20,00
005B0:  DATA 43,65
005B2:  DATA 6E,74
005B4:  DATA 65,72
005B6:  DATA 20,4D
005B8:  DATA 61,63
005BA:  DATA 68,69
005BC:  DATA 6E,65
005BE:  DATA 00,00
005C0:  DATA 25,00
005C2:  DATA 20,20
005C4:  DATA 20,20
005C6:  DATA 00,00
005C8:  DATA 25,00
005CA:  DATA 25,00
005CC:  DATA 25,00
005CE:  DATA 20,20
005D0:  DATA 20,20
005D2:  DATA 00,00
005D4:  DATA 25,00
005D6:  DATA 25,00
005D8:  DATA 25,00
005DA:  DATA 25,00
005DC:  DATA 25,00
005DE:  DATA 25,00
005E0:  DATA 3C,20
005E2:  DATA 41,75
005E4:  DATA 74,6F
005E6:  DATA 20,3E
005E8:  DATA 00,00
*
00858:  TBLRD*+
0085A:  MOVF   FF5,F
0085C:  BZ    0876
0085E:  MOVFF  FF6,79
00862:  MOVFF  FF7,7A
00866:  MOVFF  FF5,7F
0086A:  RCALL  0804
0086C:  MOVFF  79,FF6
00870:  MOVFF  7A,FF7
00874:  BRA    0858
00876:  RETURN 0
00878:  MOVFF  FEA,7E
0087C:  MOVFF  FE9,7D
00880:  SWAPF  x77,W
00882:  IORLW  F0
00884:  MOVWF  x79
00886:  ADDWF  x79,F
00888:  ADDLW  E2
0088A:  MOVWF  x7A
0088C:  ADDLW  32
0088E:  MOVWF  x7C
00890:  MOVF   x77,W
00892:  ANDLW  0F
00894:  ADDWF  x7A,F
00896:  ADDWF  x7A,F
00898:  ADDWF  x7C,F
0089A:  ADDLW  E9
0089C:  MOVWF  x7B
0089E:  ADDWF  x7B,F
008A0:  ADDWF  x7B,F
008A2:  SWAPF  x76,W
008A4:  ANDLW  0F
008A6:  ADDWF  x7B,F
008A8:  ADDWF  x7C,F
008AA:  RLCF   x7B,F
008AC:  RLCF   x7C,F
008AE:  COMF   x7C,F
008B0:  RLCF   x7C,F
008B2:  MOVF   x76,W
008B4:  ANDLW  0F
008B6:  ADDWF  x7C,F
008B8:  RLCF   x79,F
008BA:  MOVLW  07
008BC:  MOVWF  x78
008BE:  MOVLW  0A
008C0:  DECF   x7B,F
008C2:  ADDWF  x7C,F
008C4:  BNC   08C0
008C6:  DECF   x7A,F
008C8:  ADDWF  x7B,F
008CA:  BNC   08C6
008CC:  DECF   x79,F
008CE:  ADDWF  x7A,F
008D0:  BNC   08CC
008D2:  DECF   x78,F
008D4:  ADDWF  x79,F
008D6:  BNC   08D2
008D8:  CLRF   FEA
008DA:  MOVLW  78
008DC:  MOVWF  FE9
008DE:  MOVLW  07
008E0:  ANDWF  x7D,W
008E2:  BCF    x7D.6
008E4:  ADDWF  FE9,F
008E6:  MOVLW  00
008E8:  ADDWFC FEA,F
008EA:  MOVF   FE9,W
008EC:  SUBLW  7C
008EE:  BNZ   08F6
008F0:  MOVF   FEA,F
008F2:  BNZ   08F6
008F4:  BSF    x7D.6
008F6:  MOVF   FEF,W
008F8:  MOVWF  00
008FA:  BNZ   090C
008FC:  BTFSC  x7D.6
008FE:  BRA    090C
00900:  BTFSC  x7D.4
00902:  BRA    092A
00904:  BTFSC  x7D.3
00906:  BRA    090C
00908:  MOVLW  20
0090A:  BRA    0912
0090C:  BSF    x7D.3
0090E:  BCF    x7D.4
00910:  MOVLW  30
00912:  ADDWF  00,F
00914:  MOVFF  FEA,77
00918:  MOVFF  FE9,76
0091C:  MOVFF  00,7F
00920:  RCALL  0804
00922:  MOVFF  77,FEA
00926:  MOVFF  76,FE9
0092A:  MOVF   FEE,W
0092C:  BTFSS  x7D.6
0092E:  BRA    08EA
00930:  RETURN 0
00932:  MOVF   x7A,W
00934:  CLRF   01
00936:  SUBWF  x79,W
00938:  BC    0940
0093A:  MOVFF  79,00
0093E:  BRA    0958
00940:  CLRF   00
00942:  MOVLW  08
00944:  MOVWF  x7B
00946:  RLCF   x79,F
00948:  RLCF   00,F
0094A:  MOVF   x7A,W
0094C:  SUBWF  00,W
0094E:  BTFSC  FD8.0
00950:  MOVWF  00
00952:  RLCF   01,F
00954:  DECFSZ x7B,F
00956:  BRA    0946
00958:  RETURN 0
0095A:  MOVLW  20
0095C:  BTFSS  x74.4
0095E:  MOVLW  30
00960:  MOVWF  x75
00962:  MOVFF  73,00
00966:  BTFSS  x73.7
00968:  BRA    097A
0096A:  COMF   00,F
0096C:  INCF   00,F
0096E:  MOVFF  00,73
00972:  MOVLW  2D
00974:  MOVWF  x75
00976:  BSF    x74.7
00978:  BSF    x74.0
0097A:  MOVF   01,W
0097C:  MOVFF  73,79
00980:  MOVLW  64
00982:  MOVWF  x7A
00984:  RCALL  0932
00986:  MOVFF  00,73
0098A:  MOVLW  30
0098C:  ADDWF  01,W
0098E:  MOVWF  x76
00990:  MOVFF  73,79
00994:  MOVLW  0A
00996:  MOVWF  x7A
00998:  RCALL  0932
0099A:  MOVLW  30
0099C:  ADDWF  00,W
0099E:  MOVWF  x78
009A0:  MOVLW  30
009A2:  ADDWF  01,W
009A4:  MOVWF  x77
009A6:  MOVFF  75,00
009AA:  MOVLW  30
009AC:  SUBWF  x76,W
009AE:  BZ    09B8
009B0:  BSF    x74.1
009B2:  BTFSC  x74.7
009B4:  BSF    x74.2
009B6:  BRA    09DC
009B8:  MOVFF  75,76
009BC:  MOVLW  20
009BE:  MOVWF  x75
009C0:  MOVLW  30
009C2:  SUBWF  x77,W
009C4:  BZ    09CE
009C6:  BSF    x74.0
009C8:  BTFSC  x74.7
009CA:  BSF    x74.1
009CC:  BRA    09DC
009CE:  BTFSS  FD8.2
009D0:  BSF    x74.0
009D2:  BNZ   09DC
009D4:  MOVFF  76,77
009D8:  MOVLW  20
009DA:  MOVWF  x76
009DC:  BTFSC  x74.2
009DE:  BRA    09EA
009E0:  BTFSC  x74.1
009E2:  BRA    09F0
009E4:  BTFSC  x74.0
009E6:  BRA    09F6
009E8:  BRA    09FC
009EA:  MOVFF  75,7F
009EE:  RCALL  0804
009F0:  MOVFF  76,7F
009F4:  RCALL  0804
009F6:  MOVFF  77,7F
009FA:  RCALL  0804
009FC:  MOVFF  78,7F
00A00:  RCALL  0804
00A02:  RETURN 0
*
00A28:  MOVLW  8E
00A2A:  MOVWF  00
00A2C:  MOVFF  74,01
00A30:  MOVFF  73,02
00A34:  CLRF   03
00A36:  MOVF   01,F
00A38:  BNZ   0A4C
00A3A:  MOVFF  02,01
00A3E:  CLRF   02
00A40:  MOVLW  08
00A42:  SUBWF  00,F
00A44:  MOVF   01,F
00A46:  BNZ   0A4C
00A48:  CLRF   00
00A4A:  BRA    0A5C
00A4C:  BCF    FD8.0
00A4E:  BTFSC  01.7
00A50:  BRA    0A5A
00A52:  RLCF   02,F
00A54:  RLCF   01,F
00A56:  DECF   00,F
00A58:  BRA    0A4C
00A5A:  BCF    01.7
00A5C:  RETURN 0
*
00BB8:  CLRF   01
00BBA:  CLRF   02
00BBC:  CLRF   00
00BBE:  CLRF   03
00BC0:  MOVF   x7C,W
00BC2:  BNZ   0BC8
00BC4:  MOVF   x7B,W
00BC6:  BZ    0BF8
00BC8:  MOVLW  10
00BCA:  MOVWF  x7D
00BCC:  BCF    FD8.0
00BCE:  RLCF   x79,F
00BD0:  RLCF   x7A,F
00BD2:  RLCF   00,F
00BD4:  RLCF   03,F
00BD6:  MOVF   x7C,W
00BD8:  SUBWF  03,W
00BDA:  BNZ   0BE0
00BDC:  MOVF   x7B,W
00BDE:  SUBWF  00,W
00BE0:  BNC   0BF0
00BE2:  MOVF   x7B,W
00BE4:  SUBWF  00,F
00BE6:  BTFSS  FD8.0
00BE8:  DECF   03,F
00BEA:  MOVF   x7C,W
00BEC:  SUBWF  03,F
00BEE:  BSF    FD8.0
00BF0:  RLCF   01,F
00BF2:  RLCF   02,F
00BF4:  DECFSZ x7D,F
00BF6:  BRA    0BCC
00BF8:  RETURN 0
*
00D4C:  TBLRD*+
00D4E:  MOVFF  FF6,77
00D52:  MOVFF  FF7,78
00D56:  MOVFF  FF5,7F
00D5A:  RCALL  0804
00D5C:  MOVFF  77,FF6
00D60:  MOVFF  78,FF7
00D64:  DECFSZ x76,F
00D66:  BRA    0D4C
00D68:  GOTO   0EDE (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #fuses NOWDT      //No Watch Dog Timer
.................... 
.................... #use delay(internal=64MHz)
*
0015A:  MOVLW  01
0015C:  SUBWF  x8C,F
0015E:  BNC   0176
00160:  CLRF   FEA
00162:  MOVLW  8C
00164:  MOVWF  FE9
00166:  MOVF   FEF,W
00168:  BZ    0176
0016A:  MOVLW  04
0016C:  MOVWF  00
0016E:  DECFSZ 00,F
00170:  BRA    016E
00172:  DECFSZ FEF,F
00174:  BRA    016A
00176:  GOTO   0184 (RETURN)
*
00348:  CLRF   FEA
0034A:  MOVLW  89
0034C:  MOVWF  FE9
0034E:  MOVF   FEF,W
00350:  BZ    036E
00352:  MOVLW  14
00354:  MOVWF  01
00356:  CLRF   00
00358:  DECFSZ 00,F
0035A:  BRA    0358
0035C:  DECFSZ 01,F
0035E:  BRA    0356
00360:  MOVLW  BF
00362:  MOVWF  00
00364:  DECFSZ 00,F
00366:  BRA    0364
00368:  BRA    036A
0036A:  DECFSZ FEF,F
0036C:  BRA    0352
0036E:  RETURN 0
.................... #device HIGH_INTS = TRUE 
.................... #use timer(timer=0,tick=100us,bits=32,NOISR)
*
00772:  MOVF   FD6,W
00774:  MOVFF  FD7,03
00778:  BTFSS  FF2.2
0077A:  BRA    0794
0077C:  MOVLW  01
0077E:  ADDWF  1A,F
00780:  BTFSC  FD8.0
00782:  INCF   1B,F
00784:  BTFSC  FD8.2
00786:  INCF   1C,F
00788:  BTFSC  FD8.2
0078A:  INCF   1D,F
0078C:  BCF    FF2.2
0078E:  MOVF   FD6,W
00790:  MOVFF  FD7,03
00794:  MOVWF  00
00796:  MOVFF  03,01
0079A:  MOVFF  1A,02
0079E:  MOVFF  1B,03
007A2:  MOVF   1C,W
007A4:  RRCF   FE8,F
007A6:  RRCF   03,F
007A8:  RRCF   02,F
007AA:  RRCF   01,F
007AC:  RRCF   00,F
007AE:  RRCF   FE8,F
007B0:  RRCF   03,F
007B2:  RRCF   02,F
007B4:  RRCF   01,F
007B6:  RRCF   00,F
007B8:  RRCF   FE8,F
007BA:  RRCF   03,F
007BC:  RRCF   02,F
007BE:  RRCF   01,F
007C0:  RRCF   00,F
007C2:  RETURN 0
.................... #define TICK_TYPE unsigned int32
.................... 
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <flex_lcd420.c>
.................... // Flex_LCD420.c
.................... 
.................... // These pins are for my Microchip PicDem2-Plus board,
.................... // which I used to test this driver.
.................... // An external 20x4 LCD is connected to these pins.
.................... // Change these pins to match your own board's connections.
.................... 
.................... #define LCD_DB4   PIN_B4
.................... #define LCD_DB5   PIN_B5
.................... #define LCD_DB6   PIN_B6
.................... #define LCD_DB7   PIN_B7
.................... 
.................... #define LCD_RS    PIN_B1
.................... #define LCD_RW    PIN_B2
.................... #define LCD_E     PIN_B3
.................... 
.................... /*
.................... // To prove that the driver can be used with random
.................... // pins, I also tested it with these pins:
.................... #define LCD_DB4   PIN_D4
.................... #define LCD_DB5   PIN_B1
.................... #define LCD_DB6   PIN_C5
.................... #define LCD_DB7   PIN_B5
.................... 
.................... #define LCD_RS    PIN_E2
.................... #define LCD_RW    PIN_B2
.................... #define LCD_E     PIN_D6
.................... */
.................... 
.................... // If you want only a 6-pin interface to your LCD, then
.................... // connect the R/W pin on the LCD to ground, and comment
.................... // out the following line.  Doing so will save one PIC
.................... // pin, but at the cost of losing the ability to read from
.................... // the LCD.  It also makes the write time a little longer
.................... // because a static delay must be used, instead of polling
.................... // the LCD's busy bit.  Normally a 6-pin interface is only
.................... // used if you are running out of PIC pins, and you need
.................... // to use as few as possible for the LCD.
.................... #define USE_RW_PIN   1     
.................... 
.................... 
.................... // These are the line addresses for most 4x20 LCDs.
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x40
.................... #define LCD_LINE_3_ADDRESS 0x14
.................... #define LCD_LINE_4_ADDRESS 0x54
.................... 
.................... // These are the line addresses for LCD's which use
.................... // the Hitachi HD66712U controller chip.
.................... /*
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x20
.................... #define LCD_LINE_3_ADDRESS 0x40
.................... #define LCD_LINE_4_ADDRESS 0x60
.................... */
.................... 
.................... 
.................... //========================================
.................... 
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)
.................... 
.................... int8 lcd_line;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots
....................  0xc,                     // Display on
....................  1,                       // Clear display
....................  6                        // Increment cursor
....................  };
....................                              
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
.................... // Note:  !! converts an integer expression
.................... // to a boolean (1 or 0).
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
005EA:  BTFSC  x87.0
005EC:  BRA    05F2
005EE:  BCF    F8A.4
005F0:  BRA    05F4
005F2:  BSF    F8A.4
005F4:  BCF    F93.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
005F6:  BTFSC  x87.1
005F8:  BRA    05FE
005FA:  BCF    F8A.5
005FC:  BRA    0600
005FE:  BSF    F8A.5
00600:  BCF    F93.5
....................  output_bit(LCD_DB6, !!(nibble & 4));   
00602:  BTFSC  x87.2
00604:  BRA    060A
00606:  BCF    F8A.6
00608:  BRA    060C
0060A:  BSF    F8A.6
0060C:  BCF    F93.6
....................  output_bit(LCD_DB7, !!(nibble & 8));   
0060E:  BTFSC  x87.3
00610:  BRA    0616
00612:  BCF    F8A.7
00614:  BRA    0618
00616:  BSF    F8A.7
00618:  BCF    F93.7
.................... 
....................  delay_cycles(1);
0061A:  NOP   
....................  output_high(LCD_E);
0061C:  BCF    F93.3
0061E:  BSF    F8A.3
....................  delay_us(2);
00620:  MOVLW  0A
00622:  MOVWF  00
00624:  DECFSZ 00,F
00626:  BRA    0624
00628:  NOP   
....................  output_low(LCD_E);
0062A:  BCF    F93.3
0062C:  BCF    F8A.3
0062E:  RETURN 0
.................... }
.................... 
.................... //-----------------------------------
.................... // This sub-routine is only called by lcd_read_byte().
.................... // It's not a stand-alone routine.  For example, the
.................... // R/W signal is set high by lcd_read_byte() before
.................... // this routine is called.     
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... // Create bit variables so that we can easily set
.................... // individual bits in the retval variable.
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
00630:  CLRF   x88
....................    
.................... output_high(LCD_E);
00632:  BCF    F93.3
00634:  BSF    F8A.3
.................... delay_us(1);
00636:  MOVLW  05
00638:  MOVWF  00
0063A:  DECFSZ 00,F
0063C:  BRA    063A
.................... 
.................... retval_0 = input(LCD_DB4);
0063E:  BSF    F93.4
00640:  BCF    x88.0
00642:  BTFSC  F81.4
00644:  BSF    x88.0
.................... retval_1 = input(LCD_DB5);
00646:  BSF    F93.5
00648:  BCF    x88.1
0064A:  BTFSC  F81.5
0064C:  BSF    x88.1
.................... retval_2 = input(LCD_DB6);
0064E:  BSF    F93.6
00650:  BCF    x88.2
00652:  BTFSC  F81.6
00654:  BSF    x88.2
.................... retval_3 = input(LCD_DB7);
00656:  BSF    F93.7
00658:  BCF    x88.3
0065A:  BTFSC  F81.7
0065C:  BSF    x88.3
....................  
.................... output_low(LCD_E);
0065E:  BCF    F93.3
00660:  BCF    F8A.3
.................... delay_us(1);
00662:  MOVLW  05
00664:  MOVWF  00
00666:  DECFSZ 00,F
00668:  BRA    0666
....................    
.................... return(retval);   
0066A:  MOVFF  88,01
0066E:  RETURN 0
.................... }   
.................... #endif
.................... 
.................... //---------------------------------------
.................... // Read a byte from the LCD and return it.
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
00670:  BCF    F93.2
00672:  BSF    F8A.2
.................... delay_cycles(1);
00674:  NOP   
.................... 
.................... high = lcd_read_nibble();
00676:  RCALL  0630
00678:  MOVFF  01,87
.................... 
.................... low = lcd_read_nibble();
0067C:  RCALL  0630
0067E:  MOVFF  01,86
.................... 
.................... return( (high<<4) | low);
00682:  SWAPF  x87,W
00684:  MOVWF  00
00686:  MOVLW  F0
00688:  ANDWF  00,F
0068A:  MOVF   00,W
0068C:  IORWF  x86,W
0068E:  MOVWF  01
00690:  GOTO   069A (RETURN)
.................... }
.................... #endif
.................... 
.................... //----------------------------------------
.................... // Send a byte to the LCD.
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
00694:  BCF    F93.1
00696:  BCF    F8A.1
.................... 
.................... #ifdef USE_RW_PIN
.................... while(bit_test(lcd_read_byte(),7)) ;
00698:  BRA    0670
0069A:  MOVFF  01,86
0069E:  BTFSC  01.7
006A0:  BRA    0698
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
006A2:  MOVF   x84,F
006A4:  BZ    06AC
....................    output_high(LCD_RS);
006A6:  BCF    F93.1
006A8:  BSF    F8A.1
006AA:  BRA    06B0
.................... else
....................    output_low(LCD_RS);
006AC:  BCF    F93.1
006AE:  BCF    F8A.1
....................      
....................  delay_cycles(1);
006B0:  NOP   
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
006B2:  BCF    F93.2
006B4:  BCF    F8A.2
.................... delay_cycles(1);
006B6:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
006B8:  BCF    F93.3
006BA:  BCF    F8A.3
.................... 
.................... lcd_send_nibble(n >> 4);
006BC:  SWAPF  x85,W
006BE:  MOVWF  x86
006C0:  MOVLW  0F
006C2:  ANDWF  x86,F
006C4:  MOVFF  86,87
006C8:  RCALL  05EA
.................... lcd_send_nibble(n & 0xf);
006CA:  MOVF   x85,W
006CC:  ANDLW  0F
006CE:  MOVWF  x86
006D0:  MOVWF  x87
006D2:  RCALL  05EA
006D4:  RETURN 0
.................... }
.................... //----------------------------
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... lcd_line = 1;
006D6:  MOVLW  01
006D8:  MOVWF  20
.................... 
.................... output_low(LCD_RS);
006DA:  BCF    F93.1
006DC:  BCF    F8A.1
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
006DE:  BCF    F93.2
006E0:  BCF    F8A.2
.................... #endif
.................... 
.................... output_low(LCD_E);
006E2:  BCF    F93.3
006E4:  BCF    F8A.3
006E6:  CLRF   19
006E8:  BTFSC  FF2.7
006EA:  BSF    19.7
006EC:  BCF    FF2.7
.................... 
.................... // Some LCDs require 15 ms minimum delay after
.................... // power-up.  Others require 30 ms.  I'm going
.................... // to set it to 35 ms, so it should work with
.................... // all of them.
.................... delay_ms(35);         
006EE:  MOVLW  23
006F0:  MOVWF  x89
006F2:  RCALL  0348
006F4:  BTFSC  19.7
006F6:  BSF    FF2.7
.................... 
.................... for(i=0 ;i < 3; i++)
006F8:  CLRF   x72
006FA:  MOVF   x72,W
006FC:  SUBLW  02
006FE:  BNC   071C
....................    {
....................     lcd_send_nibble(0x03);
00700:  MOVLW  03
00702:  MOVWF  x87
00704:  RCALL  05EA
00706:  CLRF   19
00708:  BTFSC  FF2.7
0070A:  BSF    19.7
0070C:  BCF    FF2.7
....................     delay_ms(5);
0070E:  MOVLW  05
00710:  MOVWF  x89
00712:  RCALL  0348
00714:  BTFSC  19.7
00716:  BSF    FF2.7
00718:  INCF   x72,F
0071A:  BRA    06FA
....................    }
.................... 
.................... lcd_send_nibble(0x02);
0071C:  MOVLW  02
0071E:  MOVWF  x87
00720:  RCALL  05EA
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
00722:  CLRF   x72
00724:  MOVF   x72,W
00726:  SUBLW  03
00728:  BNC   073C
....................    {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
0072A:  CLRF   03
0072C:  MOVF   x72,W
0072E:  RCALL  00CA
00730:  MOVWF  x73
00732:  CLRF   x84
00734:  MOVWF  x85
00736:  RCALL  0694
....................    
....................     // If the R/W signal is not used, then
....................     // the busy bit can't be polled.  One of
....................     // the init commands takes longer than
....................     // the hard-coded delay of 50 us, so in
....................     // that case, lets just do a 5 ms delay
....................     // after all four of them.
....................     #ifndef USE_RW_PIN
00738:  INCF   x72,F
0073A:  BRA    0724
....................     delay_ms(5);
....................     #endif
....................    }
0073C:  GOTO   14F2 (RETURN)
.................... 
.................... }
.................... 
.................... //----------------------------
.................... 
.................... void lcd_gotoxy(int8 x, int8 y)
.................... {
.................... int8 address;
.................... 
.................... 
.................... switch(y)
*
007C4:  MOVF   x81,W
007C6:  XORLW  01
007C8:  BZ    07D8
007CA:  XORLW  03
007CC:  BZ    07DC
007CE:  XORLW  01
007D0:  BZ    07E2
007D2:  XORLW  07
007D4:  BZ    07E8
007D6:  BRA    07EE
....................   {
....................    case 1:
....................      address = LCD_LINE_1_ADDRESS;
007D8:  CLRF   x82
....................      break;
007DA:  BRA    07F0
.................... 
....................    case 2:
....................      address = LCD_LINE_2_ADDRESS;
007DC:  MOVLW  40
007DE:  MOVWF  x82
....................      break;
007E0:  BRA    07F0
.................... 
....................    case 3:
....................      address = LCD_LINE_3_ADDRESS;
007E2:  MOVLW  14
007E4:  MOVWF  x82
....................      break;
007E6:  BRA    07F0
.................... 
....................    case 4:
....................      address = LCD_LINE_4_ADDRESS;
007E8:  MOVLW  54
007EA:  MOVWF  x82
....................      break;
007EC:  BRA    07F0
.................... 
....................    default:
....................      address = LCD_LINE_1_ADDRESS;
007EE:  CLRF   x82
....................      break;
....................      
....................   }
.................... 
.................... address += x-1;
007F0:  MOVLW  01
007F2:  SUBWF  x80,W
007F4:  ADDWF  x82,F
.................... lcd_send_byte(0, 0x80 | address);
007F6:  MOVF   x82,W
007F8:  IORLW  80
007FA:  MOVWF  x83
007FC:  CLRF   x84
007FE:  MOVWF  x85
00800:  RCALL  0694
00802:  RETURN 0
.................... }
.................... 
.................... //-----------------------------
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
00804:  MOVF   x7F,W
00806:  XORLW  0C
00808:  BZ    0814
0080A:  XORLW  06
0080C:  BZ    0834
0080E:  XORLW  02
00810:  BZ    0842
00812:  BRA    084C
....................    {
....................     case '\f':
....................       lcd_send_byte(0,1);
00814:  CLRF   x84
00816:  MOVLW  01
00818:  MOVWF  x85
0081A:  RCALL  0694
....................       lcd_line = 1;
0081C:  MOVLW  01
0081E:  MOVWF  20
00820:  CLRF   19
00822:  BTFSC  FF2.7
00824:  BSF    19.7
00826:  BCF    FF2.7
....................       delay_ms(2);
00828:  MOVLW  02
0082A:  MOVWF  x89
0082C:  RCALL  0348
0082E:  BTFSC  19.7
00830:  BSF    FF2.7
....................       break;
00832:  BRA    0856
....................    
....................     case '\n':
....................        lcd_gotoxy(1, ++lcd_line);
00834:  INCF   20,F
00836:  MOVLW  01
00838:  MOVWF  x80
0083A:  MOVFF  20,81
0083E:  RCALL  07C4
....................        break;
00840:  BRA    0856
....................    
....................     case '\b':
....................        lcd_send_byte(0,0x10);
00842:  CLRF   x84
00844:  MOVLW  10
00846:  MOVWF  x85
00848:  RCALL  0694
....................        break;
0084A:  BRA    0856
....................    
....................     default:
....................        lcd_send_byte(1,c);
0084C:  MOVLW  01
0084E:  MOVWF  x84
00850:  MOVFF  7F,85
00854:  RCALL  0694
....................        break;
....................    }
00856:  RETURN 0
.................... }
.................... 
.................... //------------------------------
.................... #ifdef USE_RW_PIN
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(LCD_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... 
.................... #include <internal_eeprom.c>
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////                          internal_eeprom.c                             ////
.................... ////                                                                        ////
.................... ////       Utilities to write various data types to internal eeprom         ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                        ////
.................... ////   void write_int1_eeprom(address, int8 bitPosition, int1 data)         ////
.................... ////     Call to write one bit of data                                      ////
.................... ////                                                                        ////
.................... ////   int1 read_int1_eeprom(address, int8 bitPosition)                     ////
.................... ////     Call to read one bit of data                                       ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_int16_eeprom(address, int16 data)                         ////
.................... ////     Call to write a 16 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   void write_int16_eeprom(address, int16 data)                         ////
.................... ////     Call to read a 16 bit integer                                      ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_int32_eeprom(address, int32 data)                         ////
.................... ////     Call to write a 32 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int16 read_int32_eeprom(address)                                     ////
.................... ////     Call to read a 32 bit integer                                      ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_float_eeprom(address, float data)                         ////
.................... ////     Call to write a 32 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float read_float_eeprom(address)                                     ////
.................... ////     Call to read a 32 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////  PCD only:                                                             ////
.................... ////   void write_int48_eeprom(address, int48 data)                         ////
.................... ////     Call to write a 48 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int48 read_int48_eeprom(address)                                     ////
.................... ////     Call to read a 48 bit integer                                      ////
.................... ////                                                                        ////
.................... ////   void write_int64_eeprom(address, int64 data)                         ////
.................... ////     Call to write a 64 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int64 read_int64_eeprom(address)                                     ////
.................... ////     Call to read a 64 bit integer                                      ////
.................... ////                                                                        ////
.................... ////   void write_float48_eeprom(address, float48 data)                     ////
.................... ////     Call to write a 48 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float48 read_float48_eeprom(address)                                 ////
.................... ////     Call to read a 48 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////   void write_float64_eeprom(address, float64 data)                     ////
.................... ////     Call to write a 64 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float64 read_float64_eeprom(address)                                 ////
.................... ////     Call to read a 64 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2012 Custom Computer Services               ////
.................... //// This source code may only be used by licensed users of the CCS C       ////
.................... //// compiler.  This source code may only be distributed to other licensed  ////
.................... //// users of the CCS C compiler.  No other use, reproduction or            ////
.................... //// distribution is permitted without written permission. Derivative       ////
.................... //// programs created using this software in object code form are not       ////
.................... //// restricted in any way.                                                 ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef INTERNAL_EEPROM_UTILITIES
.................... #define INTERNAL_EEPROM_UTILITIES
.................... 
.................... // Used to adjust the address range
.................... #ifndef INT_EEPROM_ADDRESS
....................    #if getenv("DATA_EEPROM") > 255
....................       #define INT_EEPROM_ADDRESS  unsigned int16
....................    #else
....................       #define INT_EEPROM_ADDRESS  unsigned int8
....................    #endif
.................... #endif
.................... 
.................... #ifndef INT_EEPROM_DATA_SIZE
....................    #ifdef (__PCD__)
....................       #define INT_EEPROM_DATA_SIZE unsigned int16
....................    #else
....................       #define INT_EEPROM_DATA_SIZE unsigned int8
....................    #endif
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //// Internal EEPROM Functions
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Write one bit to internal eeprom
.................... // Inputs:     1) An eeprom address
.................... //             2) The bit position (LSB == 0)
.................... //             3) The bit to write
.................... // Outputs:    None
.................... void write_int1_eeprom(INT_EEPROM_ADDRESS address, unsigned int8 bitPosition, int1 data)
.................... {
....................    INT_EEPROM_DATA_SIZE stored_data;
.................... 
....................    stored_data = read_eeprom(address);
.................... 
....................    if(data)
....................    {
....................       bit_set(stored_data, bitPosition);
....................    }
....................    else
....................    {
....................       bit_clear(stored_data, bitPosition);
....................    }
.................... 
....................    write_eeprom(address, stored_data);
.................... }
.................... 
.................... 
.................... // Purpose:    Read one bit from internal eeprom
.................... // Inputs:     1) An eeprom address
.................... //             2) The bit position (LSB == 0)
.................... // Outputs:    The bit read from internal eeprom
.................... int1 read_int1_eeprom(INT_EEPROM_ADDRESS address, unsigned int8 bitPosition)
.................... {
....................    return bit_test(read_eeprom(address), bitPosition);
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 16 bit number to internal eeprom
.................... // Inputs:     1) An eeprom address. Two eeprom locations will be used.
.................... //             2) The 16 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int16_eeprom(INT_EEPROM_ADDRESS address, unsigned int16 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address,data);
....................    #else
....................    int8 i;
.................... 
....................    for(i = 0; i < 2; ++i)
....................    {
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    }
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 16 bit number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 16 bit number read from internal eeprom
.................... unsigned int16 read_int16_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    #ifdef __PCD__
....................    return(read_eeprom(address));
....................    #else
....................    int8  i;
....................    int16 data;
.................... 
....................    for(i = 0; i < 2; ++i)
....................    {
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
....................    }
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 32 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used.
.................... //             2) The 32 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int32_eeprom(INT_EEPROM_ADDRESS address, unsigned int32 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address, &data, 4);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 32 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 32 bit integer read from internal eeprom
.................... unsigned int32 read_int32_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    #ifdef __PCD__
....................    return(read_eeprom(address, 4));
....................    #else
....................    int8  i;
....................    int32 data;
....................    
....................    for(i = 0; i < 4; i++)
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 32 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float_eeprom(INT_EEPROM_ADDRESS address, float32 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address, &data, 4);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 32 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float32 read_float_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float32 data;
.................... 
....................    #ifdef __PCD__
....................    read_eeprom(address, &data, 4);
....................    
....................    return(data);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... #ifdef __PCD__
.................... // Purpose:    Write a 48 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Six eeprom locations will be used.
.................... //             2) The 48 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int48_eeprom(INT_EEPROM_ADDRESS address, unsigned int48 data)
.................... {
....................    write_eeprom(address, &data, 6);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 48 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 48 bit integer read from internal eeprom
.................... unsigned int48 read_int48_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    return(read_eeprom(address, 6));
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 64 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Eight eeprom locations will be used.
.................... //             2) The 64 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int64_eeprom(INT_EEPROM_ADDRESS address, unsigned int64 data)
.................... {
....................    write_eeprom(address, &data, 8);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 64 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 64 bit integer read from internal eeprom
.................... unsigned int64 read_int64_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    return(read_eeprom(address, 8));
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 48 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Six eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float48_eeprom(INT_EEPROM_ADDRESS address, float48 data)
.................... {
....................    write_eeprom(address, &data, 6);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 48 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float48 read_float48_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float48 data;
.................... 
....................    read_eeprom(address, &data, 6);
....................    
....................    return(data);
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 64 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Eight eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float64_eeprom(INT_EEPROM_ADDRESS address, float64 data)
.................... {
....................    write_eeprom(address, &data, 8);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 64 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float64 read_float64_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float64 data;
.................... 
....................    read_eeprom(address, &data, 8);
....................    
....................    return(data);
.................... }
.................... 
.................... #endif   //__PCD__
....................    
.................... 
.................... #endif   //INTERNAL_EEPROM_UTILITIES
.................... 
.................... 
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PORT1)
.................... 
.................... #define A1 PIN_C2
.................... #define A2 PIN_C3
.................... #define B1 PIN_C0
.................... #define B2 PIN_C1
.................... 
.................... #define button0 PIN_D1 // AUTO MAN
.................... #define button1 PIN_D6 // L
.................... #define button2 PIN_D4 // D
.................... #define button3 PIN_D5 // R
.................... #define button4 PIN_D3 // U
.................... #define button5 PIN_D7 // SET MODE
.................... #define button6 PIN_D2 // CENTER
.................... 
.................... #define proxy_right PIN_C5
.................... #define proxy_left PIN_C4
.................... 
.................... #define three_dot 0
.................... #define swon 1
.................... #define swoff 2
.................... 
.................... int8 delay_s = 5;
.................... int speed = 0;
.................... int8 accel = 5;
.................... int accel_value = 30;
.................... int c = 0;
.................... 
.................... char mode_auto = False;
.................... char mode_manuel = True;
.................... char flag = TRUE;
.................... 
.................... char data;
.................... char str[4];
.................... int counter = 0;
.................... char correct = False;
.................... char quit1 = False;
.................... char quit2 = False;
.................... 
.................... char proxy = False;
.................... int control_left = 1;
.................... int control_right = 1;
.................... 
.................... char centered = False;
.................... unsigned int16 centercounter = 65535;
.................... int8 cc1, cc2;
.................... char center_flag = False;
.................... 
.................... unsigned int16 step = 350;
.................... int8 step1, step2;
.................... int line1 = 0;
.................... int linecheck = 0;
.................... int8 threshold = 0;
.................... int comm_counter = threshold - 1;
.................... unsigned int16 last_centercounter=65535;
.................... 
.................... char start = True;
.................... char q = False;
.................... char return_value = True;
.................... char check=False;
.................... 
.................... int dir = 0;
.................... char array1[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};
.................... int8 array2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
.................... TICK_TYPE StartTick, FinishTick, CurrentTick;
.................... 
.................... void delay_func(loop)
.................... {
.................... 
....................     // delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(250);delay_cycles(200);delay_cycles(200);
....................     delay_us(330);
*
0017A:  MOVLW  02
0017C:  MOVWF  x8B
0017E:  MOVLW  A5
00180:  MOVWF  x8C
00182:  BRA    015A
00184:  DECFSZ x8B,F
00186:  BRA    017E
....................     for (int i = 0; i < 10 - loop; i++)
00188:  CLRF   x8A
0018A:  MOVLW  0A
0018C:  BSF    FD8.0
0018E:  SUBFWB x89,W
00190:  SUBWF  x8A,W
00192:  BC    01A0
....................     {
....................         // delay_cycles(200);
....................         delay_us(40);
00194:  MOVLW  D5
00196:  MOVWF  00
00198:  DECFSZ 00,F
0019A:  BRA    0198
0019C:  INCF   x8A,F
0019E:  BRA    018A
....................     }
001A0:  RETURN 0
.................... }
.................... 
.................... void stop()
.................... {  
....................     disable_interrupts(INT_TIMER1);
*
00BA4:  BCF    F9D.0
....................     output_low(A1);
00BA6:  BCF    F94.2
00BA8:  BCF    F8B.2
....................     output_low(A2);
00BAA:  BCF    F94.3
00BAC:  BCF    F8B.3
....................     output_low(B1);
00BAE:  BCF    F94.0
00BB0:  BCF    F8B.0
....................     output_low(B2);
00BB2:  BCF    F94.1
00BB4:  BCF    F8B.1
00BB6:  RETURN 0
.................... }
.................... 
.................... char check_right_proxy()
.................... {
.................... 
....................     if (!(input(proxy_right)))
*
00CEA:  BSF    F94.5
00CEC:  BTFSC  F82.5
00CEE:  BRA    0D22
....................     {
....................         proxy = True;
00CF0:  MOVLW  01
00CF2:  MOVWF  32
.................... 
....................         if (!(control_right))
00CF4:  MOVF   34,F
00CF6:  BNZ   0D20
....................         {
....................             lcd_gotoxy(1, 4);
00CF8:  MOVLW  01
00CFA:  MOVWF  x80
00CFC:  MOVLW  04
00CFE:  MOVWF  x81
00D00:  RCALL  07C4
....................             lcd_putc(swon);
00D02:  MOVLW  01
00D04:  MOVWF  x7F
00D06:  RCALL  0804
....................             //delay_ms(1);
....................             //printf("y");
.................... 
....................             lcd_gotoxy(2, 4);
00D08:  MOVLW  02
00D0A:  MOVWF  x80
00D0C:  MOVLW  04
00D0E:  MOVWF  x81
00D10:  RCALL  07C4
....................             lcd_putc(" ");
00D12:  MOVLW  06
00D14:  MOVWF  FF6
00D16:  MOVLW  01
00D18:  MOVWF  FF7
00D1A:  RCALL  0858
.................... 
....................             control_right = True;
00D1C:  MOVLW  01
00D1E:  MOVWF  34
....................         }
....................     }
00D20:  BRA    0D3A
.................... 
....................     else
....................     {
.................... 
....................         proxy = False;
00D22:  CLRF   32
.................... 
....................         if (control_left)
00D24:  MOVF   33,F
00D26:  BZ    0D3A
....................         {
....................             lcd_gotoxy(20, 4);
00D28:  MOVLW  14
00D2A:  MOVWF  x80
00D2C:  MOVLW  04
00D2E:  MOVWF  x81
00D30:  RCALL  07C4
....................             lcd_putc(swoff);
00D32:  MOVLW  02
00D34:  MOVWF  x7F
00D36:  RCALL  0804
....................             control_left = False;
00D38:  CLRF   33
....................         }
....................     }
....................     return proxy;
00D3A:  MOVFF  32,01
00D3E:  RETURN 0
.................... }
.................... 
.................... char check_left_proxy()
.................... {
.................... 
....................     if (!(input(proxy_left)))
*
00B5A:  BSF    F94.4
00B5C:  BTFSC  F82.4
00B5E:  BRA    0B86
....................     {
....................         proxy = True;
00B60:  MOVLW  01
00B62:  MOVWF  32
....................         step = centercounter;
00B64:  MOVFF  37,3C
00B68:  MOVFF  36,3B
....................         
....................         if (!(control_left))
00B6C:  MOVF   33,F
00B6E:  BNZ   0B84
....................         {
.................... 
....................         lcd_gotoxy(20, 4);
00B70:  MOVLW  14
00B72:  MOVWF  x80
00B74:  MOVLW  04
00B76:  MOVWF  x81
00B78:  RCALL  07C4
....................         lcd_putc(swon);
00B7A:  MOVLW  01
00B7C:  MOVWF  x7F
00B7E:  RCALL  0804
....................         //delay_ms(1);
....................         //printf("x");
....................         control_left = True;
00B80:  MOVLW  01
00B82:  MOVWF  33
.................... 
....................     }
....................     }
00B84:  BRA    0B9E
.................... 
....................     else
....................     {
.................... 
....................         proxy = False;
00B86:  CLRF   32
.................... 
....................         if (control_right)
00B88:  MOVF   34,F
00B8A:  BZ    0B9E
....................         {
....................             lcd_gotoxy(1, 4);
00B8C:  MOVLW  01
00B8E:  MOVWF  x80
00B90:  MOVLW  04
00B92:  MOVWF  x81
00B94:  RCALL  07C4
....................             lcd_putc(swoff);
00B96:  MOVLW  02
00B98:  MOVWF  x7F
00B9A:  RCALL  0804
....................             control_right = False;
00B9C:  CLRF   34
....................         }
....................     }
.................... 
....................     return proxy;
00B9E:  MOVFF  32,01
00BA2:  RETURN 0
.................... }
.................... 
.................... void distance_measure()
.................... {
....................     comm_counter++;
*
00BFA:  INCF   42,F
.................... 
....................     if (step < threshold)
00BFC:  MOVF   3C,F
00BFE:  BNZ   0C0E
00C00:  MOVF   41,W
00C02:  SUBWF  3B,W
00C04:  BC    0C0E
....................     {
....................         step = threshold - 1;
00C06:  MOVLW  01
00C08:  SUBWF  41,W
00C0A:  MOVWF  3B
00C0C:  CLRF   3C
....................     }
.................... 
....................     if (comm_counter == 20)
00C0E:  MOVF   42,W
00C10:  SUBLW  14
00C12:  BNZ   0C28
....................     { 
....................         int8 step_data = step / 10;
00C14:  MOVFF  3C,7A
00C18:  MOVFF  3B,79
00C1C:  CLRF   x7C
00C1E:  MOVLW  0A
00C20:  MOVWF  x7B
00C22:  RCALL  0BB8
00C24:  MOVFF  01,78
....................         //printf("q%d", step_data);
....................     }
.................... 
....................     if (comm_counter == threshold | step <= threshold) //centered &
00C28:  MOVF   41,W
00C2A:  SUBWF  42,W
00C2C:  BZ    0C32
00C2E:  MOVLW  00
00C30:  BRA    0C34
00C32:  MOVLW  01
00C34:  MOVWF  x79
00C36:  MOVF   3C,F
00C38:  BNZ   0C40
00C3A:  MOVF   3B,W
00C3C:  SUBWF  41,W
00C3E:  BC    0C44
00C40:  MOVLW  00
00C42:  BRA    0C46
00C44:  MOVLW  01
00C46:  IORWF  x79,W
00C48:  BZ    0CDE
....................     { 
....................         comm_counter = 0;
00C4A:  CLRF   42
....................         line1 = (step / threshold);
00C4C:  MOVFF  3C,7A
00C50:  MOVFF  3B,79
00C54:  CLRF   x7C
00C56:  MOVFF  41,7B
00C5A:  RCALL  0BB8
00C5C:  MOVFF  01,3F
.................... 
....................         if (line1 > 18)
00C60:  MOVF   3F,W
00C62:  SUBLW  12
00C64:  BC    0C6A
....................         {
....................             line1 = 19;
00C66:  MOVLW  13
00C68:  MOVWF  3F
....................         }
.................... 
....................         if (line1 < 2)
00C6A:  MOVF   3F,W
00C6C:  SUBLW  01
00C6E:  BNC   0C74
....................         {
....................             line1 = 2;
00C70:  MOVLW  02
00C72:  MOVWF  3F
....................         }
.................... 
....................         if (line1 < linecheck)
00C74:  MOVF   40,W
00C76:  SUBWF  3F,W
00C78:  BC    0CCC
....................         {
.................... 
....................             if (line1 == 18)
00C7A:  MOVF   3F,W
00C7C:  SUBLW  12
00C7E:  BNZ   0C9A
....................             {
....................                 lcd_gotoxy(19, 4);
00C80:  MOVLW  13
00C82:  MOVWF  x80
00C84:  MOVLW  04
00C86:  MOVWF  x81
00C88:  RCALL  07C4
....................                 lcd_putc(" ");
00C8A:  MOVLW  08
00C8C:  MOVWF  FF6
00C8E:  MOVLW  01
00C90:  MOVWF  FF7
00C92:  RCALL  0858
....................                 linecheck = line1;
00C94:  MOVFF  3F,40
....................                 return;
00C98:  BRA    0CDE
....................             }
.................... 
....................             if (line1 == 1)
00C9A:  DECFSZ 3F,W
00C9C:  BRA    0CB8
....................             {
....................                 lcd_gotoxy(2, 4);
00C9E:  MOVLW  02
00CA0:  MOVWF  x80
00CA2:  MOVLW  04
00CA4:  MOVWF  x81
00CA6:  RCALL  07C4
....................                 lcd_putc(" ");
00CA8:  MOVLW  0A
00CAA:  MOVWF  FF6
00CAC:  MOVLW  01
00CAE:  MOVWF  FF7
00CB0:  RCALL  0858
....................                 linecheck = line1;
00CB2:  MOVFF  3F,40
....................                 return;
00CB6:  BRA    0CDE
....................             }
.................... 
....................             lcd_gotoxy(line1, 4);
00CB8:  MOVFF  3F,80
00CBC:  MOVLW  04
00CBE:  MOVWF  x81
00CC0:  RCALL  07C4
....................             lcd_putc("  ");
00CC2:  MOVLW  0C
00CC4:  MOVWF  FF6
00CC6:  MOVLW  01
00CC8:  MOVWF  FF7
00CCA:  RCALL  0858
....................         }
.................... 
....................         lcd_gotoxy(line1, 4);
00CCC:  MOVFF  3F,80
00CD0:  MOVLW  04
00CD2:  MOVWF  x81
00CD4:  RCALL  07C4
....................         lcd_putc(three_dot);
00CD6:  CLRF   x7F
00CD8:  RCALL  0804
.................... 
....................         linecheck = line1;
00CDA:  MOVFF  3F,40
....................     }
00CDE:  RETURN 0
.................... }
.................... 
.................... void normal()
.................... {
....................     dir = 1;
*
00D40:  MOVLW  01
00D42:  MOVWF  49
....................     enable_interrupts(INT_TIMER1);
00D44:  BSF    F9D.0
....................     distance_measure();
00D46:  RCALL  0BFA
....................     disable_interrupts(INT_TIMER1);
00D48:  BCF    F9D.0
00D4A:  RETURN 0
.................... 
....................     /*
....................           output_high (A1) ;
....................           output_low (A2) ;
....................           output_low (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_high (A1) ;
....................           output_low (A2) ;
....................           output_high (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_low (A2) ;
....................           output_high (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_high (A2) ;
....................           output_high (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_high (A2) ;
....................           output_low (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_high (A2) ;
....................           output_low (B1) ;
....................           output_high (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_low (A2) ;
....................           output_low (B1) ;
....................           output_high (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_high (A1) ;
....................           output_low (A2) ;
....................           output_low (B1) ;
....................           output_high (B2) ;
....................           delay_func (loop) ;
.................... 
....................           if(center_flag==True){
....................           centercounter=centercounter+1;
....................           }
.................... 
....................           step--;
.................... 
....................       */
.................... }
.................... 
.................... void reverse()
.................... {
....................     dir = 0;
*
00CE0:  CLRF   49
....................     enable_interrupts(INT_TIMER1);
00CE2:  BSF    F9D.0
....................     distance_measure();
00CE4:  RCALL  0BFA
....................     disable_interrupts(INT_TIMER1);
00CE6:  BCF    F9D.0
00CE8:  RETURN 0
.................... 
....................     /*
....................        output_high (A1);
....................        output_low (A2);
....................        output_low (B1);
....................        output_high (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_low (A2);
....................        output_low (B1);
....................        output_high (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_high (A2);
....................        output_low (B1);
....................        output_high (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_high (A2);
....................        output_low (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_high (A2);
....................        output_high (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_low (A2);
....................        output_high (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_high (A1);
....................        output_low (A2);
....................        output_high (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_high (A1);
....................        output_low (A2);
....................        output_low (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        step++;
....................     */
.................... }
.................... 
.................... char acc_start_normal_man()
.................... {
....................     output_high(pin_d4);
*
0125E:  BCF    F95.4
01260:  BSF    F8C.4
....................     while (start)
01262:  MOVF   45,F
01264:  BZ    12CE
....................     {   
....................       enable_interrupts(INT_RDA);
01266:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
01268:  MOVLW  0A
0126A:  BSF    FD8.0
0126C:  SUBFWB 23,W
0126E:  SUBWF  21,W
01270:  MOVWF  25
....................         for (int i = 0; i < 10 - accel; i++)
01272:  CLRF   x72
01274:  MOVLW  0A
01276:  BSF    FD8.0
01278:  SUBFWB 23,W
0127A:  SUBWF  x72,W
0127C:  BC    12C2
....................         {   
....................             enable_interrupts(INT_RDA);
0127E:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
01280:  CLRF   x73
01282:  MOVF   24,W
01284:  SUBWF  x73,W
01286:  BC    12BA
....................             {
....................                enable_interrupts(INT_RDA);
01288:  BSF    F9D.5
....................                 if ( !(input(button3)) | check_right_proxy() | (input(button1)) ) //!(input(button1)) 
0128A:  BSF    F95.5
0128C:  MOVLW  00
0128E:  BTFSS  F83.5
01290:  MOVLW  01
01292:  MOVWF  x74
01294:  RCALL  0CEA
01296:  MOVF   01,W
01298:  IORWF  x74,F
0129A:  BSF    F95.6
0129C:  MOVLW  00
0129E:  BTFSC  F83.6
012A0:  MOVLW  01
012A2:  IORWF  x74,W
012A4:  BZ    12B0
....................                 {
....................                     stop();
012A6:  RCALL  0BA4
....................                     return return_value = False;
012A8:  CLRF   47
012AA:  MOVFF  47,01
012AE:  BRA    12D2
....................                 }
.................... 
....................                 speed = c;
012B0:  MOVFF  25,22
....................                 normal();
012B4:  RCALL  0D40
012B6:  INCF   x73,F
012B8:  BRA    1282
....................             }
....................             c = c + 1;
012BA:  MOVLW  01
012BC:  ADDWF  25,F
012BE:  INCF   x72,F
012C0:  BRA    1274
....................         }
....................         start = False;
012C2:  CLRF   45
....................         return return_value = True;
012C4:  MOVLW  01
012C6:  MOVWF  47
012C8:  MOVWF  01
012CA:  BRA    12D2
012CC:  BRA    1262
....................     }
....................     output_low(pin_d4);
012CE:  BCF    F95.4
012D0:  BCF    F8C.4
012D2:  GOTO   20D2 (RETURN)
.................... }
.................... 
.................... char acc_start_reverse_man()
.................... {
....................     output_high(pin_d4);
012D6:  BCF    F95.4
012D8:  BSF    F8C.4
....................     while (start)
012DA:  MOVF   45,F
012DC:  BZ    1346
....................     {
....................          enable_interrupts(INT_RDA);
012DE:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
012E0:  MOVLW  0A
012E2:  BSF    FD8.0
012E4:  SUBFWB 23,W
012E6:  SUBWF  21,W
012E8:  MOVWF  25
....................         for (int i = 0; i < 10 - accel; i++)
012EA:  CLRF   x72
012EC:  MOVLW  0A
012EE:  BSF    FD8.0
012F0:  SUBFWB 23,W
012F2:  SUBWF  x72,W
012F4:  BC    133A
....................         {   
....................             enable_interrupts(INT_RDA);
012F6:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
012F8:  CLRF   x73
012FA:  MOVF   24,W
012FC:  SUBWF  x73,W
012FE:  BC    1332
....................             {
....................                 enable_interrupts(INT_RDA);
01300:  BSF    F9D.5
....................                 if ( !(input(button1))  | check_left_proxy() | (input(button3)) ) //!(input(button3))
01302:  BSF    F95.6
01304:  MOVLW  00
01306:  BTFSS  F83.6
01308:  MOVLW  01
0130A:  MOVWF  x74
0130C:  RCALL  0B5A
0130E:  MOVF   01,W
01310:  IORWF  x74,F
01312:  BSF    F95.5
01314:  MOVLW  00
01316:  BTFSC  F83.5
01318:  MOVLW  01
0131A:  IORWF  x74,W
0131C:  BZ    1328
....................                 {
....................                     stop();
0131E:  RCALL  0BA4
....................                     return return_value = False;
01320:  CLRF   47
01322:  MOVFF  47,01
01326:  BRA    134A
....................                 }
....................                 speed = c;
01328:  MOVFF  25,22
....................                 reverse();
0132C:  RCALL  0CE0
0132E:  INCF   x73,F
01330:  BRA    12FA
....................             }
....................             c = c + 1;
01332:  MOVLW  01
01334:  ADDWF  25,F
01336:  INCF   x72,F
01338:  BRA    12EC
....................         }
....................         start = False;
0133A:  CLRF   45
....................         return return_value = True;
0133C:  MOVLW  01
0133E:  MOVWF  47
01340:  MOVWF  01
01342:  BRA    134A
01344:  BRA    12DA
....................     }
....................     output_low(pin_d4);
01346:  BCF    F95.4
01348:  BCF    F8C.4
0134A:  GOTO   2138 (RETURN)
.................... }
.................... 
.................... char acc_start_normal_auto()
.................... {
....................     while (start)
*
011D4:  MOVF   45,F
011D6:  BZ    125C
....................     {
....................         enable_interrupts(INT_RDA);
011D8:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
011DA:  MOVLW  0A
011DC:  BSF    FD8.0
011DE:  SUBFWB 23,W
011E0:  SUBWF  21,W
011E2:  MOVWF  25
....................         for (int i = 0; i < 10 - accel; i++)
011E4:  CLRF   x72
011E6:  MOVLW  0A
011E8:  BSF    FD8.0
011EA:  SUBFWB 23,W
011EC:  SUBWF  x72,W
011EE:  BC    1250
....................         {   
....................             enable_interrupts(INT_RDA);
011F0:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
011F2:  CLRF   x73
011F4:  MOVF   24,W
011F6:  SUBWF  x73,W
011F8:  BC    1248
....................             {
....................                 enable_interrupts(INT_RDA);
011FA:  BSF    F9D.5
....................                 if (!(input(button1)) | !(input(button3)) | check_right_proxy() | str[0] != 'l' | str[1] != '1' )
011FC:  BSF    F95.6
011FE:  MOVLW  00
01200:  BTFSS  F83.6
01202:  MOVLW  01
01204:  MOVWF  x74
01206:  BSF    F95.5
01208:  MOVLW  00
0120A:  BTFSS  F83.5
0120C:  MOVLW  01
0120E:  IORWF  x74,F
01210:  RCALL  0CEA
01212:  MOVF   01,W
01214:  IORWF  x74,F
01216:  MOVF   2A,W
01218:  SUBLW  6C
0121A:  BNZ   1220
0121C:  MOVLW  00
0121E:  BRA    1222
01220:  MOVLW  01
01222:  IORWF  x74,F
01224:  MOVF   2B,W
01226:  SUBLW  31
01228:  BNZ   122E
0122A:  MOVLW  00
0122C:  BRA    1230
0122E:  MOVLW  01
01230:  IORWF  x74,W
01232:  BZ    123E
....................                 {
....................                     stop();
01234:  RCALL  0BA4
....................                     return return_value = False;
01236:  CLRF   47
01238:  MOVFF  47,01
0123C:  BRA    125C
....................                 }
....................                 speed = c;
0123E:  MOVFF  25,22
....................                 normal();
01242:  RCALL  0D40
01244:  INCF   x73,F
01246:  BRA    11F4
....................             }
....................             c = c + 1;
01248:  MOVLW  01
0124A:  ADDWF  25,F
0124C:  INCF   x72,F
0124E:  BRA    11E6
....................         }
....................         start = False;
01250:  CLRF   45
....................         return return_value = True;
01252:  MOVLW  01
01254:  MOVWF  47
01256:  MOVWF  01
01258:  BRA    125C
0125A:  BRA    11D4
....................     }
0125C:  RETURN 0
.................... }
.................... 
.................... char acc_start_reverse_auto()
.................... {
.................... 
....................     while (start == True)
*
0134E:  DECFSZ 45,W
01350:  BRA    13DA
....................     {   
....................         enable_interrupts(INT_RDA);
01352:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
01354:  MOVLW  0A
01356:  BSF    FD8.0
01358:  SUBFWB 23,W
0135A:  SUBWF  21,W
0135C:  MOVWF  25
....................         for (int i = 0; i < 10 - accel; i++)
0135E:  CLRF   x72
01360:  MOVLW  0A
01362:  BSF    FD8.0
01364:  SUBFWB 23,W
01366:  SUBWF  x72,W
01368:  BC    13CE
....................         {   
....................             enable_interrupts(INT_RDA);
0136A:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
0136C:  CLRF   x73
0136E:  MOVF   24,W
01370:  SUBWF  x73,W
01372:  BC    13C6
....................             {
....................                 enable_interrupts(INT_RDA);
01374:  BSF    F9D.5
....................                 if (!(input(button1))  | !(input(button3)) | check_left_proxy() | str[0] != 'r' | str[1] != '1' )
01376:  BSF    F95.6
01378:  MOVLW  00
0137A:  BTFSS  F83.6
0137C:  MOVLW  01
0137E:  MOVWF  x74
01380:  BSF    F95.5
01382:  MOVLW  00
01384:  BTFSS  F83.5
01386:  MOVLW  01
01388:  IORWF  x74,F
0138A:  CALL   0B5A
0138E:  MOVF   01,W
01390:  IORWF  x74,F
01392:  MOVF   2A,W
01394:  SUBLW  72
01396:  BNZ   139C
01398:  MOVLW  00
0139A:  BRA    139E
0139C:  MOVLW  01
0139E:  IORWF  x74,F
013A0:  MOVF   2B,W
013A2:  SUBLW  31
013A4:  BNZ   13AA
013A6:  MOVLW  00
013A8:  BRA    13AC
013AA:  MOVLW  01
013AC:  IORWF  x74,W
013AE:  BZ    13BC
....................                 {
....................                     stop();
013B0:  CALL   0BA4
....................                     return return_value = False;
013B4:  CLRF   47
013B6:  MOVFF  47,01
013BA:  BRA    13DA
....................                 }
....................                 speed = c;
013BC:  MOVFF  25,22
....................                 reverse();
013C0:  RCALL  0CE0
013C2:  INCF   x73,F
013C4:  BRA    136E
....................             }
....................             c = c + 1;
013C6:  MOVLW  01
013C8:  ADDWF  25,F
013CA:  INCF   x72,F
013CC:  BRA    1360
....................         }
....................         start = False;
013CE:  CLRF   45
....................         return return_value = True;
013D0:  MOVLW  01
013D2:  MOVWF  47
013D4:  MOVWF  01
013D6:  BRA    13DA
013D8:  BRA    134E
....................     }
013DA:  GOTO   230E (RETURN)
.................... }
.................... 
.................... float read_serial_speed()
.................... {
....................     /*
....................      if (str[0] == 's'){
....................         output_toggle(pin_d4);
.................... 
....................         if (str[1] == '0'){
.................... 
....................            for(int i=0;i<=8;i++){
....................               if(str[2]==array1[i])
....................               {
....................                  delay_s=array2[i];
....................                  break;
....................               }
....................            }
.................... 
....................         }
.................... 
....................         if (str[1] == '1'){
....................            delay_s=10;
....................         }
.................... 
....................      }
.................... 
....................      return delay_s;
....................      */
.................... 
....................     if (str[0] == 'h')
*
00A5E:  MOVF   2A,W
00A60:  SUBLW  68
00A62:  BNZ   0AD2
....................     {
....................         output_toggle(pin_d4);
00A64:  BCF    F95.4
00A66:  BTG    F8C.4
....................         if (str[1] == '0')
00A68:  MOVF   2B,W
00A6A:  SUBLW  30
00A6C:  BNZ   0AC8
....................         {
.................... 
....................             if (str[2] == '1')
00A6E:  MOVF   2C,W
00A70:  SUBLW  31
00A72:  BNZ   0A78
....................             {
....................                 delay_s = 1;
00A74:  MOVLW  01
00A76:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '2')
00A78:  MOVF   2C,W
00A7A:  SUBLW  32
00A7C:  BNZ   0A82
....................             {
....................                 delay_s = 2;
00A7E:  MOVLW  02
00A80:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '3')
00A82:  MOVF   2C,W
00A84:  SUBLW  33
00A86:  BNZ   0A8C
....................             {
....................                 delay_s = 3;
00A88:  MOVLW  03
00A8A:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '4')
00A8C:  MOVF   2C,W
00A8E:  SUBLW  34
00A90:  BNZ   0A96
....................             {
....................                 delay_s = 4;
00A92:  MOVLW  04
00A94:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '5')
00A96:  MOVF   2C,W
00A98:  SUBLW  35
00A9A:  BNZ   0AA0
....................             {
....................                 delay_s = 5;
00A9C:  MOVLW  05
00A9E:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '6')
00AA0:  MOVF   2C,W
00AA2:  SUBLW  36
00AA4:  BNZ   0AAA
....................             {
....................                 delay_s = 6;
00AA6:  MOVLW  06
00AA8:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '7')
00AAA:  MOVF   2C,W
00AAC:  SUBLW  37
00AAE:  BNZ   0AB4
....................             {
....................                 delay_s = 7;
00AB0:  MOVLW  07
00AB2:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '8')
00AB4:  MOVF   2C,W
00AB6:  SUBLW  38
00AB8:  BNZ   0ABE
....................             {
....................                 delay_s = 8;
00ABA:  MOVLW  08
00ABC:  MOVWF  21
....................             }
.................... 
....................             if (str[2] == '9')
00ABE:  MOVF   2C,W
00AC0:  SUBLW  39
00AC2:  BNZ   0AC8
....................             {
....................                 delay_s = 9;
00AC4:  MOVLW  09
00AC6:  MOVWF  21
....................             }
....................         }
.................... 
....................         if (str[1] == '1')
00AC8:  MOVF   2B,W
00ACA:  SUBLW  31
00ACC:  BNZ   0AD2
....................         {
....................             delay_s = 10;
00ACE:  MOVLW  0A
00AD0:  MOVWF  21
....................         }
....................     }
....................     return delay_s;
00AD2:  CLRF   x74
00AD4:  MOVFF  21,73
00AD8:  RCALL  0A28
00ADA:  RETURN 0
.................... }
.................... 
.................... void read_serial_mode()
.................... {
.................... 
....................     if (str[0] == 'm')
*
00A04:  MOVF   2A,W
00A06:  SUBLW  6D
00A08:  BNZ   0A26
....................     {
....................         output_toggle(pin_d4);
00A0A:  BCF    F95.4
00A0C:  BTG    F8C.4
.................... 
....................         if (str[1] == '0')
00A0E:  MOVF   2B,W
00A10:  SUBLW  30
00A12:  BNZ   0A1A
....................         {
....................             mode_AUTO = False;
00A14:  CLRF   26
....................             mode_manuel = True;
00A16:  MOVLW  01
00A18:  MOVWF  27
....................         }
.................... 
....................         if (str[1] == '1')
00A1A:  MOVF   2B,W
00A1C:  SUBLW  31
00A1E:  BNZ   0A26
....................         {
....................             mode_AUTO = True;
00A20:  MOVLW  01
00A22:  MOVWF  26
....................             mode_manuel = False;
00A24:  CLRF   27
....................         }
....................     }
00A26:  RETURN 0
.................... }
.................... 
.................... float read_serial_acc()
.................... {
.................... 
....................     if (str[0] == 'a')
*
00ADC:  MOVF   2A,W
00ADE:  SUBLW  61
00AE0:  BNZ   0B50
....................     {
....................         output_toggle(pin_d4);
00AE2:  BCF    F95.4
00AE4:  BTG    F8C.4
....................         if (str[1] == '0')
00AE6:  MOVF   2B,W
00AE8:  SUBLW  30
00AEA:  BNZ   0B46
....................         {
.................... 
....................             if (str[2] == '1')
00AEC:  MOVF   2C,W
00AEE:  SUBLW  31
00AF0:  BNZ   0AF6
....................             {
....................                 accel = 1;
00AF2:  MOVLW  01
00AF4:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '2')
00AF6:  MOVF   2C,W
00AF8:  SUBLW  32
00AFA:  BNZ   0B00
....................             {
....................                 accel = 2;
00AFC:  MOVLW  02
00AFE:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '3')
00B00:  MOVF   2C,W
00B02:  SUBLW  33
00B04:  BNZ   0B0A
....................             {
....................                 accel = 3;
00B06:  MOVLW  03
00B08:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '4')
00B0A:  MOVF   2C,W
00B0C:  SUBLW  34
00B0E:  BNZ   0B14
....................             {
....................                 accel = 4;
00B10:  MOVLW  04
00B12:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '5')
00B14:  MOVF   2C,W
00B16:  SUBLW  35
00B18:  BNZ   0B1E
....................             {
....................                 accel = 5;
00B1A:  MOVLW  05
00B1C:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '6')
00B1E:  MOVF   2C,W
00B20:  SUBLW  36
00B22:  BNZ   0B28
....................             {
....................                 accel = 6;
00B24:  MOVLW  06
00B26:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '7')
00B28:  MOVF   2C,W
00B2A:  SUBLW  37
00B2C:  BNZ   0B32
....................             {
....................                 accel = 7;
00B2E:  MOVLW  07
00B30:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '8')
00B32:  MOVF   2C,W
00B34:  SUBLW  38
00B36:  BNZ   0B3C
....................             {
....................                 accel = 8;
00B38:  MOVLW  08
00B3A:  MOVWF  23
....................             }
.................... 
....................             if (str[2] == '9')
00B3C:  MOVF   2C,W
00B3E:  SUBLW  39
00B40:  BNZ   0B46
....................             {
....................                 accel = 9;
00B42:  MOVLW  09
00B44:  MOVWF  23
....................             }
....................         }
.................... 
....................         if (str[1] == '1')
00B46:  MOVF   2B,W
00B48:  SUBLW  31
00B4A:  BNZ   0B50
....................         {
....................             accel = 10;
00B4C:  MOVLW  0A
00B4E:  MOVWF  23
....................         }
....................     }
....................     return accel;
00B50:  CLRF   x74
00B52:  MOVFF  23,73
00B56:  RCALL  0A28
00B58:  RETURN 0
.................... }
.................... 
.................... void centerline(delay)
.................... {     
....................     lcd_gotoxy(13, 1);
*
00D6C:  MOVLW  0D
00D6E:  MOVWF  x80
00D70:  MOVLW  01
00D72:  MOVWF  x81
00D74:  RCALL  07C4
....................     lcd_putc("<Center>");
00D76:  MOVLW  10
00D78:  MOVWF  FF6
00D7A:  MOVLW  01
00D7C:  MOVWF  FF7
00D7E:  RCALL  0858
....................             
....................     last_centercounter=0;
00D80:  CLRF   44
00D82:  CLRF   43
....................     lcd_gotoxy(1, 4);
00D84:  MOVLW  01
00D86:  MOVWF  x80
00D88:  MOVLW  04
00D8A:  MOVWF  x81
00D8C:  RCALL  07C4
....................     lcd_putc(swoff);
00D8E:  MOVLW  02
00D90:  MOVWF  x7F
00D92:  RCALL  0804
....................     lcd_gotoxy(20, 4);
00D94:  MOVLW  14
00D96:  MOVWF  x80
00D98:  MOVLW  04
00D9A:  MOVWF  x81
00D9C:  RCALL  07C4
....................     lcd_putc(swoff);
00D9E:  MOVLW  02
00DA0:  MOVWF  x7F
00DA2:  RCALL  0804
....................     lcd_gotoxy(2, 4);
00DA4:  MOVLW  02
00DA6:  MOVWF  x80
00DA8:  MOVLW  04
00DAA:  MOVWF  x81
00DAC:  RCALL  07C4
....................     //lcd_putc("     Homing...    ");
....................     speed = 6;
00DAE:  MOVLW  06
00DB0:  MOVWF  22
....................     //centered = False;
....................     //centercounter = 0;
.................... 
....................     while (1)
....................     {
....................         enable_interrupts(INT_RDA);
00DB2:  BSF    F9D.5
.................... 
....................         if (check_left_proxy())
00DB4:  RCALL  0B5A
00DB6:  MOVF   01,F
00DB8:  BZ    0DD8
....................         {
....................             stop();
00DBA:  RCALL  0BA4
00DBC:  CLRF   19
00DBE:  BTFSC  FF2.7
00DC0:  BSF    19.7
00DC2:  BCF    FF2.7
....................             delay_ms(250);
00DC4:  MOVLW  FA
00DC6:  MOVWF  x89
00DC8:  CALL   0348
00DCC:  BTFSC  19.7
00DCE:  BSF    FF2.7
....................             output_toggle(PIN_D4);
00DD0:  BCF    F95.4
00DD2:  BTG    F8C.4
....................             correct = False;
00DD4:  CLRF   2F
.................... 
....................             break;
00DD6:  BRA    0E02
....................         }
.................... 
....................         if (!(input(button1)) | !(input(button3)))
00DD8:  BSF    F95.6
00DDA:  MOVLW  00
00DDC:  BTFSS  F83.6
00DDE:  MOVLW  01
00DE0:  MOVWF  x76
00DE2:  BSF    F95.5
00DE4:  MOVLW  00
00DE6:  BTFSS  F83.5
00DE8:  MOVLW  01
00DEA:  IORWF  x76,W
00DEC:  BZ    0DFE
....................         {
....................             stop();
00DEE:  RCALL  0BA4
....................             lcd_gotoxy(1, 4);
00DF0:  MOVLW  01
00DF2:  MOVWF  x80
00DF4:  MOVLW  04
00DF6:  MOVWF  x81
00DF8:  RCALL  07C4
....................             centered = False;
00DFA:  CLRF   35
.................... 
....................             return;
00DFC:  BRA    0F7A
....................         }
.................... 
....................         reverse();
00DFE:  RCALL  0CE0
00E00:  BRA    0DB2
....................     }
.................... 
....................     while (1)
....................     {
....................         enable_interrupts(INT_RDA);
00E02:  BSF    F9D.5
.................... 
....................         center_flag = True;
00E04:  MOVLW  01
00E06:  MOVWF  3A
.................... 
....................         if (check_right_proxy())
00E08:  RCALL  0CEA
00E0A:  MOVF   01,F
00E0C:  BZ    0E2C
....................         {
....................             stop();
00E0E:  RCALL  0BA4
00E10:  CLRF   19
00E12:  BTFSC  FF2.7
00E14:  BSF    19.7
00E16:  BCF    FF2.7
....................             delay_ms(250);
00E18:  MOVLW  FA
00E1A:  MOVWF  x89
00E1C:  CALL   0348
00E20:  BTFSC  19.7
00E22:  BSF    FF2.7
....................             correct = False;
00E24:  CLRF   2F
....................             step = 0;
00E26:  CLRF   3C
00E28:  CLRF   3B
....................             break;
00E2A:  BRA    0E56
....................         }
.................... 
....................         if (!(input(button1)) | !(input(button3)))
00E2C:  BSF    F95.6
00E2E:  MOVLW  00
00E30:  BTFSS  F83.6
00E32:  MOVLW  01
00E34:  MOVWF  x76
00E36:  BSF    F95.5
00E38:  MOVLW  00
00E3A:  BTFSS  F83.5
00E3C:  MOVLW  01
00E3E:  IORWF  x76,W
00E40:  BZ    0E52
....................         {
....................             stop();
00E42:  RCALL  0BA4
....................             lcd_gotoxy(1, 4);
00E44:  MOVLW  01
00E46:  MOVWF  x80
00E48:  MOVLW  04
00E4A:  MOVWF  x81
00E4C:  RCALL  07C4
....................             centered = False; 
00E4E:  CLRF   35
....................             return;
00E50:  BRA    0F7A
....................         }
.................... 
....................         normal();
00E52:  RCALL  0D40
00E54:  BRA    0E02
.................... 
....................         // printf("data: %s", centercounter);
....................     }
.................... 
....................     while (step < last_centercounter / 2)
00E56:  BCF    FD8.0
00E58:  RRCF   44,W
00E5A:  MOVWF  03
00E5C:  RRCF   43,W
00E5E:  MOVWF  02
00E60:  MOVWF  01
00E62:  MOVF   3C,W
00E64:  SUBWF  03,W
00E66:  BNC   0EAA
00E68:  BNZ   0E70
00E6A:  MOVF   01,W
00E6C:  SUBWF  3B,W
00E6E:  BC    0EAA
....................     {
....................         enable_interrupts(INT_RDA);
00E70:  BSF    F9D.5
.................... 
....................         center_flag = False;
00E72:  CLRF   3A
....................         CurrentTick = get_ticks();
00E74:  RCALL  0772
00E76:  MOVFF  03,67
00E7A:  MOVFF  02,66
00E7E:  MOVFF  01,65
00E82:  MOVFF  00,64
.................... 
....................         if (!(input(button1)) | !(input(button3)) | check_left_proxy())
00E86:  BSF    F95.6
00E88:  MOVLW  00
00E8A:  BTFSS  F83.6
00E8C:  MOVLW  01
00E8E:  MOVWF  x76
00E90:  BSF    F95.5
00E92:  MOVLW  00
00E94:  BTFSS  F83.5
00E96:  MOVLW  01
00E98:  IORWF  x76,F
00E9A:  RCALL  0B5A
00E9C:  MOVF   x76,W
00E9E:  IORWF  01,W
00EA0:  BZ    0EA6
....................         {
....................             stop();
00EA2:  RCALL  0BA4
....................             return;
00EA4:  BRA    0F7A
....................         }
.................... 
....................         reverse();
00EA6:  RCALL  0CE0
00EA8:  BRA    0E56
....................     }
.................... 
....................     stop();
00EAA:  RCALL  0BA4
....................     lcd_putc("\f");
00EAC:  MOVLW  1A
00EAE:  MOVWF  FF6
00EB0:  MOVLW  01
00EB2:  MOVWF  FF7
00EB4:  RCALL  0858
.................... 
....................     lcd_gotoxy(1, 3);
00EB6:  MOVLW  01
00EB8:  MOVWF  x80
00EBA:  MOVLW  03
00EBC:  MOVWF  x81
00EBE:  RCALL  07C4
....................     centercounter = last_centercounter;
00EC0:  MOVFF  44,37
00EC4:  MOVFF  43,36
....................     centercounter=centercounter+3;
00EC8:  MOVLW  03
00ECA:  ADDWF  36,F
00ECC:  MOVLW  00
00ECE:  ADDWFC 37,F
....................     printf(lcd_putc, "count: %Lu", centercounter);
00ED0:  MOVLW  1C
00ED2:  MOVWF  FF6
00ED4:  MOVLW  01
00ED6:  MOVWF  FF7
00ED8:  MOVLW  07
00EDA:  MOVWF  x76
00EDC:  BRA    0D4C
00EDE:  MOVLW  10
00EE0:  MOVWF  FE9
00EE2:  MOVFF  37,77
00EE6:  MOVFF  36,76
00EEA:  RCALL  0878
....................     step = centercounter / 2;
00EEC:  BCF    FD8.0
00EEE:  RRCF   37,W
00EF0:  MOVWF  3C
00EF2:  RRCF   36,W
00EF4:  MOVWF  3B
....................     centered = True;
00EF6:  MOVLW  01
00EF8:  MOVWF  35
....................     center_flag = False;
00EFA:  CLRF   3A
....................     threshold = (centercounter / 20);
00EFC:  MOVFF  37,7A
00F00:  MOVFF  36,79
00F04:  CLRF   x7C
00F06:  MOVLW  14
00F08:  MOVWF  x7B
00F0A:  RCALL  0BB8
00F0C:  MOVFF  01,41
....................       
....................     comm_counter = threshold - 1;
00F10:  MOVLW  01
00F12:  SUBWF  41,W
00F14:  MOVWF  42
....................     
....................     //printf("t%d", threshold);
....................     //delay_ms(35);
....................     int8 step_data = step / 10;
00F16:  MOVFF  3C,7A
00F1A:  MOVFF  3B,79
00F1E:  CLRF   x7C
00F20:  MOVLW  0A
00F22:  MOVWF  x7B
00F24:  RCALL  0BB8
00F26:  MOVFF  01,74
....................     //printf("q%d", step_data);
.................... 
....................     line1 = (step / threshold);
00F2A:  MOVFF  3C,7A
00F2E:  MOVFF  3B,79
00F32:  CLRF   x7C
00F34:  MOVFF  41,7B
00F38:  RCALL  0BB8
00F3A:  MOVFF  01,3F
.................... 
....................     lcd_gotoxy(1, 4);
00F3E:  MOVLW  01
00F40:  MOVWF  x80
00F42:  MOVLW  04
00F44:  MOVWF  x81
00F46:  RCALL  07C4
....................     lcd_putc(swoff);
00F48:  MOVLW  02
00F4A:  MOVWF  x7F
00F4C:  RCALL  0804
....................     lcd_gotoxy(20, 4);
00F4E:  MOVLW  14
00F50:  MOVWF  x80
00F52:  MOVLW  04
00F54:  MOVWF  x81
00F56:  RCALL  07C4
....................     lcd_putc(swoff);
00F58:  MOVLW  02
00F5A:  MOVWF  x7F
00F5C:  RCALL  0804
.................... 
....................     for (int i = 2; i <= 10; i++)
00F5E:  MOVLW  02
00F60:  MOVWF  x75
00F62:  MOVF   x75,W
00F64:  SUBLW  0A
00F66:  BNC   0F7A
....................     {
....................         lcd_gotoxy(i, 4);
00F68:  MOVFF  75,80
00F6C:  MOVLW  04
00F6E:  MOVWF  x81
00F70:  RCALL  07C4
....................         lcd_putc(three_dot);
00F72:  CLRF   x7F
00F74:  RCALL  0804
00F76:  INCF   x75,F
00F78:  BRA    0F62
....................     }
.................... 
....................     return;
00F7A:  RETURN 0
.................... }
.................... 
.................... void gogo()
00F7C:  MOVLW  01
00F7E:  MOVWF  x73
.................... {
....................     char start = True;
.................... 
....................     output_toggle(PIN_D4);
00F80:  BCF    F95.4
00F82:  BTG    F8C.4
.................... 
....................     while (1)
....................     {     
....................         enable_interrupts(INT_RDA);
00F84:  BSF    F9D.5
....................         while (1)
....................         {
....................             enable_interrupts(INT_RDA);
00F86:  BSF    F9D.5
....................             while (start == True)
00F88:  DECFSZ x73,W
00F8A:  BRA    101A
....................             {
....................                 enable_interrupts(INT_RDA);
00F8C:  BSF    F9D.5
.................... 
....................                 c = abs(delay_s - (10 - accel));
00F8E:  MOVLW  0A
00F90:  BSF    FD8.0
00F92:  SUBFWB 23,W
00F94:  SUBWF  21,W
00F96:  MOVWF  25
....................                 for (int i = 0; i < 10 - accel; i++)
00F98:  CLRF   x74
00F9A:  MOVLW  0A
00F9C:  BSF    FD8.0
00F9E:  SUBFWB 23,W
00FA0:  SUBWF  x74,W
00FA2:  BC    1016
....................                 {    
.................... 
....................                 enable_interrupts(INT_RDA);
00FA4:  BSF    F9D.5
....................                 
....................                     for (int j = 0; j < accel_value; j++)
00FA6:  CLRF   x75
00FA8:  MOVF   24,W
00FAA:  SUBWF  x75,W
00FAC:  BC    100E
....................                     {
.................... 
....................                 enable_interrupts(INT_RDA);
00FAE:  BSF    F9D.5
.................... 
....................                         if (!(input(button1)) | !(input(button3)) | !(input(button4)) | str[0]!='g' )
00FB0:  BSF    F95.6
00FB2:  MOVLW  00
00FB4:  BTFSS  F83.6
00FB6:  MOVLW  01
00FB8:  MOVWF  x78
00FBA:  BSF    F95.5
00FBC:  MOVLW  00
00FBE:  BTFSS  F83.5
00FC0:  MOVLW  01
00FC2:  IORWF  x78,F
00FC4:  BSF    F95.3
00FC6:  MOVLW  00
00FC8:  BTFSS  F83.3
00FCA:  MOVLW  01
00FCC:  IORWF  x78,F
00FCE:  MOVF   2A,W
00FD0:  SUBLW  67
00FD2:  BNZ   0FD8
00FD4:  MOVLW  00
00FD6:  BRA    0FDA
00FD8:  MOVLW  01
00FDA:  IORWF  x78,W
00FDC:  BZ    0FE2
....................                         {
....................                             stop();
00FDE:  RCALL  0BA4
....................                             return;
00FE0:  BRA    116E
....................                         }
.................... 
....................                         if (check_left_proxy())
00FE2:  RCALL  0B5A
00FE4:  MOVF   01,F
00FE6:  BZ    1004
....................                         {
....................                             start = True;
00FE8:  MOVLW  01
00FEA:  MOVWF  x73
....................                             stop();
00FEC:  RCALL  0BA4
00FEE:  CLRF   19
00FF0:  BTFSC  FF2.7
00FF2:  BSF    19.7
00FF4:  BCF    FF2.7
....................                             delay_ms(100);
00FF6:  MOVLW  64
00FF8:  MOVWF  x89
00FFA:  CALL   0348
00FFE:  BTFSC  19.7
01000:  BSF    FF2.7
....................                             break;
01002:  BRA    100E
....................                         }
....................                         speed = c;
01004:  MOVFF  25,22
....................                         reverse();
01008:  RCALL  0CE0
0100A:  INCF   x75,F
0100C:  BRA    0FA8
....................                     }
....................                     c = c + 1;
0100E:  MOVLW  01
01010:  ADDWF  25,F
01012:  INCF   x74,F
01014:  BRA    0F9A
....................                 }
....................                 start = False;
01016:  CLRF   x73
01018:  BRA    0F88
....................             }
.................... 
....................             if (check_left_proxy())
0101A:  RCALL  0B5A
0101C:  MOVF   01,F
0101E:  BZ    1042
....................             {
....................                 stop();
01020:  RCALL  0BA4
....................                 output_toggle(PIN_D4);
01022:  BCF    F95.4
01024:  BTG    F8C.4
01026:  CLRF   19
01028:  BTFSC  FF2.7
0102A:  BSF    19.7
0102C:  BCF    FF2.7
....................                 delay_ms(100);
0102E:  MOVLW  64
01030:  MOVWF  x89
01032:  CALL   0348
01036:  BTFSC  19.7
01038:  BSF    FF2.7
....................                 start = True;
0103A:  MOVLW  01
0103C:  MOVWF  x73
....................                 correct = False;
0103E:  CLRF   2F
....................                 break;
01040:  BRA    107C
....................             }
.................... 
....................             if (!(input(button5)) | !(input(button1))  | !(input(button3)) | str[0]!='g' )
01042:  BSF    F95.7
01044:  MOVLW  00
01046:  BTFSS  F83.7
01048:  MOVLW  01
0104A:  MOVWF  x78
0104C:  BSF    F95.6
0104E:  MOVLW  00
01050:  BTFSS  F83.6
01052:  MOVLW  01
01054:  IORWF  x78,F
01056:  BSF    F95.5
01058:  MOVLW  00
0105A:  BTFSS  F83.5
0105C:  MOVLW  01
0105E:  IORWF  x78,F
01060:  MOVF   2A,W
01062:  SUBLW  67
01064:  BNZ   106A
01066:  MOVLW  00
01068:  BRA    106C
0106A:  MOVLW  01
0106C:  IORWF  x78,W
0106E:  BZ    1074
....................             {
....................                 stop();
01070:  RCALL  0BA4
....................                 return;
01072:  BRA    116E
....................             }
....................             speed = c;
01074:  MOVFF  25,22
....................             reverse();
01078:  RCALL  0CE0
0107A:  BRA    0F86
....................         }
.................... 
....................         while (1)
....................         {         
....................             enable_interrupts(INT_RDA);
0107C:  BSF    F9D.5
....................             while (start == True)
0107E:  DECFSZ x73,W
01080:  BRA    110E
....................             {     
.................... 
....................                 enable_interrupts(INT_RDA);
01082:  BSF    F9D.5
.................... 
....................                 c = abs(delay_s - (10 - accel));
01084:  MOVLW  0A
01086:  BSF    FD8.0
01088:  SUBFWB 23,W
0108A:  SUBWF  21,W
0108C:  MOVWF  25
....................                 for (int i = 0; i < 10 - accel; i++)
0108E:  CLRF   x76
01090:  MOVLW  0A
01092:  BSF    FD8.0
01094:  SUBFWB 23,W
01096:  SUBWF  x76,W
01098:  BC    110A
....................                 {    
.................... 
....................                 enable_interrupts(INT_RDA);
0109A:  BSF    F9D.5
.................... 
....................                     for (int j = 0; j < accel_value; j++)
0109C:  CLRF   x77
0109E:  MOVF   24,W
010A0:  SUBWF  x77,W
010A2:  BC    1102
....................                     {      
.................... 
....................                 enable_interrupts(INT_RDA);
010A4:  BSF    F9D.5
.................... 
....................                         if (!(input(button1)) | !(input(button3)) | str[0]!='g' )
010A6:  BSF    F95.6
010A8:  MOVLW  00
010AA:  BTFSS  F83.6
010AC:  MOVLW  01
010AE:  MOVWF  x78
010B0:  BSF    F95.5
010B2:  MOVLW  00
010B4:  BTFSS  F83.5
010B6:  MOVLW  01
010B8:  IORWF  x78,F
010BA:  MOVF   2A,W
010BC:  SUBLW  67
010BE:  BNZ   10C4
010C0:  MOVLW  00
010C2:  BRA    10C6
010C4:  MOVLW  01
010C6:  IORWF  x78,W
010C8:  BZ    10CE
....................                         {
....................                             stop();
010CA:  RCALL  0BA4
....................                             return;
010CC:  BRA    116E
....................                         }
.................... 
....................                         if (check_right_proxy())
010CE:  RCALL  0CEA
010D0:  MOVF   01,F
010D2:  BZ    10F8
....................                         {
....................                             start = True;
010D4:  MOVLW  01
010D6:  MOVWF  x73
....................                             stop();
010D8:  RCALL  0BA4
....................                             delay_ms(500);
010DA:  MOVLW  02
010DC:  MOVWF  x78
010DE:  CLRF   19
010E0:  BTFSC  FF2.7
010E2:  BSF    19.7
010E4:  BCF    FF2.7
010E6:  MOVLW  FA
010E8:  MOVWF  x89
010EA:  CALL   0348
010EE:  BTFSC  19.7
010F0:  BSF    FF2.7
010F2:  DECFSZ x78,F
010F4:  BRA    10DE
....................                             break;
010F6:  BRA    1102
....................                         }
....................                         speed = c;
010F8:  MOVFF  25,22
....................                         normal();
010FC:  RCALL  0D40
010FE:  INCF   x77,F
01100:  BRA    109E
....................                     }
....................                     c = c + 1;
01102:  MOVLW  01
01104:  ADDWF  25,F
01106:  INCF   x76,F
01108:  BRA    1090
....................                 }
....................                 start = False;
0110A:  CLRF   x73
0110C:  BRA    107E
....................             }
.................... 
....................             if (check_right_proxy())
0110E:  RCALL  0CEA
01110:  MOVF   01,F
01112:  BZ    1132
....................             {
....................                 stop();
01114:  RCALL  0BA4
01116:  CLRF   19
01118:  BTFSC  FF2.7
0111A:  BSF    19.7
0111C:  BCF    FF2.7
....................                 delay_ms(100);
0111E:  MOVLW  64
01120:  MOVWF  x89
01122:  CALL   0348
01126:  BTFSC  19.7
01128:  BSF    FF2.7
....................                 start = True;
0112A:  MOVLW  01
0112C:  MOVWF  x73
....................                 correct = False;
0112E:  CLRF   2F
....................                 break;
01130:  BRA    116C
....................             }
.................... 
....................             if (!(input(button5)) | !(input(button1)) | !(input(button3)) | str[0]!='g' )
01132:  BSF    F95.7
01134:  MOVLW  00
01136:  BTFSS  F83.7
01138:  MOVLW  01
0113A:  MOVWF  x78
0113C:  BSF    F95.6
0113E:  MOVLW  00
01140:  BTFSS  F83.6
01142:  MOVLW  01
01144:  IORWF  x78,F
01146:  BSF    F95.5
01148:  MOVLW  00
0114A:  BTFSS  F83.5
0114C:  MOVLW  01
0114E:  IORWF  x78,F
01150:  MOVF   2A,W
01152:  SUBLW  67
01154:  BNZ   115A
01156:  MOVLW  00
01158:  BRA    115C
0115A:  MOVLW  01
0115C:  IORWF  x78,W
0115E:  BZ    1164
....................             {
....................                 stop();
01160:  RCALL  0BA4
....................                 return;
01162:  BRA    116E
....................             }
.................... 
....................             speed = c;
01164:  MOVFF  25,22
....................             normal();
01168:  RCALL  0D40
0116A:  BRA    107C
....................         }
0116C:  BRA    0F84
....................     }
0116E:  RETURN 0
.................... }
.................... 
.................... void seri_check(){
.................... 
.................... enable_interrupts(INT_RDA);
01170:  BSF    F9D.5
.................... 
.................... if(correct){
01172:  MOVF   2F,F
01174:  BZ    11D0
....................       enable_interrupts(INT_RDA);
01176:  BSF    F9D.5
....................       
....................       read_serial_mode();
01178:  RCALL  0A04
....................       read_serial_speed();
0117A:  RCALL  0A5E
....................       read_serial_acc();
0117C:  RCALL  0ADC
.................... 
....................       if (str[0] == 'c')
0117E:  MOVF   2A,W
01180:  SUBLW  63
01182:  BNZ   118A
....................       {
....................           centerline(6);
01184:  MOVLW  06
01186:  MOVWF  x73
01188:  RCALL  0D6C
....................       }
.................... 
....................       if (str[0] == 'g')
0118A:  MOVF   2A,W
0118C:  SUBLW  67
0118E:  BNZ   1192
....................       {
....................           gogo();
01190:  RCALL  0F7C
....................       }
.................... 
....................       if (str[0] == 'd')// usb connected, send commands to pc
01192:  MOVF   2A,W
01194:  SUBLW  64
01196:  BNZ   11D0
....................       { 
....................           //printf("x");
....................           //delay_ms(50);
....................           //printf("h0%d", delay_s);
....................           //delay_ms(50);
....................           //printf("a0%d", accel);
....................           //delay_ms(50);
.................... 
....................           if (mode_manuel)
01198:  MOVF   27,F
0119A:  BZ    119C
....................           {
....................               //printf("m0");
....................           }
.................... 
....................           if (mode_auto)
0119C:  MOVF   26,F
0119E:  BZ    11A0
011A0:  CLRF   19
011A2:  BTFSC  FF2.7
011A4:  BSF    19.7
011A6:  BCF    FF2.7
....................           {
....................               //printf("m1");
....................           }
.................... 
....................           delay_ms(50);
011A8:  MOVLW  32
011AA:  MOVWF  x89
011AC:  CALL   0348
011B0:  BTFSC  19.7
011B2:  BSF    FF2.7
.................... 
....................           if (centered)
011B4:  MOVF   35,F
011B6:  BZ    11B8
....................           {
....................               //printf("t%d", threshold);
....................           }
.................... 
....................           //delay_ms(50);
....................           int8 step_data = step / 10;
011B8:  MOVFF  3C,7A
011BC:  MOVFF  3B,79
011C0:  CLRF   x7C
011C2:  MOVLW  0A
011C4:  MOVWF  x7B
011C6:  RCALL  0BB8
011C8:  MOVFF  01,72
....................           //printf("q%d", step_data);
....................           
....................           str[0]='0';
011CC:  MOVLW  30
011CE:  MOVWF  2A
....................       }
.................... }
011D0:  GOTO   1A5C (RETURN)
.................... }
.................... 
.................... #INT_RDA fast
.................... void serial_comm()
.................... {
....................     disable_interrupts(int_rda);
*
00128:  BCF    F9D.5
....................     // lcd_putc ("data received: ") ;
....................     data = getc();
0012A:  BTFSS  F9E.5
0012C:  BRA    012A
0012E:  MOVFF  FAE,29
....................     //printf(data);
....................     // lcd_putc (data) ;
....................     str[counter] = data;
00132:  CLRF   03
00134:  MOVF   2E,W
00136:  ADDLW  2A
00138:  MOVWF  FE9
0013A:  MOVLW  00
0013C:  ADDWFC 03,W
0013E:  MOVWF  FEA
00140:  MOVFF  29,FEF
....................     // lcd_putc (str[counter]) ;
....................     counter++;
00144:  INCF   2E,F
....................     // lcd_putc (str[counter]) ;
....................     if (data == '!')
00146:  MOVF   29,W
00148:  SUBLW  21
0014A:  BNZ   0156
....................     {
....................         /*
....................             lcd_putc ("Data: ");
....................             for (int i = 0; i < counter - 1; i++)
....................             {
....................                lcd_putc (str[i]);
....................             }
....................         */
....................         counter = 0;
0014C:  CLRF   2E
....................         correct = True;
0014E:  MOVLW  01
00150:  MOVWF  2F
....................         output_toggle (PIN_D4);
00152:  BCF    F95.4
00154:  BTG    F8C.4
....................         // printf("OK");
.................... 
....................         // lcd_putc ('\f');
....................     }
....................     
00156:  BCF    F9E.5
00158:  RETFIE 1
.................... }
.................... 
.................... ////////////////////////////////////////
.................... 
.................... const int8 lcd_custom_chars[] =
....................     {
.................... 
....................         // Char Number 0 -- THREE
....................         0x00,
....................         0x00,
....................         0x15,
....................         0x15,
....................         0x15,
....................         0x15,
....................         0x15,
....................         0x00,
.................... 
....................         // Char Number 1 -- SW on
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
.................... 
....................         // 2  Sw off
.................... 
....................         0x1F,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x1F
.................... 
.................... };
.................... void lcd_load_custom_chars()
.................... {
....................     int8 i;
.................... 
....................     // Set address counter pointing to CGRAM address 0.
....................     lcd_send_byte(0, 0x40);
*
00740:  CLRF   x84
00742:  MOVLW  40
00744:  MOVWF  x85
00746:  RCALL  0694
.................... 
....................     // Load custom lcd character data into CGRAM.
....................     // It can only hold a maximum of 8 custom characters.
....................     for (i = 0; i < sizeof(lcd_custom_chars); i++)
00748:  CLRF   x72
0074A:  MOVF   x72,W
0074C:  SUBLW  17
0074E:  BNC   0766
....................     {
....................         lcd_send_byte(1, lcd_custom_chars[i]);
00750:  CLRF   03
00752:  MOVF   x72,W
00754:  RCALL  00DE
00756:  MOVWF  x73
00758:  MOVLW  01
0075A:  MOVWF  x84
0075C:  MOVFF  73,85
00760:  RCALL  0694
00762:  INCF   x72,F
00764:  BRA    074A
....................     }
.................... 
....................     // Set address counter pointing back to the DDRAM.
....................     lcd_send_byte(0, 0x80);
00766:  CLRF   x84
00768:  MOVLW  80
0076A:  MOVWF  x85
0076C:  RCALL  0694
0076E:  GOTO   14F6 (RETURN)
.................... }
.................... 
.................... #int_timer1
.................... void Timer1_isr(void)
.................... {
....................     // output_toggle(PIN_D4);
.................... 
....................     if (dir == 0)
*
001A2:  MOVF   49,F
001A4:  BNZ   0272
....................     {
....................         delay_func(speed);
001A6:  MOVFF  22,89
001AA:  RCALL  017A
....................         output_high(A1);
001AC:  BCF    F94.2
001AE:  BSF    F8B.2
....................         output_low(A2);
001B0:  BCF    F94.3
001B2:  BCF    F8B.3
....................         output_low(B1);
001B4:  BCF    F94.0
001B6:  BCF    F8B.0
....................         output_high(B2);
001B8:  BCF    F94.1
001BA:  BSF    F8B.1
....................         delay_func(speed);
001BC:  MOVFF  22,89
001C0:  RCALL  017A
.................... 
....................         output_low(A1);
001C2:  BCF    F94.2
001C4:  BCF    F8B.2
....................         output_low(A2);
001C6:  BCF    F94.3
001C8:  BCF    F8B.3
....................         output_low(B1);
001CA:  BCF    F94.0
001CC:  BCF    F8B.0
....................         output_high(B2);
001CE:  BCF    F94.1
001D0:  BSF    F8B.1
....................         delay_func(speed);
001D2:  MOVFF  22,89
001D6:  RCALL  017A
.................... 
....................         output_low(A1);
001D8:  BCF    F94.2
001DA:  BCF    F8B.2
....................         output_high(A2);
001DC:  BCF    F94.3
001DE:  BSF    F8B.3
....................         output_low(B1);
001E0:  BCF    F94.0
001E2:  BCF    F8B.0
....................         output_high(B2);
001E4:  BCF    F94.1
001E6:  BSF    F8B.1
....................         delay_func(speed);
001E8:  MOVFF  22,89
001EC:  RCALL  017A
.................... 
....................         output_low(A1);
001EE:  BCF    F94.2
001F0:  BCF    F8B.2
....................         output_high(A2);
001F2:  BCF    F94.3
001F4:  BSF    F8B.3
....................         output_low(B1);
001F6:  BCF    F94.0
001F8:  BCF    F8B.0
....................         output_low(B2);
001FA:  BCF    F94.1
001FC:  BCF    F8B.1
....................         delay_func(speed);
001FE:  MOVFF  22,89
00202:  RCALL  017A
.................... 
....................         output_low(A1);
00204:  BCF    F94.2
00206:  BCF    F8B.2
....................         output_high(A2);
00208:  BCF    F94.3
0020A:  BSF    F8B.3
....................         output_high(B1);
0020C:  BCF    F94.0
0020E:  BSF    F8B.0
....................         output_low(B2);
00210:  BCF    F94.1
00212:  BCF    F8B.1
....................         delay_func(speed);
00214:  MOVFF  22,89
00218:  RCALL  017A
.................... 
....................         output_low(A1);
0021A:  BCF    F94.2
0021C:  BCF    F8B.2
....................         output_low(A2);
0021E:  BCF    F94.3
00220:  BCF    F8B.3
....................         output_high(B1);
00222:  BCF    F94.0
00224:  BSF    F8B.0
....................         output_low(B2);
00226:  BCF    F94.1
00228:  BCF    F8B.1
....................         delay_func(speed);
0022A:  MOVFF  22,89
0022E:  RCALL  017A
.................... 
....................         output_high(A1);
00230:  BCF    F94.2
00232:  BSF    F8B.2
....................         output_low(A2);
00234:  BCF    F94.3
00236:  BCF    F8B.3
....................         output_high(B1);
00238:  BCF    F94.0
0023A:  BSF    F8B.0
....................         output_low(B2);
0023C:  BCF    F94.1
0023E:  BCF    F8B.1
....................         delay_func(speed);
00240:  MOVFF  22,89
00244:  RCALL  017A
.................... 
....................         output_high(A1);
00246:  BCF    F94.2
00248:  BSF    F8B.2
....................         output_low(A2);
0024A:  BCF    F94.3
0024C:  BCF    F8B.3
....................         output_low(B1);
0024E:  BCF    F94.0
00250:  BCF    F8B.0
....................         output_low(B2);
00252:  BCF    F94.1
00254:  BCF    F8B.1
.................... 
....................         step++;
00256:  INCF   3B,F
00258:  BTFSC  FD8.2
0025A:  INCF   3C,F
....................       
....................         if (step > centercounter)
0025C:  MOVF   37,W
0025E:  SUBWF  3C,W
00260:  BNC   0272
00262:  BNZ   026A
00264:  MOVF   3B,W
00266:  SUBWF  36,W
00268:  BC    0272
....................         {
....................             step = centercounter;
0026A:  MOVFF  37,3C
0026E:  MOVFF  36,3B
....................         }
....................         
....................     }
....................     if (dir == 1)
00272:  DECFSZ 49,W
00274:  BRA    0338
....................     {
....................         delay_func(speed);
00276:  MOVFF  22,89
0027A:  RCALL  017A
....................         output_high(A1);
0027C:  BCF    F94.2
0027E:  BSF    F8B.2
....................         output_low(A2);
00280:  BCF    F94.3
00282:  BCF    F8B.3
....................         output_low(B1);
00284:  BCF    F94.0
00286:  BCF    F8B.0
....................         output_low(B2);
00288:  BCF    F94.1
0028A:  BCF    F8B.1
....................         delay_func(speed);
0028C:  MOVFF  22,89
00290:  RCALL  017A
.................... 
....................         output_high(A1);
00292:  BCF    F94.2
00294:  BSF    F8B.2
....................         output_low(A2);
00296:  BCF    F94.3
00298:  BCF    F8B.3
....................         output_high(B1);
0029A:  BCF    F94.0
0029C:  BSF    F8B.0
....................         output_low(B2);
0029E:  BCF    F94.1
002A0:  BCF    F8B.1
....................         delay_func(speed);
002A2:  MOVFF  22,89
002A6:  RCALL  017A
.................... 
....................         output_low(A1);
002A8:  BCF    F94.2
002AA:  BCF    F8B.2
....................         output_low(A2);
002AC:  BCF    F94.3
002AE:  BCF    F8B.3
....................         output_high(B1);
002B0:  BCF    F94.0
002B2:  BSF    F8B.0
....................         output_low(B2);
002B4:  BCF    F94.1
002B6:  BCF    F8B.1
....................         delay_func(speed);
002B8:  MOVFF  22,89
002BC:  RCALL  017A
.................... 
....................         output_low(A1);
002BE:  BCF    F94.2
002C0:  BCF    F8B.2
....................         output_high(A2);
002C2:  BCF    F94.3
002C4:  BSF    F8B.3
....................         output_high(B1);
002C6:  BCF    F94.0
002C8:  BSF    F8B.0
....................         output_low(B2);
002CA:  BCF    F94.1
002CC:  BCF    F8B.1
....................         delay_func(speed);
002CE:  MOVFF  22,89
002D2:  RCALL  017A
.................... 
....................         output_low(A1);
002D4:  BCF    F94.2
002D6:  BCF    F8B.2
....................         output_high(A2);
002D8:  BCF    F94.3
002DA:  BSF    F8B.3
....................         output_low(B1);
002DC:  BCF    F94.0
002DE:  BCF    F8B.0
....................         output_low(B2);
002E0:  BCF    F94.1
002E2:  BCF    F8B.1
....................         delay_func(speed);
002E4:  MOVFF  22,89
002E8:  RCALL  017A
.................... 
....................         output_low(A1);
002EA:  BCF    F94.2
002EC:  BCF    F8B.2
....................         output_high(A2);
002EE:  BCF    F94.3
002F0:  BSF    F8B.3
....................         output_low(B1);
002F2:  BCF    F94.0
002F4:  BCF    F8B.0
....................         output_high(B2);
002F6:  BCF    F94.1
002F8:  BSF    F8B.1
....................         delay_func(speed);
002FA:  MOVFF  22,89
002FE:  RCALL  017A
.................... 
....................         output_low(A1);
00300:  BCF    F94.2
00302:  BCF    F8B.2
....................         output_low(A2);
00304:  BCF    F94.3
00306:  BCF    F8B.3
....................         output_low(B1);
00308:  BCF    F94.0
0030A:  BCF    F8B.0
....................         output_high(B2);
0030C:  BCF    F94.1
0030E:  BSF    F8B.1
....................         delay_func(speed);
00310:  MOVFF  22,89
00314:  RCALL  017A
.................... 
....................         output_high(A1);
00316:  BCF    F94.2
00318:  BSF    F8B.2
....................         output_low(A2);
0031A:  BCF    F94.3
0031C:  BCF    F8B.3
....................         output_low(B1);
0031E:  BCF    F94.0
00320:  BCF    F8B.0
....................         output_high(B2);
00322:  BCF    F94.1
00324:  BSF    F8B.1
.................... 
....................         step--;
00326:  MOVF   3B,W
00328:  BTFSC  FD8.2
0032A:  DECF   3C,F
0032C:  DECF   3B,F
.................... 
....................         if (center_flag)
0032E:  MOVF   3A,F
00330:  BZ    0338
....................         {
....................             last_centercounter++;
00332:  INCF   43,F
00334:  BTFSC  FD8.2
00336:  INCF   44,F
....................         }
....................     }
.................... 
....................     set_timer1(65486);
00338:  SETF   FCF
0033A:  MOVLW  CE
0033C:  MOVWF  FCE
0033E:  NOP   
....................     //restart_wdt();
....................     clear_interrupt(INT_TIMER1);
00340:  BCF    F9E.0
....................     // disable_interrupts(INT_TIMER1);
.................... }
.................... 
00342:  BCF    F9E.0
00344:  GOTO   007C
.................... #INT_HLVD
.................... void LOWVOLT_isr(void)
.................... {
....................     disable_interrupts(INT_TIMER1);
*
00370:  BCF    F9D.0
....................     disable_interrupts(INT_RDA);
00372:  BCF    F9D.5
.................... 
....................     delay_ms(10);
00374:  MOVLW  0A
00376:  MOVWF  x89
00378:  RCALL  0348
....................    
....................     write_eeprom(1, delay_s);  // speed
0037A:  MOVF   FF2,W
0037C:  MOVWF  00
0037E:  BCF    FF2.7
00380:  CLRF   FAA
00382:  MOVLW  01
00384:  MOVWF  FA9
00386:  MOVFF  21,FA8
0038A:  BCF    FA6.6
0038C:  BCF    FA6.7
0038E:  BSF    FA6.2
00390:  MOVLB  F
00392:  MOVLW  55
00394:  MOVWF  FA7
00396:  MOVLW  AA
00398:  MOVWF  FA7
0039A:  BSF    FA6.1
0039C:  BTFSC  FA6.1
0039E:  BRA    039C
003A0:  BCF    FA6.2
003A2:  MOVF   00,W
003A4:  IORWF  FF2,F
.................... 
....................     
....................     write_eeprom(2, accel);    // accel
003A6:  MOVFF  FF2,00
003AA:  BCF    FF2.7
003AC:  CLRF   FAA
003AE:  MOVLW  02
003B0:  MOVWF  FA9
003B2:  MOVFF  23,FA8
003B6:  BCF    FA6.6
003B8:  BCF    FA6.7
003BA:  BSF    FA6.2
003BC:  MOVLW  55
003BE:  MOVWF  FA7
003C0:  MOVLW  AA
003C2:  MOVWF  FA7
003C4:  BSF    FA6.1
003C6:  BTFSC  FA6.1
003C8:  BRA    03C6
003CA:  BCF    FA6.2
003CC:  MOVF   00,W
003CE:  IORWF  FF2,F
.................... 
....................     
....................     write_eeprom(3, centered); // centered?
003D0:  MOVFF  FF2,00
003D4:  BCF    FF2.7
003D6:  CLRF   FAA
003D8:  MOVLW  03
003DA:  MOVWF  FA9
003DC:  MOVFF  35,FA8
003E0:  BCF    FA6.6
003E2:  BCF    FA6.7
003E4:  BSF    FA6.2
003E6:  MOVLW  55
003E8:  MOVWF  FA7
003EA:  MOVLW  AA
003EC:  MOVWF  FA7
003EE:  BSF    FA6.1
003F0:  BTFSC  FA6.1
003F2:  BRA    03F0
003F4:  BCF    FA6.2
003F6:  MOVF   00,W
003F8:  IORWF  FF2,F
.................... 
....................     
....................     step1 = make8(step, 0);
003FA:  MOVFF  3B,3D
....................     step2 = make8(step, 1);
003FE:  MOVFF  3C,3E
....................     write_eeprom(4, step1); // pos1
00402:  MOVFF  FF2,00
00406:  BCF    FF2.7
00408:  CLRF   FAA
0040A:  MOVLW  04
0040C:  MOVWF  FA9
0040E:  MOVFF  3D,FA8
00412:  BCF    FA6.6
00414:  BCF    FA6.7
00416:  BSF    FA6.2
00418:  MOVLW  55
0041A:  MOVWF  FA7
0041C:  MOVLW  AA
0041E:  MOVWF  FA7
00420:  BSF    FA6.1
00422:  BTFSC  FA6.1
00424:  BRA    0422
00426:  BCF    FA6.2
00428:  MOVF   00,W
0042A:  IORWF  FF2,F
....................  
....................     write_eeprom(5, step2); // pos2
0042C:  MOVFF  FF2,00
00430:  BCF    FF2.7
00432:  CLRF   FAA
00434:  MOVLW  05
00436:  MOVWF  FA9
00438:  MOVFF  3E,FA8
0043C:  BCF    FA6.6
0043E:  BCF    FA6.7
00440:  BSF    FA6.2
00442:  MOVLW  55
00444:  MOVWF  FA7
00446:  MOVLW  AA
00448:  MOVWF  FA7
0044A:  BSF    FA6.1
0044C:  BTFSC  FA6.1
0044E:  BRA    044C
00450:  BCF    FA6.2
00452:  MOVF   00,W
00454:  IORWF  FF2,F
.................... 
....................     
....................     write_eeprom(6, threshold); // threshold
00456:  MOVFF  FF2,00
0045A:  BCF    FF2.7
0045C:  CLRF   FAA
0045E:  MOVLW  06
00460:  MOVWF  FA9
00462:  MOVFF  41,FA8
00466:  BCF    FA6.6
00468:  BCF    FA6.7
0046A:  BSF    FA6.2
0046C:  MOVLW  55
0046E:  MOVWF  FA7
00470:  MOVLW  AA
00472:  MOVWF  FA7
00474:  BSF    FA6.1
00476:  BTFSC  FA6.1
00478:  BRA    0476
0047A:  BCF    FA6.2
0047C:  MOVF   00,W
0047E:  IORWF  FF2,F
.................... 
....................     cc1 = make8(centercounter, 0);
00480:  MOVFF  36,38
....................     cc2 = make8(centercounter, 1);
00484:  MOVFF  37,39
....................     write_eeprom(7, cc1); // cc1
00488:  MOVFF  FF2,00
0048C:  BCF    FF2.7
0048E:  CLRF   FAA
00490:  MOVLW  07
00492:  MOVWF  FA9
00494:  MOVFF  38,FA8
00498:  BCF    FA6.6
0049A:  BCF    FA6.7
0049C:  BSF    FA6.2
0049E:  MOVLW  55
004A0:  MOVWF  FA7
004A2:  MOVLW  AA
004A4:  MOVWF  FA7
004A6:  BSF    FA6.1
004A8:  BTFSC  FA6.1
004AA:  BRA    04A8
004AC:  BCF    FA6.2
004AE:  MOVF   00,W
004B0:  IORWF  FF2,F
....................     write_eeprom(8, cc2); // cc2
004B2:  MOVFF  FF2,00
004B6:  BCF    FF2.7
004B8:  CLRF   FAA
004BA:  MOVLW  08
004BC:  MOVWF  FA9
004BE:  MOVFF  39,FA8
004C2:  BCF    FA6.6
004C4:  BCF    FA6.7
004C6:  BSF    FA6.2
004C8:  MOVLW  55
004CA:  MOVWF  FA7
004CC:  MOVLW  AA
004CE:  MOVWF  FA7
004D0:  BSF    FA6.1
004D2:  BTFSC  FA6.1
004D4:  BRA    04D2
004D6:  BCF    FA6.2
004D8:  MOVF   00,W
004DA:  IORWF  FF2,F
.................... 
....................     write_eeprom(9, line1);
004DC:  MOVFF  FF2,00
004E0:  BCF    FF2.7
004E2:  CLRF   FAA
004E4:  MOVLW  09
004E6:  MOVWF  FA9
004E8:  MOVFF  3F,FA8
004EC:  BCF    FA6.6
004EE:  BCF    FA6.7
004F0:  BSF    FA6.2
004F2:  MOVLW  55
004F4:  MOVWF  FA7
004F6:  MOVLW  AA
004F8:  MOVWF  FA7
004FA:  BSF    FA6.1
004FC:  BTFSC  FA6.1
004FE:  BRA    04FC
00500:  BCF    FA6.2
00502:  MOVF   00,W
00504:  IORWF  FF2,F
.................... 
....................     write_eeprom(10, control_right);
00506:  MOVFF  FF2,00
0050A:  BCF    FF2.7
0050C:  CLRF   FAA
0050E:  MOVLW  0A
00510:  MOVWF  FA9
00512:  MOVFF  34,FA8
00516:  BCF    FA6.6
00518:  BCF    FA6.7
0051A:  BSF    FA6.2
0051C:  MOVLW  55
0051E:  MOVWF  FA7
00520:  MOVLW  AA
00522:  MOVWF  FA7
00524:  BSF    FA6.1
00526:  BTFSC  FA6.1
00528:  BRA    0526
0052A:  BCF    FA6.2
0052C:  MOVF   00,W
0052E:  IORWF  FF2,F
....................     write_eeprom(11, control_left);
00530:  MOVFF  FF2,00
00534:  BCF    FF2.7
00536:  CLRF   FAA
00538:  MOVLW  0B
0053A:  MOVWF  FA9
0053C:  MOVFF  33,FA8
00540:  BCF    FA6.6
00542:  BCF    FA6.7
00544:  BSF    FA6.2
00546:  MOVLW  55
00548:  MOVWF  FA7
0054A:  MOVLW  AA
0054C:  MOVWF  FA7
0054E:  BSF    FA6.1
00550:  BTFSC  FA6.1
00552:  BRA    0550
00554:  BCF    FA6.2
00556:  MOVF   00,W
00558:  IORWF  FF2,F
.................... 
....................     output_high(pin_E0);
0055A:  BCF    F96.0
0055C:  BSF    F8D.0
.................... 
.................... 
....................     disable_interrupts(INT_HLVD);
0055E:  BCF    FA0.2
00560:  BCF    FA1.2
00562:  MOVLB  0
00564:  GOTO   007C
.................... }
.................... 
.................... void main()
*
013DE:  CLRF   FF8
013E0:  BCF    F9F.0
013E2:  BSF    F9F.5
013E4:  BCF    FA2.2
013E6:  BSF    FD0.7
013E8:  BSF    07.7
013EA:  MOVLW  70
013EC:  MOVWF  FD3
013EE:  BSF    F9B.6
013F0:  BCF    F9B.7
013F2:  CLRF   1D
013F4:  CLRF   1C
013F6:  CLRF   1B
013F8:  CLRF   1A
013FA:  BCF    FD5.7
013FC:  MOVLW  87
013FE:  MOVWF  FD5
01400:  CLRF   FD7
01402:  CLRF   FD6
01404:  NOP   
01406:  BCF    FF2.2
01408:  BSF    FB8.3
0140A:  MOVLW  82
0140C:  MOVWF  FAF
0140E:  MOVLW  06
01410:  MOVWF  FB0
01412:  MOVLW  A6
01414:  MOVWF  FAC
01416:  MOVLW  90
01418:  MOVWF  FAB
0141A:  MOVLW  05
0141C:  MOVWF  21
0141E:  CLRF   22
01420:  MOVWF  23
01422:  MOVLW  1E
01424:  MOVWF  24
01426:  CLRF   25
01428:  CLRF   26
0142A:  MOVLW  01
0142C:  MOVWF  27
0142E:  MOVWF  28
01430:  CLRF   2E
01432:  CLRF   2F
01434:  CLRF   30
01436:  CLRF   31
01438:  CLRF   32
0143A:  MOVWF  33
0143C:  MOVWF  34
0143E:  CLRF   35
01440:  SETF   37
01442:  SETF   36
01444:  CLRF   3A
01446:  MOVWF  3C
01448:  MOVLW  5E
0144A:  MOVWF  3B
0144C:  CLRF   3F
0144E:  CLRF   40
01450:  CLRF   41
01452:  MOVLW  01
01454:  SUBWF  41,W
01456:  MOVWF  42
01458:  SETF   44
0145A:  SETF   43
0145C:  MOVLW  01
0145E:  MOVWF  45
01460:  CLRF   46
01462:  MOVWF  47
01464:  CLRF   48
01466:  CLRF   49
01468:  CLRF   x69
0146A:  CLRF   x68
0146C:  MOVLB  F
0146E:  CLRF   x38
01470:  CLRF   x39
01472:  CLRF   x3A
01474:  CLRF   x3B
01476:  CLRF   x3C
01478:  CLRF   F77
0147A:  CLRF   F78
0147C:  CLRF   F79
0147E:  CLRF   1E
01480:  CLRF   1F
01482:  MOVLW  31
01484:  MOVWF  4A
01486:  MOVLW  32
01488:  MOVWF  4B
0148A:  MOVLW  33
0148C:  MOVWF  4C
0148E:  MOVLW  34
01490:  MOVWF  4D
01492:  MOVLW  35
01494:  MOVWF  4E
01496:  MOVLW  36
01498:  MOVWF  4F
0149A:  MOVLW  37
0149C:  MOVWF  50
0149E:  MOVLW  38
014A0:  MOVWF  51
014A2:  MOVLW  39
014A4:  MOVWF  52
014A6:  MOVLW  01
014A8:  MOVWF  53
014AA:  MOVLW  02
014AC:  MOVWF  54
014AE:  MOVLW  03
014B0:  MOVWF  55
014B2:  MOVLW  04
014B4:  MOVWF  56
014B6:  MOVLW  05
014B8:  MOVWF  57
014BA:  MOVLW  06
014BC:  MOVWF  58
014BE:  MOVLW  07
014C0:  MOVWF  59
014C2:  MOVLW  08
014C4:  MOVWF  5A
014C6:  MOVLW  09
014C8:  MOVWF  5B
.................... {
.................... 
....................     setup_CCP1(CCP_OFF);
014CA:  MOVLW  F0
014CC:  ANDWF  FBD,F
....................     clear_interrupt(INT_TIMER1);
014CE:  BCF    F9E.0
.................... 
....................     setup_low_volt_detect(LVD_TRIGGER_BELOW | LVD_36);
014D0:  MOVLW  1A
014D2:  MOVWF  F9C
....................     enable_interrupts(INT_HLVD);
014D4:  BSF    FA0.2
.................... 
....................     enable_interrupts(GLOBAL);
014D6:  MOVLW  C0
014D8:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA);
014DA:  BSF    F9D.5
....................     disable_interrupts(INT_TIMER1);
014DC:  BCF    F9D.0
....................     
....................     //setup_wdt( WDT_ON | WDT_64MS    );
....................     
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); // Timer1 configuration: internal clock source + 8 prescaler
014DE:  MOVLW  37
014E0:  MOVWF  FCD
014E2:  CLRF   FCC
....................     set_timer1(65486);                        // 65488 --- 63350
014E4:  SETF   FCF
014E6:  MOVLW  CE
014E8:  MOVWF  FCE
014EA:  NOP   
....................     //restart_wdt();
....................     lcd_init();
014EC:  MOVLB  0
014EE:  GOTO   06D6
.................... 
....................     lcd_load_custom_chars();
014F2:  GOTO   0740
.................... 
....................     FinishTick = StartTick = CurrentTick = get_ticks(); // timers for centering
014F6:  CALL   0772
014FA:  MOVFF  03,67
014FE:  MOVFF  02,66
01502:  MOVFF  01,65
01506:  MOVFF  00,64
0150A:  MOVFF  67,5F
0150E:  MOVFF  66,5E
01512:  MOVFF  65,5D
01516:  MOVFF  64,5C
0151A:  MOVFF  5F,63
0151E:  MOVFF  5E,62
01522:  MOVFF  5D,61
01526:  MOVFF  5C,60
.................... 
....................     if (read_eeprom(1) <= 0 | read_eeprom(1) > 10 )//
0152A:  MOVFF  FF2,72
0152E:  BCF    FF2.7
01530:  CLRF   FAA
01532:  MOVLW  01
01534:  MOVWF  FA9
01536:  BCF    FA6.6
01538:  BCF    FA6.7
0153A:  BSF    FA6.0
0153C:  MOVF   FA8,W
0153E:  BTFSC  x72.7
01540:  BSF    FF2.7
01542:  XORLW  00
01544:  BZ    154A
01546:  MOVLW  00
01548:  BRA    154C
0154A:  MOVLW  01
0154C:  MOVWF  x73
0154E:  MOVFF  FF2,74
01552:  BCF    FF2.7
01554:  CLRF   FAA
01556:  MOVLW  01
01558:  MOVWF  FA9
0155A:  BCF    FA6.6
0155C:  BCF    FA6.7
0155E:  BSF    FA6.0
01560:  MOVF   FA8,W
01562:  BTFSC  x74.7
01564:  BSF    FF2.7
01566:  SUBLW  0A
01568:  BNC   156E
0156A:  MOVLW  00
0156C:  BRA    1570
0156E:  MOVLW  01
01570:  IORWF  x73,W
01572:  XORLW  00
01574:  BTFSC  FD8.2
01576:  BRA    1758
....................     {
....................          
....................         lcd_gotoxy(1, 3);
01578:  MOVLW  01
0157A:  MOVWF  x80
0157C:  MOVLW  03
0157E:  MOVWF  x81
01580:  CALL   07C4
....................         lcd_putc("Eeprom Fail");
01584:  MOVLW  68
01586:  MOVWF  FF6
01588:  MOVLW  05
0158A:  MOVWF  FF7
0158C:  CALL   0858
....................         
....................         write_eeprom(1, 5); // speed
01590:  MOVF   FF2,W
01592:  MOVWF  00
01594:  BCF    FF2.7
01596:  CLRF   FAA
01598:  MOVLW  01
0159A:  MOVWF  FA9
0159C:  MOVLW  05
0159E:  MOVWF  FA8
015A0:  BCF    FA6.6
015A2:  BCF    FA6.7
015A4:  BSF    FA6.2
015A6:  MOVLB  F
015A8:  MOVLW  55
015AA:  MOVWF  FA7
015AC:  MOVLW  AA
015AE:  MOVWF  FA7
015B0:  BSF    FA6.1
015B2:  BTFSC  FA6.1
015B4:  BRA    15B2
015B6:  BCF    FA6.2
015B8:  MOVF   00,W
015BA:  IORWF  FF2,F
....................         write_eeprom(2, 5); // accel
015BC:  MOVFF  FF2,00
015C0:  BCF    FF2.7
015C2:  CLRF   FAA
015C4:  MOVLW  02
015C6:  MOVWF  FA9
015C8:  MOVLW  05
015CA:  MOVWF  FA8
015CC:  BCF    FA6.6
015CE:  BCF    FA6.7
015D0:  BSF    FA6.2
015D2:  MOVLW  55
015D4:  MOVWF  FA7
015D6:  MOVLW  AA
015D8:  MOVWF  FA7
015DA:  BSF    FA6.1
015DC:  BTFSC  FA6.1
015DE:  BRA    15DC
015E0:  BCF    FA6.2
015E2:  MOVF   00,W
015E4:  IORWF  FF2,F
....................         write_eeprom(3, 0); // centered?
015E6:  MOVFF  FF2,00
015EA:  BCF    FF2.7
015EC:  CLRF   FAA
015EE:  MOVLW  03
015F0:  MOVWF  FA9
015F2:  CLRF   FA8
015F4:  BCF    FA6.6
015F6:  BCF    FA6.7
015F8:  BSF    FA6.2
015FA:  MOVLW  55
015FC:  MOVWF  FA7
015FE:  MOVLW  AA
01600:  MOVWF  FA7
01602:  BSF    FA6.1
01604:  BTFSC  FA6.1
01606:  BRA    1604
01608:  BCF    FA6.2
0160A:  MOVF   00,W
0160C:  IORWF  FF2,F
.................... 
....................         write_eeprom(4, 100); // pos1
0160E:  MOVFF  FF2,00
01612:  BCF    FF2.7
01614:  CLRF   FAA
01616:  MOVLW  04
01618:  MOVWF  FA9
0161A:  MOVLW  64
0161C:  MOVWF  FA8
0161E:  BCF    FA6.6
01620:  BCF    FA6.7
01622:  BSF    FA6.2
01624:  MOVLW  55
01626:  MOVWF  FA7
01628:  MOVLW  AA
0162A:  MOVWF  FA7
0162C:  BSF    FA6.1
0162E:  BTFSC  FA6.1
01630:  BRA    162E
01632:  BCF    FA6.2
01634:  MOVF   00,W
01636:  IORWF  FF2,F
....................         write_eeprom(5, 100); // pos2
01638:  MOVFF  FF2,00
0163C:  BCF    FF2.7
0163E:  CLRF   FAA
01640:  MOVLW  05
01642:  MOVWF  FA9
01644:  MOVLW  64
01646:  MOVWF  FA8
01648:  BCF    FA6.6
0164A:  BCF    FA6.7
0164C:  BSF    FA6.2
0164E:  MOVLW  55
01650:  MOVWF  FA7
01652:  MOVLW  AA
01654:  MOVWF  FA7
01656:  BSF    FA6.1
01658:  BTFSC  FA6.1
0165A:  BRA    1658
0165C:  BCF    FA6.2
0165E:  MOVF   00,W
01660:  IORWF  FF2,F
.................... 
....................         write_eeprom(6, 0); // threshold
01662:  MOVFF  FF2,00
01666:  BCF    FF2.7
01668:  CLRF   FAA
0166A:  MOVLW  06
0166C:  MOVWF  FA9
0166E:  CLRF   FA8
01670:  BCF    FA6.6
01672:  BCF    FA6.7
01674:  BSF    FA6.2
01676:  MOVLW  55
01678:  MOVWF  FA7
0167A:  MOVLW  AA
0167C:  MOVWF  FA7
0167E:  BSF    FA6.1
01680:  BTFSC  FA6.1
01682:  BRA    1680
01684:  BCF    FA6.2
01686:  MOVF   00,W
01688:  IORWF  FF2,F
.................... 
....................         write_eeprom(7, 0); // cc1
0168A:  MOVFF  FF2,00
0168E:  BCF    FF2.7
01690:  CLRF   FAA
01692:  MOVLW  07
01694:  MOVWF  FA9
01696:  CLRF   FA8
01698:  BCF    FA6.6
0169A:  BCF    FA6.7
0169C:  BSF    FA6.2
0169E:  MOVLW  55
016A0:  MOVWF  FA7
016A2:  MOVLW  AA
016A4:  MOVWF  FA7
016A6:  BSF    FA6.1
016A8:  BTFSC  FA6.1
016AA:  BRA    16A8
016AC:  BCF    FA6.2
016AE:  MOVF   00,W
016B0:  IORWF  FF2,F
....................         write_eeprom(8, 0); // cc2
016B2:  MOVFF  FF2,00
016B6:  BCF    FF2.7
016B8:  CLRF   FAA
016BA:  MOVLW  08
016BC:  MOVWF  FA9
016BE:  CLRF   FA8
016C0:  BCF    FA6.6
016C2:  BCF    FA6.7
016C4:  BSF    FA6.2
016C6:  MOVLW  55
016C8:  MOVWF  FA7
016CA:  MOVLW  AA
016CC:  MOVWF  FA7
016CE:  BSF    FA6.1
016D0:  BTFSC  FA6.1
016D2:  BRA    16D0
016D4:  BCF    FA6.2
016D6:  MOVF   00,W
016D8:  IORWF  FF2,F
.................... 
....................         write_eeprom(9, 0); // line1
016DA:  MOVFF  FF2,00
016DE:  BCF    FF2.7
016E0:  CLRF   FAA
016E2:  MOVLW  09
016E4:  MOVWF  FA9
016E6:  CLRF   FA8
016E8:  BCF    FA6.6
016EA:  BCF    FA6.7
016EC:  BSF    FA6.2
016EE:  MOVLW  55
016F0:  MOVWF  FA7
016F2:  MOVLW  AA
016F4:  MOVWF  FA7
016F6:  BSF    FA6.1
016F8:  BTFSC  FA6.1
016FA:  BRA    16F8
016FC:  BCF    FA6.2
016FE:  MOVF   00,W
01700:  IORWF  FF2,F
.................... 
....................         write_eeprom(10, 1); // check_right
01702:  MOVFF  FF2,00
01706:  BCF    FF2.7
01708:  CLRF   FAA
0170A:  MOVLW  0A
0170C:  MOVWF  FA9
0170E:  MOVLW  01
01710:  MOVWF  FA8
01712:  BCF    FA6.6
01714:  BCF    FA6.7
01716:  BSF    FA6.2
01718:  MOVLW  55
0171A:  MOVWF  FA7
0171C:  MOVLW  AA
0171E:  MOVWF  FA7
01720:  BSF    FA6.1
01722:  BTFSC  FA6.1
01724:  BRA    1722
01726:  BCF    FA6.2
01728:  MOVF   00,W
0172A:  IORWF  FF2,F
....................         write_eeprom(11, 1); // check_left
0172C:  MOVFF  FF2,00
01730:  BCF    FF2.7
01732:  CLRF   FAA
01734:  MOVLW  0B
01736:  MOVWF  FA9
01738:  MOVLW  01
0173A:  MOVWF  FA8
0173C:  BCF    FA6.6
0173E:  BCF    FA6.7
01740:  BSF    FA6.2
01742:  MOVLW  55
01744:  MOVWF  FA7
01746:  MOVLW  AA
01748:  MOVWF  FA7
0174A:  BSF    FA6.1
0174C:  BTFSC  FA6.1
0174E:  BRA    174C
01750:  BCF    FA6.2
01752:  MOVF   00,W
01754:  IORWF  FF2,F
01756:  MOVLB  0
.................... 
....................         
....................     }
.................... 
....................     delay_s = read_eeprom(1);
01758:  MOVFF  FF2,72
0175C:  BCF    FF2.7
0175E:  CLRF   FAA
01760:  MOVLW  01
01762:  MOVWF  FA9
01764:  BCF    FA6.6
01766:  BCF    FA6.7
01768:  BSF    FA6.0
0176A:  MOVF   FA8,W
0176C:  BTFSC  x72.7
0176E:  BSF    FF2.7
01770:  MOVWF  21
....................     accel = read_eeprom(2);
01772:  MOVFF  FF2,72
01776:  BCF    FF2.7
01778:  CLRF   FAA
0177A:  MOVLW  02
0177C:  MOVWF  FA9
0177E:  BCF    FA6.6
01780:  BCF    FA6.7
01782:  BSF    FA6.0
01784:  MOVF   FA8,W
01786:  BTFSC  x72.7
01788:  BSF    FF2.7
0178A:  MOVWF  23
....................     centered = read_eeprom(3);
0178C:  MOVFF  FF2,72
01790:  BCF    FF2.7
01792:  CLRF   FAA
01794:  MOVLW  03
01796:  MOVWF  FA9
01798:  BCF    FA6.6
0179A:  BCF    FA6.7
0179C:  BSF    FA6.0
0179E:  MOVF   FA8,W
017A0:  BTFSC  x72.7
017A2:  BSF    FF2.7
017A4:  MOVWF  35
.................... 
....................     control_right = read_eeprom(10);
017A6:  MOVFF  FF2,72
017AA:  BCF    FF2.7
017AC:  CLRF   FAA
017AE:  MOVLW  0A
017B0:  MOVWF  FA9
017B2:  BCF    FA6.6
017B4:  BCF    FA6.7
017B6:  BSF    FA6.0
017B8:  MOVF   FA8,W
017BA:  BTFSC  x72.7
017BC:  BSF    FF2.7
017BE:  MOVWF  34
....................     control_left = read_eeprom(11);
017C0:  MOVFF  FF2,72
017C4:  BCF    FF2.7
017C6:  CLRF   FAA
017C8:  MOVLW  0B
017CA:  MOVWF  FA9
017CC:  BCF    FA6.6
017CE:  BCF    FA6.7
017D0:  BSF    FA6.0
017D2:  MOVF   FA8,W
017D4:  BTFSC  x72.7
017D6:  BSF    FF2.7
017D8:  MOVWF  33
.................... 
....................     if (centered)
017DA:  MOVF   35,F
017DC:  BTFSC  FD8.2
017DE:  BRA    196C
....................     {
.................... 
....................         step1 = read_eeprom(4);
017E0:  MOVFF  FF2,72
017E4:  BCF    FF2.7
017E6:  CLRF   FAA
017E8:  MOVLW  04
017EA:  MOVWF  FA9
017EC:  BCF    FA6.6
017EE:  BCF    FA6.7
017F0:  BSF    FA6.0
017F2:  MOVF   FA8,W
017F4:  BTFSC  x72.7
017F6:  BSF    FF2.7
017F8:  MOVWF  3D
....................         step2 = read_eeprom(5);
017FA:  MOVFF  FF2,72
017FE:  BCF    FF2.7
01800:  CLRF   FAA
01802:  MOVLW  05
01804:  MOVWF  FA9
01806:  BCF    FA6.6
01808:  BCF    FA6.7
0180A:  BSF    FA6.0
0180C:  MOVF   FA8,W
0180E:  BTFSC  x72.7
01810:  BSF    FF2.7
01812:  MOVWF  3E
.................... 
....................         step = make16(step2, step1);
01814:  MOVFF  3E,3C
01818:  MOVFF  3D,3B
....................         lcd_gotoxy(1, 3);
0181C:  MOVLW  01
0181E:  MOVWF  x80
01820:  MOVLW  03
01822:  MOVWF  x81
01824:  CALL   07C4
....................         printf(lcd_putc, "%lu", step);
01828:  MOVLW  10
0182A:  MOVWF  FE9
0182C:  MOVFF  3C,77
01830:  MOVFF  3B,76
01834:  CALL   0878
.................... 
....................         threshold = read_eeprom(6);
01838:  MOVFF  FF2,72
0183C:  BCF    FF2.7
0183E:  CLRF   FAA
01840:  MOVLW  06
01842:  MOVWF  FA9
01844:  BCF    FA6.6
01846:  BCF    FA6.7
01848:  BSF    FA6.0
0184A:  MOVF   FA8,W
0184C:  BTFSC  x72.7
0184E:  BSF    FF2.7
01850:  MOVWF  41
....................         printf(lcd_putc, " %d", threshold);
01852:  MOVLW  20
01854:  MOVWF  x7F
01856:  CALL   0804
0185A:  MOVFF  41,73
0185E:  MOVLW  18
01860:  MOVWF  x74
01862:  CALL   095A
.................... 
....................         cc1 = read_eeprom(7);
01866:  MOVFF  FF2,72
0186A:  BCF    FF2.7
0186C:  CLRF   FAA
0186E:  MOVLW  07
01870:  MOVWF  FA9
01872:  BCF    FA6.6
01874:  BCF    FA6.7
01876:  BSF    FA6.0
01878:  MOVF   FA8,W
0187A:  BTFSC  x72.7
0187C:  BSF    FF2.7
0187E:  MOVWF  38
....................         cc2 = read_eeprom(8);
01880:  MOVFF  FF2,72
01884:  BCF    FF2.7
01886:  CLRF   FAA
01888:  MOVLW  08
0188A:  MOVWF  FA9
0188C:  BCF    FA6.6
0188E:  BCF    FA6.7
01890:  BSF    FA6.0
01892:  MOVF   FA8,W
01894:  BTFSC  x72.7
01896:  BSF    FF2.7
01898:  MOVWF  39
....................         centercounter = make16(cc2, cc1);
0189A:  MOVFF  39,37
0189E:  MOVFF  38,36
.................... 
....................         // ine1=step/threshold;
....................         // line1++;
.................... 
....................         line1 = read_eeprom(9);
018A2:  MOVFF  FF2,72
018A6:  BCF    FF2.7
018A8:  CLRF   FAA
018AA:  MOVLW  09
018AC:  MOVWF  FA9
018AE:  BCF    FA6.6
018B0:  BCF    FA6.7
018B2:  BSF    FA6.0
018B4:  MOVF   FA8,W
018B6:  BTFSC  x72.7
018B8:  BSF    FF2.7
018BA:  MOVWF  3F
.................... 
....................         lcd_gotoxy(1, 4);
018BC:  MOVLW  01
018BE:  MOVWF  x80
018C0:  MOVLW  04
018C2:  MOVWF  x81
018C4:  CALL   07C4
....................         lcd_putc(swoff);
018C8:  MOVLW  02
018CA:  MOVWF  x7F
018CC:  CALL   0804
....................         lcd_gotoxy(20, 4);
018D0:  MOVLW  14
018D2:  MOVWF  x80
018D4:  MOVLW  04
018D6:  MOVWF  x81
018D8:  CALL   07C4
....................         lcd_putc(swoff);
018DC:  MOVLW  02
018DE:  MOVWF  x7F
018E0:  CALL   0804
.................... 
....................         if (step >= threshold)
018E4:  MOVF   3C,F
018E6:  BNZ   18EE
018E8:  MOVF   41,W
018EA:  SUBWF  3B,W
018EC:  BNC   190E
....................         {
....................             for (int i = 2; i <= line1; i++)
018EE:  MOVLW  02
018F0:  MOVWF  x6A
018F2:  MOVF   x6A,W
018F4:  SUBWF  3F,W
018F6:  BNC   190E
....................             {
....................                 lcd_gotoxy(i, 4);
018F8:  MOVFF  6A,80
018FC:  MOVLW  04
018FE:  MOVWF  x81
01900:  CALL   07C4
....................                 lcd_putc(three_dot);
01904:  CLRF   x7F
01906:  CALL   0804
0190A:  INCF   x6A,F
0190C:  BRA    18F2
....................             }
....................         }
.................... 
....................         if (!(input(proxy_left)))
0190E:  BSF    F94.4
01910:  BTFSC  F82.4
01912:  BRA    193C
....................         {
.................... 
....................             lcd_gotoxy(1, 4);
01914:  MOVLW  01
01916:  MOVWF  x80
01918:  MOVLW  04
0191A:  MOVWF  x81
0191C:  CALL   07C4
....................             lcd_putc(swoff);
01920:  MOVLW  02
01922:  MOVWF  x7F
01924:  CALL   0804
.................... 
....................             lcd_gotoxy(20, 4);
01928:  MOVLW  14
0192A:  MOVWF  x80
0192C:  MOVLW  04
0192E:  MOVWF  x81
01930:  CALL   07C4
....................             lcd_putc(swon);
01934:  MOVLW  01
01936:  MOVWF  x7F
01938:  CALL   0804
....................         }
.................... 
....................         if (!(input(proxy_right)))
0193C:  BSF    F94.5
0193E:  BTFSC  F82.5
01940:  BRA    196A
....................         {
.................... 
....................             lcd_gotoxy(1, 4);
01942:  MOVLW  01
01944:  MOVWF  x80
01946:  MOVLW  04
01948:  MOVWF  x81
0194A:  CALL   07C4
....................             lcd_putc(swon);
0194E:  MOVLW  01
01950:  MOVWF  x7F
01952:  CALL   0804
.................... 
....................             lcd_gotoxy(20, 4);
01956:  MOVLW  14
01958:  MOVWF  x80
0195A:  MOVLW  04
0195C:  MOVWF  x81
0195E:  CALL   07C4
....................             lcd_putc(swoff);
01962:  MOVLW  02
01964:  MOVWF  x7F
01966:  CALL   0804
....................         }
....................     }
0196A:  BRA    1984
.................... 
....................     else
....................     {
....................         lcd_gotoxy(3, 4);
0196C:  MOVLW  03
0196E:  MOVWF  x80
01970:  MOVLW  04
01972:  MOVWF  x81
01974:  CALL   07C4
....................         lcd_putc("Centee Machine");
01978:  MOVLW  74
0197A:  MOVWF  FF6
0197C:  MOVLW  05
0197E:  MOVWF  FF7
01980:  CALL   0858
....................     }
....................     
....................     //////////////////////////////////////
.................... 
....................     while (TRUE)
....................     {    
....................         //restart_wdt();
....................         enable_interrupts(INT_RDA);
01984:  BSF    F9D.5
....................         // output_toggle (PIN_D4);
....................          
....................         lcd_gotoxy(1, 1);
01986:  MOVLW  01
01988:  MOVWF  x80
0198A:  MOVWF  x81
0198C:  CALL   07C4
....................         lcd_putc("Speed: %   ");
01990:  MOVLW  84
01992:  MOVWF  FF6
01994:  MOVLW  05
01996:  MOVWF  FF7
01998:  CALL   0858
....................         lcd_gotoxy(9, 1);
0199C:  MOVLW  09
0199E:  MOVWF  x80
019A0:  MOVLW  01
019A2:  MOVWF  x81
019A4:  CALL   07C4
....................         printf(lcd_putc, "%d", delay_s * 10);
019A8:  MOVF   21,W
019AA:  MULLW  0A
019AC:  MOVFF  FF3,73
019B0:  MOVLW  18
019B2:  MOVWF  x74
019B4:  CALL   095A
.................... 
....................         lcd_gotoxy(13, 1);
019B8:  MOVLW  0D
019BA:  MOVWF  x80
019BC:  MOVLW  01
019BE:  MOVWF  x81
019C0:  CALL   07C4
....................         if (mode_manuel)
019C4:  MOVF   27,F
019C6:  BZ    19D4
....................         {
....................             lcd_putc("<Manuel>");
019C8:  MOVLW  90
019CA:  MOVWF  FF6
019CC:  MOVLW  05
019CE:  MOVWF  FF7
019D0:  CALL   0858
....................         }
.................... 
....................         if (mode_auto)
019D4:  MOVF   26,F
019D6:  BZ    19E4
....................         {
....................             lcd_putc("< Auto >");
019D8:  MOVLW  9A
019DA:  MOVWF  FF6
019DC:  MOVLW  05
019DE:  MOVWF  FF7
019E0:  CALL   0858
....................         }
.................... 
....................         lcd_gotoxy(1, 2);
019E4:  MOVLW  01
019E6:  MOVWF  x80
019E8:  MOVLW  02
019EA:  MOVWF  x81
019EC:  CALL   07C4
....................         lcd_putc("Accel: %   ");
019F0:  MOVLW  A4
019F2:  MOVWF  FF6
019F4:  MOVLW  05
019F6:  MOVWF  FF7
019F8:  CALL   0858
....................         lcd_gotoxy(9, 2);
019FC:  MOVLW  09
019FE:  MOVWF  x80
01A00:  MOVLW  02
01A02:  MOVWF  x81
01A04:  CALL   07C4
....................         printf(lcd_putc, "%d", accel * 10);
01A08:  MOVF   23,W
01A0A:  MULLW  0A
01A0C:  MOVFF  FF3,73
01A10:  MOVLW  18
01A12:  MOVWF  x74
01A14:  CALL   095A
....................    
....................         if (!(centered))
01A18:  MOVF   35,F
01A1A:  BNZ   1A32
....................         {
....................             lcd_gotoxy(4, 4);
01A1C:  MOVLW  04
01A1E:  MOVWF  x80
01A20:  MOVWF  x81
01A22:  CALL   07C4
....................             lcd_putc("Center Machine");
01A26:  MOVLW  B0
01A28:  MOVWF  FF6
01A2A:  MOVLW  05
01A2C:  MOVWF  FF7
01A2E:  CALL   0858
....................         }
....................    
....................         ///////////////////>>>>>> MODE CHANGE  <<<<<//////////////////////
.................... 
....................         if (!(input(button5)))
01A32:  BSF    F95.7
01A34:  BTFSC  F83.7
01A36:  BRA    1F24
....................         {
....................             int mode_cursor = 1;
....................             char mod_flag = False;
01A38:  MOVLW  01
01A3A:  MOVWF  x6B
01A3C:  CLRF   x6C
....................             
....................             StartTick = get_ticks();
01A3E:  CALL   0772
01A42:  MOVFF  03,5F
01A46:  MOVFF  02,5E
01A4A:  MOVFF  01,5D
01A4E:  MOVFF  00,5C
....................             
....................             while (!(input(button5))){};
01A52:  BSF    F95.7
01A54:  BTFSS  F83.7
01A56:  BRA    1A52
....................         
....................             while (1)
....................             {
....................                seri_check();
01A58:  GOTO   1170
....................                enable_interrupts(INT_RDA);
01A5C:  BSF    F9D.5
....................                
....................                //restart_wdt();
....................                 if (mode_cursor == 1)
01A5E:  DECFSZ x6B,W
01A60:  BRA    1C2E
....................                 { // SET SPEED
.................... 
....................                     CurrentTick = get_ticks();
01A62:  CALL   0772
01A66:  MOVFF  03,67
01A6A:  MOVFF  02,66
01A6E:  MOVFF  01,65
01A72:  MOVFF  00,64
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == True)
01A76:  MOVF   5C,W
01A78:  SUBWF  x64,W
01A7A:  MOVWF  x72
01A7C:  MOVF   5D,W
01A7E:  SUBWFB x65,W
01A80:  MOVWF  x73
01A82:  MOVF   5E,W
01A84:  SUBWFB x66,W
01A86:  MOVWF  x74
01A88:  MOVF   5F,W
01A8A:  SUBWFB x67,W
01A8C:  MOVWF  x75
01A8E:  MOVF   x75,F
01A90:  BNZ   1AAA
01A92:  MOVF   x74,F
01A94:  BNZ   1AAA
01A96:  MOVF   x73,W
01A98:  SUBLW  08
01A9A:  BC    1AA6
01A9C:  XORLW  FF
01A9E:  BNZ   1AAA
01AA0:  MOVF   x72,W
01AA2:  SUBLW  C4
01AA4:  BNC   1AAA
01AA6:  MOVLW  00
01AA8:  BRA    1AAC
01AAA:  MOVLW  01
01AAC:  MOVWF  x72
01AAE:  DECFSZ x6C,W
01AB0:  BRA    1AB4
01AB2:  BRA    1AB8
01AB4:  MOVLW  00
01AB6:  BRA    1ABA
01AB8:  MOVLW  01
01ABA:  ANDWF  x72,W
01ABC:  BZ    1AF8
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01ABE:  MOVLW  08
01AC0:  MOVWF  x80
01AC2:  MOVFF  6B,81
01AC6:  CALL   07C4
....................                         lcd_putc("%");
01ACA:  MOVLW  C0
01ACC:  MOVWF  FF6
01ACE:  MOVLW  05
01AD0:  MOVWF  FF7
01AD2:  CALL   0858
....................                         printf(lcd_putc, "%d", delay_s * 10);
01AD6:  MOVF   21,W
01AD8:  MULLW  0A
01ADA:  MOVFF  FF3,73
01ADE:  MOVLW  18
01AE0:  MOVWF  x74
01AE2:  CALL   095A
.................... 
....................                         mod_flag = False;
01AE6:  CLRF   x6C
....................                         StartTick = CurrentTick;
01AE8:  MOVFF  67,5F
01AEC:  MOVFF  66,5E
01AF0:  MOVFF  65,5D
01AF4:  MOVFF  64,5C
....................                     }
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == False)
01AF8:  MOVF   5C,W
01AFA:  SUBWF  x64,W
01AFC:  MOVWF  x72
01AFE:  MOVF   5D,W
01B00:  SUBWFB x65,W
01B02:  MOVWF  x73
01B04:  MOVF   5E,W
01B06:  SUBWFB x66,W
01B08:  MOVWF  x74
01B0A:  MOVF   5F,W
01B0C:  SUBWFB x67,W
01B0E:  MOVWF  x75
01B10:  MOVF   x75,F
01B12:  BNZ   1B2C
01B14:  MOVF   x74,F
01B16:  BNZ   1B2C
01B18:  MOVF   x73,W
01B1A:  SUBLW  08
01B1C:  BC    1B28
01B1E:  XORLW  FF
01B20:  BNZ   1B2C
01B22:  MOVF   x72,W
01B24:  SUBLW  C4
01B26:  BNC   1B2C
01B28:  MOVLW  00
01B2A:  BRA    1B2E
01B2C:  MOVLW  01
01B2E:  MOVWF  x72
01B30:  MOVF   x6C,F
01B32:  BZ    1B38
01B34:  MOVLW  00
01B36:  BRA    1B3A
01B38:  MOVLW  01
01B3A:  ANDWF  x72,W
01B3C:  BZ    1B6A
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01B3E:  MOVLW  08
01B40:  MOVWF  x80
01B42:  MOVFF  6B,81
01B46:  CALL   07C4
....................                         lcd_putc("    ");
01B4A:  MOVLW  C2
01B4C:  MOVWF  FF6
01B4E:  MOVLW  05
01B50:  MOVWF  FF7
01B52:  CALL   0858
.................... 
....................                         mod_flag = True;
01B56:  MOVLW  01
01B58:  MOVWF  x6C
....................                         StartTick = CurrentTick;
01B5A:  MOVFF  67,5F
01B5E:  MOVFF  66,5E
01B62:  MOVFF  65,5D
01B66:  MOVFF  64,5C
....................                     }
.................... 
....................                     if (!(input(button1)))
01B6A:  BSF    F95.6
01B6C:  BTFSC  F83.6
01B6E:  BRA    1BC8
....................                     {
....................                         delay_s=delay_s-1;
01B70:  MOVLW  01
01B72:  SUBWF  21,F
.................... 
....................                         if (delay_s <= 0)
01B74:  MOVF   21,F
01B76:  BNZ   1B7C
....................                         {
....................                             delay_s = 1;
01B78:  MOVLW  01
01B7A:  MOVWF  21
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01B7C:  MOVLW  08
01B7E:  MOVWF  x80
01B80:  MOVFF  6B,81
01B84:  CALL   07C4
....................                         lcd_putc("%");
01B88:  MOVLW  C8
01B8A:  MOVWF  FF6
01B8C:  MOVLW  05
01B8E:  MOVWF  FF7
01B90:  CALL   0858
....................                         printf(lcd_putc, "%d ", delay_s * 10);
01B94:  MOVF   21,W
01B96:  MULLW  0A
01B98:  MOVFF  FF3,73
01B9C:  MOVLW  18
01B9E:  MOVWF  x74
01BA0:  CALL   095A
01BA4:  MOVLW  20
01BA6:  MOVWF  x7F
01BA8:  CALL   0804
.................... 
....................                         //printf("h0%d ", delay_s);
....................                         delay_ms(500);
01BAC:  MOVLW  02
01BAE:  MOVWF  x72
01BB0:  CLRF   19
01BB2:  BTFSC  FF2.7
01BB4:  BSF    19.7
01BB6:  BCF    FF2.7
01BB8:  MOVLW  FA
01BBA:  MOVWF  x89
01BBC:  CALL   0348
01BC0:  BTFSC  19.7
01BC2:  BSF    FF2.7
01BC4:  DECFSZ x72,F
01BC6:  BRA    1BB0
....................                     }
.................... 
....................                     if (!(input(button3)))
01BC8:  BSF    F95.5
01BCA:  BTFSC  F83.5
01BCC:  BRA    1C2E
....................                     {
....................                         delay_s=delay_s+1;
01BCE:  MOVLW  01
01BD0:  ADDWF  21,F
.................... 
....................                         if (delay_s >= 10)
01BD2:  MOVF   21,W
01BD4:  SUBLW  09
01BD6:  BC    1BDC
....................                         {
....................                             delay_s = 10;
01BD8:  MOVLW  0A
01BDA:  MOVWF  21
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01BDC:  MOVLW  08
01BDE:  MOVWF  x80
01BE0:  MOVFF  6B,81
01BE4:  CALL   07C4
....................                         lcd_putc("%");
01BE8:  MOVLW  CA
01BEA:  MOVWF  FF6
01BEC:  MOVLW  05
01BEE:  MOVWF  FF7
01BF0:  CALL   0858
....................                         printf(lcd_putc, "%d ", delay_s * 10);
01BF4:  MOVF   21,W
01BF6:  MULLW  0A
01BF8:  MOVFF  FF3,73
01BFC:  MOVLW  18
01BFE:  MOVWF  x74
01C00:  CALL   095A
01C04:  MOVLW  20
01C06:  MOVWF  x7F
01C08:  CALL   0804
.................... 
....................                         if (delay_s < 10)
01C0C:  MOVF   21,W
01C0E:  SUBLW  09
01C10:  BNC   1C12
....................                         {
....................                             //printf("h0%d ", delay_s);
....................                         }
....................                         else
....................                         {
....................                             //printf("h10");
....................                         }
.................... 
....................                         delay_ms(500);
01C12:  MOVLW  02
01C14:  MOVWF  x72
01C16:  CLRF   19
01C18:  BTFSC  FF2.7
01C1A:  BSF    19.7
01C1C:  BCF    FF2.7
01C1E:  MOVLW  FA
01C20:  MOVWF  x89
01C22:  CALL   0348
01C26:  BTFSC  19.7
01C28:  BSF    FF2.7
01C2A:  DECFSZ x72,F
01C2C:  BRA    1C16
....................                     }
....................                 }
.................... 
....................                 ////////////////////////
.................... 
....................                 if (mode_cursor == 2){ // SET ACCEL
01C2E:  MOVF   x6B,W
01C30:  SUBLW  02
01C32:  BTFSS  FD8.2
01C34:  BRA    1E02
.................... 
....................                     CurrentTick = get_ticks();
01C36:  CALL   0772
01C3A:  MOVFF  03,67
01C3E:  MOVFF  02,66
01C42:  MOVFF  01,65
01C46:  MOVFF  00,64
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == True)
01C4A:  MOVF   5C,W
01C4C:  SUBWF  x64,W
01C4E:  MOVWF  x72
01C50:  MOVF   5D,W
01C52:  SUBWFB x65,W
01C54:  MOVWF  x73
01C56:  MOVF   5E,W
01C58:  SUBWFB x66,W
01C5A:  MOVWF  x74
01C5C:  MOVF   5F,W
01C5E:  SUBWFB x67,W
01C60:  MOVWF  x75
01C62:  MOVF   x75,F
01C64:  BNZ   1C7E
01C66:  MOVF   x74,F
01C68:  BNZ   1C7E
01C6A:  MOVF   x73,W
01C6C:  SUBLW  08
01C6E:  BC    1C7A
01C70:  XORLW  FF
01C72:  BNZ   1C7E
01C74:  MOVF   x72,W
01C76:  SUBLW  C4
01C78:  BNC   1C7E
01C7A:  MOVLW  00
01C7C:  BRA    1C80
01C7E:  MOVLW  01
01C80:  MOVWF  x72
01C82:  DECFSZ x6C,W
01C84:  BRA    1C88
01C86:  BRA    1C8C
01C88:  MOVLW  00
01C8A:  BRA    1C8E
01C8C:  MOVLW  01
01C8E:  ANDWF  x72,W
01C90:  BZ    1CCC
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01C92:  MOVLW  08
01C94:  MOVWF  x80
01C96:  MOVFF  6B,81
01C9A:  CALL   07C4
....................                         lcd_putc("%");
01C9E:  MOVLW  CC
01CA0:  MOVWF  FF6
01CA2:  MOVLW  05
01CA4:  MOVWF  FF7
01CA6:  CALL   0858
....................                         printf(lcd_putc, "%d", accel * 10);
01CAA:  MOVF   23,W
01CAC:  MULLW  0A
01CAE:  MOVFF  FF3,73
01CB2:  MOVLW  18
01CB4:  MOVWF  x74
01CB6:  CALL   095A
.................... 
....................                         mod_flag = False;
01CBA:  CLRF   x6C
....................                         StartTick = CurrentTick;
01CBC:  MOVFF  67,5F
01CC0:  MOVFF  66,5E
01CC4:  MOVFF  65,5D
01CC8:  MOVFF  64,5C
....................                     }
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == False)
01CCC:  MOVF   5C,W
01CCE:  SUBWF  x64,W
01CD0:  MOVWF  x72
01CD2:  MOVF   5D,W
01CD4:  SUBWFB x65,W
01CD6:  MOVWF  x73
01CD8:  MOVF   5E,W
01CDA:  SUBWFB x66,W
01CDC:  MOVWF  x74
01CDE:  MOVF   5F,W
01CE0:  SUBWFB x67,W
01CE2:  MOVWF  x75
01CE4:  MOVF   x75,F
01CE6:  BNZ   1D00
01CE8:  MOVF   x74,F
01CEA:  BNZ   1D00
01CEC:  MOVF   x73,W
01CEE:  SUBLW  08
01CF0:  BC    1CFC
01CF2:  XORLW  FF
01CF4:  BNZ   1D00
01CF6:  MOVF   x72,W
01CF8:  SUBLW  C4
01CFA:  BNC   1D00
01CFC:  MOVLW  00
01CFE:  BRA    1D02
01D00:  MOVLW  01
01D02:  MOVWF  x72
01D04:  MOVF   x6C,F
01D06:  BZ    1D0C
01D08:  MOVLW  00
01D0A:  BRA    1D0E
01D0C:  MOVLW  01
01D0E:  ANDWF  x72,W
01D10:  BZ    1D3E
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01D12:  MOVLW  08
01D14:  MOVWF  x80
01D16:  MOVFF  6B,81
01D1A:  CALL   07C4
....................                         lcd_putc("    ");
01D1E:  MOVLW  CE
01D20:  MOVWF  FF6
01D22:  MOVLW  05
01D24:  MOVWF  FF7
01D26:  CALL   0858
.................... 
....................                         mod_flag = True;
01D2A:  MOVLW  01
01D2C:  MOVWF  x6C
....................                         StartTick = CurrentTick;
01D2E:  MOVFF  67,5F
01D32:  MOVFF  66,5E
01D36:  MOVFF  65,5D
01D3A:  MOVFF  64,5C
....................                     }
.................... 
....................                     if (!(input(button1)))
01D3E:  BSF    F95.6
01D40:  BTFSC  F83.6
01D42:  BRA    1D9C
....................                     {
....................                         accel=accel-1;
01D44:  MOVLW  01
01D46:  SUBWF  23,F
.................... 
....................                         if (accel <= 0)
01D48:  MOVF   23,F
01D4A:  BNZ   1D50
....................                         {
....................                             accel = 1;
01D4C:  MOVLW  01
01D4E:  MOVWF  23
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01D50:  MOVLW  08
01D52:  MOVWF  x80
01D54:  MOVFF  6B,81
01D58:  CALL   07C4
....................                         lcd_putc("%");
01D5C:  MOVLW  D4
01D5E:  MOVWF  FF6
01D60:  MOVLW  05
01D62:  MOVWF  FF7
01D64:  CALL   0858
....................                         printf(lcd_putc, "%d ", accel * 10);
01D68:  MOVF   23,W
01D6A:  MULLW  0A
01D6C:  MOVFF  FF3,73
01D70:  MOVLW  18
01D72:  MOVWF  x74
01D74:  CALL   095A
01D78:  MOVLW  20
01D7A:  MOVWF  x7F
01D7C:  CALL   0804
.................... 
....................                         //printf("a0%d ", accel);
.................... 
....................                         delay_ms(500);
01D80:  MOVLW  02
01D82:  MOVWF  x72
01D84:  CLRF   19
01D86:  BTFSC  FF2.7
01D88:  BSF    19.7
01D8A:  BCF    FF2.7
01D8C:  MOVLW  FA
01D8E:  MOVWF  x89
01D90:  CALL   0348
01D94:  BTFSC  19.7
01D96:  BSF    FF2.7
01D98:  DECFSZ x72,F
01D9A:  BRA    1D84
....................                     }
.................... 
....................                     if (!(input(button3)))
01D9C:  BSF    F95.5
01D9E:  BTFSC  F83.5
01DA0:  BRA    1E02
....................                     {
....................                         accel=accel+1;
01DA2:  MOVLW  01
01DA4:  ADDWF  23,F
.................... 
....................                         if (accel >= 11)
01DA6:  MOVF   23,W
01DA8:  SUBLW  0A
01DAA:  BC    1DB0
....................                         {
....................                             accel = 10;
01DAC:  MOVLW  0A
01DAE:  MOVWF  23
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01DB0:  MOVLW  08
01DB2:  MOVWF  x80
01DB4:  MOVFF  6B,81
01DB8:  CALL   07C4
....................                         lcd_putc("%");
01DBC:  MOVLW  D6
01DBE:  MOVWF  FF6
01DC0:  MOVLW  05
01DC2:  MOVWF  FF7
01DC4:  CALL   0858
....................                         printf(lcd_putc, "%d ", accel * 10);
01DC8:  MOVF   23,W
01DCA:  MULLW  0A
01DCC:  MOVFF  FF3,73
01DD0:  MOVLW  18
01DD2:  MOVWF  x74
01DD4:  CALL   095A
01DD8:  MOVLW  20
01DDA:  MOVWF  x7F
01DDC:  CALL   0804
.................... 
....................                         if (accel < 10)
01DE0:  MOVF   23,W
01DE2:  SUBLW  09
01DE4:  BNC   1DE6
....................                         {
....................                             //printf("a0%d ", accel);
....................                         }
....................                         else
....................                         {
....................                             //printf("a10");
....................                         }
.................... 
....................                         delay_ms(500);
01DE6:  MOVLW  02
01DE8:  MOVWF  x72
01DEA:  CLRF   19
01DEC:  BTFSC  FF2.7
01DEE:  BSF    19.7
01DF0:  BCF    FF2.7
01DF2:  MOVLW  FA
01DF4:  MOVWF  x89
01DF6:  CALL   0348
01DFA:  BTFSC  19.7
01DFC:  BSF    FF2.7
01DFE:  DECFSZ x72,F
01E00:  BRA    1DEA
....................                     }
....................                 }
.................... 
....................                 ////////////////////////
.................... 
....................                 if (!(input(button4)))
01E02:  BSF    F95.3
01E04:  BTFSC  F83.3
01E06:  BRA    1E7E
....................                 {
.................... 
....................                     lcd_gotoxy(8, 1);
01E08:  MOVLW  08
01E0A:  MOVWF  x80
01E0C:  MOVLW  01
01E0E:  MOVWF  x81
01E10:  CALL   07C4
....................                     lcd_putc("%");
01E14:  MOVLW  D8
01E16:  MOVWF  FF6
01E18:  MOVLW  05
01E1A:  MOVWF  FF7
01E1C:  CALL   0858
....................                     printf(lcd_putc, "%d", delay_s * 10);
01E20:  MOVF   21,W
01E22:  MULLW  0A
01E24:  MOVFF  FF3,73
01E28:  MOVLW  18
01E2A:  MOVWF  x74
01E2C:  CALL   095A
.................... 
....................                     lcd_gotoxy(8, 2);
01E30:  MOVLW  08
01E32:  MOVWF  x80
01E34:  MOVLW  02
01E36:  MOVWF  x81
01E38:  CALL   07C4
....................                     lcd_putc("%");
01E3C:  MOVLW  DA
01E3E:  MOVWF  FF6
01E40:  MOVLW  05
01E42:  MOVWF  FF7
01E44:  CALL   0858
....................                     printf(lcd_putc, "%d", accel * 10);
01E48:  MOVF   23,W
01E4A:  MULLW  0A
01E4C:  MOVFF  FF3,73
01E50:  MOVLW  18
01E52:  MOVWF  x74
01E54:  CALL   095A
.................... 
....................                     mode_cursor--;
01E58:  DECF   x6B,F
.................... 
....................                     if (mode_cursor <= 0)
01E5A:  MOVF   x6B,F
01E5C:  BNZ   1E62
....................                     {
....................                         mode_cursor = 2;
01E5E:  MOVLW  02
01E60:  MOVWF  x6B
....................                     }
....................                     delay_ms(500);
01E62:  MOVLW  02
01E64:  MOVWF  x72
01E66:  CLRF   19
01E68:  BTFSC  FF2.7
01E6A:  BSF    19.7
01E6C:  BCF    FF2.7
01E6E:  MOVLW  FA
01E70:  MOVWF  x89
01E72:  CALL   0348
01E76:  BTFSC  19.7
01E78:  BSF    FF2.7
01E7A:  DECFSZ x72,F
01E7C:  BRA    1E66
....................                 }
.................... 
....................                 if (!(input(button2)))
01E7E:  BSF    F95.4
01E80:  BTFSC  F83.4
01E82:  BRA    1EFC
....................                 {
.................... 
....................                     lcd_gotoxy(8, 1);
01E84:  MOVLW  08
01E86:  MOVWF  x80
01E88:  MOVLW  01
01E8A:  MOVWF  x81
01E8C:  CALL   07C4
....................                     lcd_putc("%");
01E90:  MOVLW  DC
01E92:  MOVWF  FF6
01E94:  MOVLW  05
01E96:  MOVWF  FF7
01E98:  CALL   0858
....................                     printf(lcd_putc, "%d", delay_s * 10);
01E9C:  MOVF   21,W
01E9E:  MULLW  0A
01EA0:  MOVFF  FF3,73
01EA4:  MOVLW  18
01EA6:  MOVWF  x74
01EA8:  CALL   095A
.................... 
....................                     lcd_gotoxy(8, 2);
01EAC:  MOVLW  08
01EAE:  MOVWF  x80
01EB0:  MOVLW  02
01EB2:  MOVWF  x81
01EB4:  CALL   07C4
....................                     lcd_putc("%");
01EB8:  MOVLW  DE
01EBA:  MOVWF  FF6
01EBC:  MOVLW  05
01EBE:  MOVWF  FF7
01EC0:  CALL   0858
....................                     printf(lcd_putc, "%d", accel * 10);
01EC4:  MOVF   23,W
01EC6:  MULLW  0A
01EC8:  MOVFF  FF3,73
01ECC:  MOVLW  18
01ECE:  MOVWF  x74
01ED0:  CALL   095A
.................... 
....................                     mode_cursor++;
01ED4:  INCF   x6B,F
.................... 
....................                     if (mode_cursor >= 3)
01ED6:  MOVF   x6B,W
01ED8:  SUBLW  02
01EDA:  BC    1EE0
....................                     {
....................                         mode_cursor = 1;
01EDC:  MOVLW  01
01EDE:  MOVWF  x6B
....................                     }
....................                     delay_ms(500);
01EE0:  MOVLW  02
01EE2:  MOVWF  x72
01EE4:  CLRF   19
01EE6:  BTFSC  FF2.7
01EE8:  BSF    19.7
01EEA:  BCF    FF2.7
01EEC:  MOVLW  FA
01EEE:  MOVWF  x89
01EF0:  CALL   0348
01EF4:  BTFSC  19.7
01EF6:  BSF    FF2.7
01EF8:  DECFSZ x72,F
01EFA:  BRA    1EE4
....................                 }
.................... 
....................                 if (!(input(button5)))
01EFC:  BSF    F95.7
01EFE:  BTFSC  F83.7
01F00:  BRA    1F20
....................                 {
....................                     delay_ms(500);
01F02:  MOVLW  02
01F04:  MOVWF  x72
01F06:  CLRF   19
01F08:  BTFSC  FF2.7
01F0A:  BSF    19.7
01F0C:  BCF    FF2.7
01F0E:  MOVLW  FA
01F10:  MOVWF  x89
01F12:  CALL   0348
01F16:  BTFSC  19.7
01F18:  BSF    FF2.7
01F1A:  DECFSZ x72,F
01F1C:  BRA    1F06
....................                     break;
01F1E:  BRA    1F22
....................                 }
01F20:  BRA    1A58
....................             }
....................             
....................             correct=False;
01F22:  CLRF   2F
....................         }
.................... 
....................         //////////////>>>>>>>>> SERIAL COMM <<<<<<<<///////////
.................... 
....................         if (correct) { // full data received
01F24:  MOVF   2F,F
01F26:  BZ    1FE4
....................             //restart_wdt();
....................             read_serial_mode();
01F28:  CALL   0A04
....................             read_serial_speed();
01F2C:  CALL   0A5E
....................             read_serial_acc();
01F30:  CALL   0ADC
.................... 
....................             if (str[0] == 'c')
01F34:  MOVF   2A,W
01F36:  SUBLW  63
01F38:  BNZ   1F42
....................             {
....................                 centerline(6);
01F3A:  MOVLW  06
01F3C:  MOVWF  x73
01F3E:  CALL   0D6C
....................             }
.................... 
....................             if (str[0] == 'g')
01F42:  MOVF   2A,W
01F44:  SUBLW  67
01F46:  BNZ   1F4C
....................             {
....................                 gogo();
01F48:  CALL   0F7C
....................             }
.................... 
....................             if (str[0] == 'd')// usb connected, send commands to pc
01F4C:  MOVF   2A,W
01F4E:  SUBLW  64
01F50:  BNZ   1FE4
....................             { 
....................                 printf("x");
01F52:  MOVLW  78
01F54:  BTFSS  F9E.4
01F56:  BRA    1F54
01F58:  MOVWF  FAD
01F5A:  CLRF   19
01F5C:  BTFSC  FF2.7
01F5E:  BSF    19.7
01F60:  BCF    FF2.7
....................                 delay_ms(50);
01F62:  MOVLW  32
01F64:  MOVWF  x89
01F66:  CALL   0348
01F6A:  BTFSC  19.7
01F6C:  BSF    FF2.7
01F6E:  CLRF   19
01F70:  BTFSC  FF2.7
01F72:  BSF    19.7
01F74:  BCF    FF2.7
....................                 //printf("h0%d", delay_s);
....................                 delay_ms(50);
01F76:  MOVLW  32
01F78:  MOVWF  x89
01F7A:  CALL   0348
01F7E:  BTFSC  19.7
01F80:  BSF    FF2.7
01F82:  CLRF   19
01F84:  BTFSC  FF2.7
01F86:  BSF    19.7
01F88:  BCF    FF2.7
....................                 //printf("a0%d", accel);
....................                 delay_ms(50);
01F8A:  MOVLW  32
01F8C:  MOVWF  x89
01F8E:  CALL   0348
01F92:  BTFSC  19.7
01F94:  BSF    FF2.7
.................... 
....................                 if (mode_manuel)
01F96:  MOVF   27,F
01F98:  BZ    1F9A
....................                 {
....................                     //printf("m0");
....................                 }
.................... 
....................                 if (mode_auto)
01F9A:  MOVF   26,F
01F9C:  BZ    1F9E
01F9E:  CLRF   19
01FA0:  BTFSC  FF2.7
01FA2:  BSF    19.7
01FA4:  BCF    FF2.7
....................                 {
....................                     //printf("m1");
....................                 }
.................... 
....................                 delay_ms(50);
01FA6:  MOVLW  32
01FA8:  MOVWF  x89
01FAA:  CALL   0348
01FAE:  BTFSC  19.7
01FB0:  BSF    FF2.7
.................... 
....................                 if (centered)
01FB2:  MOVF   35,F
01FB4:  BZ    1FB6
01FB6:  CLRF   19
01FB8:  BTFSC  FF2.7
01FBA:  BSF    19.7
01FBC:  BCF    FF2.7
....................                 {
....................                     //printf("t%d", threshold);
....................                 }
.................... 
....................                 delay_ms(50);
01FBE:  MOVLW  32
01FC0:  MOVWF  x89
01FC2:  CALL   0348
01FC6:  BTFSC  19.7
01FC8:  BSF    FF2.7
....................                 int8 step_data = step / 10;
01FCA:  MOVFF  3C,7A
01FCE:  MOVFF  3B,79
01FD2:  CLRF   x7C
01FD4:  MOVLW  0A
01FD6:  MOVWF  x7B
01FD8:  CALL   0BB8
01FDC:  MOVFF  01,6D
....................                 //printf("q%d", step_data);
....................                 
....................                 str[0]='0';
01FE0:  MOVLW  30
01FE2:  MOVWF  2A
....................             }
.................... 
....................         // correct=False;
....................         
....................         }
.................... 
....................         ///////////>>>>>>> SELECT MANUEL or AUTO <<<<<<<<<///////
....................         while (!(input(button0))) // select auto
01FE4:  BSF    F95.1
01FE6:  BTFSC  F83.1
01FE8:  BRA    207E
....................         {
.................... 
....................             delay_ms(500);
01FEA:  MOVLW  02
01FEC:  MOVWF  x72
01FEE:  CLRF   19
01FF0:  BTFSC  FF2.7
01FF2:  BSF    19.7
01FF4:  BCF    FF2.7
01FF6:  MOVLW  FA
01FF8:  MOVWF  x89
01FFA:  CALL   0348
01FFE:  BTFSC  19.7
02000:  BSF    FF2.7
02002:  DECFSZ x72,F
02004:  BRA    1FEE
.................... 
....................             if (flag)
02006:  MOVF   28,F
02008:  BZ    2072
....................             {
....................                 flag = False;
0200A:  CLRF   28
....................                 mode_AUTO = True;
0200C:  MOVLW  01
0200E:  MOVWF  26
....................                 mode_manuel = False;
02010:  CLRF   27
.................... 
....................                 lcd_gotoxy(13, 1);
02012:  MOVLW  0D
02014:  MOVWF  x80
02016:  MOVLW  01
02018:  MOVWF  x81
0201A:  CALL   07C4
....................                 lcd_putc("< Auto >");
0201E:  MOVLW  E0
02020:  MOVWF  FF6
02022:  MOVLW  05
02024:  MOVWF  FF7
02026:  CALL   0858
....................                 //printf("m1");
.................... 
....................                 start = True;
0202A:  MOVLW  01
0202C:  MOVWF  45
.................... 
....................                 while (TRUE)
....................                 {
.................... 
....................                     acc_start_normal_auto();
0202E:  CALL   11D4
.................... 
....................                     if (return_value == False)
02032:  MOVF   47,F
02034:  BNZ   203C
....................                     {
....................                         return_value = True;
02036:  MOVLW  01
02038:  MOVWF  47
....................                         break;
0203A:  BRA    2070
....................                     }
.................... 
....................                     normal();
0203C:  CALL   0D40
.................... 
....................                     if (!(input(button2)) | !(input(button3)) | !(input(button4)) | check_right_proxy())
02040:  BSF    F95.4
02042:  MOVLW  00
02044:  BTFSS  F83.4
02046:  MOVLW  01
02048:  MOVWF  x72
0204A:  BSF    F95.5
0204C:  MOVLW  00
0204E:  BTFSS  F83.5
02050:  MOVLW  01
02052:  IORWF  x72,F
02054:  BSF    F95.3
02056:  MOVLW  00
02058:  BTFSS  F83.3
0205A:  MOVLW  01
0205C:  IORWF  x72,F
0205E:  CALL   0CEA
02062:  MOVF   x72,W
02064:  IORWF  01,W
02066:  BZ    206E
....................                     {
....................                         stop();
02068:  CALL   0BA4
....................                         break;
0206C:  BRA    2070
....................                     }
0206E:  BRA    202E
....................                 }
....................             }
02070:  BRA    207C
.................... 
....................             else
....................             {
....................                 flag = TRUE;
02072:  MOVLW  01
02074:  MOVWF  28
....................                 mode_AUTO = FALSE;
02076:  CLRF   26
....................                 mode_manuel = TRUE;
02078:  MOVWF  27
....................                 //printf("m0");
....................                 break;
0207A:  BRA    207E
....................             }
0207C:  BRA    1FE4
....................         }
.................... 
....................         ////////////////>>>>>> MANUEL <<<<< ////////////////////
....................         start = True;
0207E:  MOVLW  01
02080:  MOVWF  45
....................         q = False;
02082:  CLRF   46
.................... 
....................         while (!(input(button1)) & mode_manuel | ( str[0] == 'l' & str[1] == '0' )) //left
02084:  BSF    F95.6
02086:  MOVLW  00
02088:  BTFSS  F83.6
0208A:  MOVLW  01
0208C:  ANDWF  27,W
0208E:  MOVWF  x72
02090:  MOVF   2A,W
02092:  SUBLW  6C
02094:  BZ    209A
02096:  MOVLW  00
02098:  BRA    209C
0209A:  MOVLW  01
0209C:  MOVWF  x73
0209E:  MOVF   2B,W
020A0:  SUBLW  30
020A2:  BZ    20A8
020A4:  MOVLW  00
020A6:  BRA    20AA
020A8:  MOVLW  01
020AA:  ANDWF  x73,W
020AC:  IORWF  x72,W
020AE:  BZ    20EA
....................         {   
....................              enable_interrupts(INT_RDA);
020B0:  BSF    F9D.5
....................              
....................                //restart_wdt();
....................             if (check_right_proxy() | !(input(button3)))
020B2:  CALL   0CEA
020B6:  MOVFF  01,72
020BA:  BSF    F95.5
020BC:  MOVLW  00
020BE:  BTFSS  F83.5
020C0:  MOVLW  01
020C2:  IORWF  01,W
020C4:  BZ    20CE
....................             {
....................                 stop();
020C6:  CALL   0BA4
....................                 // correct = False;
....................                 disable_interrupts(INT_TIMER1);
020CA:  BCF    F9D.0
....................                 break;
020CC:  BRA    20EA
....................             }
....................             
....................             acc_start_normal_man();
020CE:  GOTO   125E
.................... 
....................             if (!(return_value))
020D2:  MOVF   47,F
020D4:  BNZ   20DC
....................             {
....................                 return_value = True;
020D6:  MOVLW  01
020D8:  MOVWF  47
....................                 break;
020DA:  BRA    20EA
....................             }
.................... 
....................             speed = delay_s;
020DC:  MOVFF  21,22
....................             normal();
020E0:  CALL   0D40
....................             quit1 = True;
020E4:  MOVLW  01
020E6:  MOVWF  30
020E8:  BRA    2084
....................         }
.................... 
....................         while (!(input(button3)) & mode_manuel |  (str[0] == 'r' & str[1] == '0' )) //right
020EA:  BSF    F95.5
020EC:  MOVLW  00
020EE:  BTFSS  F83.5
020F0:  MOVLW  01
020F2:  ANDWF  27,W
020F4:  MOVWF  x72
020F6:  MOVF   2A,W
020F8:  SUBLW  72
020FA:  BZ    2100
020FC:  MOVLW  00
020FE:  BRA    2102
02100:  MOVLW  01
02102:  MOVWF  x73
02104:  MOVF   2B,W
02106:  SUBLW  30
02108:  BZ    210E
0210A:  MOVLW  00
0210C:  BRA    2110
0210E:  MOVLW  01
02110:  ANDWF  x73,W
02112:  IORWF  x72,W
02114:  BZ    2150
....................         {   
....................             //restart_wdt();
....................              enable_interrupts(INT_RDA);
02116:  BSF    F9D.5
....................              
....................              
....................             if (check_left_proxy() | !(input(button1)) )
02118:  CALL   0B5A
0211C:  MOVFF  01,72
02120:  BSF    F95.6
02122:  MOVLW  00
02124:  BTFSS  F83.6
02126:  MOVLW  01
02128:  IORWF  01,W
0212A:  BZ    2134
....................             {
....................                 stop();
0212C:  CALL   0BA4
....................                 // correct = False;
....................                 disable_interrupts(INT_TIMER1);
02130:  BCF    F9D.0
....................                 break;
02132:  BRA    2150
....................             }
....................             
....................              
....................             acc_start_reverse_man();
02134:  GOTO   12D6
.................... 
....................             if (!(return_value ))
02138:  MOVF   47,F
0213A:  BNZ   2142
....................             {
....................                 return_value = True;
0213C:  MOVLW  01
0213E:  MOVWF  47
....................                 break;
02140:  BRA    2150
....................             }
.................... 
....................             speed = delay_s;
02142:  MOVFF  21,22
....................             reverse();
02146:  CALL   0CE0
....................             quit2 = True;
0214A:  MOVLW  01
0214C:  MOVWF  31
0214E:  BRA    20EA
....................         }
.................... 
....................         while (quit2)
02150:  MOVF   31,F
02152:  BZ    21A4
....................         {
....................         //restart_wdt();
....................             for (int i = 0; i < 10 - accel; i++)
02154:  CLRF   x6E
02156:  MOVLW  0A
02158:  BSF    FD8.0
0215A:  SUBFWB 23,W
0215C:  SUBWF  x6E,W
0215E:  BC    219C
....................             {  
....................                 enable_interrupts(INT_RDA);
02160:  BSF    F9D.5
....................                 for (int j = 0; j < accel_value; j++)
02162:  CLRF   x6F
02164:  MOVF   24,W
02166:  SUBWF  x6F,W
02168:  BC    2194
....................                 {
....................                     enable_interrupts(INT_RDA);
0216A:  BSF    F9D.5
....................                     if (!(input(button1)) | check_left_proxy())
0216C:  BSF    F95.6
0216E:  MOVLW  00
02170:  BTFSS  F83.6
02172:  MOVLW  01
02174:  MOVWF  x72
02176:  CALL   0B5A
0217A:  MOVF   x72,W
0217C:  IORWF  01,W
0217E:  BZ    2188
....................                     {
....................                         stop();
02180:  CALL   0BA4
....................                         disable_interrupts(INT_TIMER1);
02184:  BCF    F9D.0
....................                         break;
02186:  BRA    2194
....................                     }
.................... 
....................                     speed = c;
02188:  MOVFF  25,22
....................                     reverse();
0218C:  CALL   0CE0
02190:  INCF   x6F,F
02192:  BRA    2164
....................                 }
....................                 c = c - 1;
02194:  MOVLW  01
02196:  SUBWF  25,F
02198:  INCF   x6E,F
0219A:  BRA    2156
....................             }
....................             quit2 = False;
0219C:  CLRF   31
....................             stop();
0219E:  CALL   0BA4
021A2:  BRA    2150
....................         }
.................... 
....................         while (quit1)
021A4:  MOVF   30,F
021A6:  BZ    21F8
....................         {
....................         //restart_wdt();
....................             for (int i = 0; i < 10 - accel; i++)
021A8:  CLRF   x70
021AA:  MOVLW  0A
021AC:  BSF    FD8.0
021AE:  SUBFWB 23,W
021B0:  SUBWF  x70,W
021B2:  BC    21F0
....................             {   
....................                  enable_interrupts(INT_RDA);
021B4:  BSF    F9D.5
....................                 for (int j = 0; j < accel_value; j++)
021B6:  CLRF   x71
021B8:  MOVF   24,W
021BA:  SUBWF  x71,W
021BC:  BC    21E8
....................                 {
....................                     enable_interrupts(INT_RDA);
021BE:  BSF    F9D.5
.................... 
....................                     if (!(input(button3)) | check_right_proxy())
021C0:  BSF    F95.5
021C2:  MOVLW  00
021C4:  BTFSS  F83.5
021C6:  MOVLW  01
021C8:  MOVWF  x72
021CA:  CALL   0CEA
021CE:  MOVF   x72,W
021D0:  IORWF  01,W
021D2:  BZ    21DC
....................                     {
....................                         stop();
021D4:  CALL   0BA4
....................                         disable_interrupts(INT_TIMER1);
021D8:  BCF    F9D.0
....................                         break;
021DA:  BRA    21E8
....................                     }
.................... 
....................                     speed = c;
021DC:  MOVFF  25,22
....................                     normal();
021E0:  CALL   0D40
021E4:  INCF   x71,F
021E6:  BRA    21B8
....................                 }
....................                 c = c - 1;
021E8:  MOVLW  01
021EA:  SUBWF  25,F
021EC:  INCF   x70,F
021EE:  BRA    21AA
....................             }
....................             quit1 = False;
021F0:  CLRF   30
....................             stop();
021F2:  CALL   0BA4
021F6:  BRA    21A4
....................         }
.................... 
....................         stop();
021F8:  CALL   0BA4
.................... 
....................         ////////////////////>>>>>> AUTO <<<<</////////////////////
.................... 
....................         if (!(input(button1)) & mode_auto | (str[0] == 'l' & str[1] == '1'))
021FC:  BSF    F95.6
021FE:  MOVLW  00
02200:  BTFSS  F83.6
02202:  MOVLW  01
02204:  ANDWF  26,W
02206:  MOVWF  x72
02208:  MOVF   2A,W
0220A:  SUBLW  6C
0220C:  BZ    2212
0220E:  MOVLW  00
02210:  BRA    2214
02212:  MOVLW  01
02214:  MOVWF  x73
02216:  MOVF   2B,W
02218:  SUBLW  31
0221A:  BZ    2220
0221C:  MOVLW  00
0221E:  BRA    2222
02220:  MOVLW  01
02222:  ANDWF  x73,W
02224:  IORWF  x72,W
02226:  BZ    22B4
....................         {
....................          
....................             delay_ms(500);
02228:  MOVLW  02
0222A:  MOVWF  x72
0222C:  CLRF   19
0222E:  BTFSC  FF2.7
02230:  BSF    19.7
02232:  BCF    FF2.7
02234:  MOVLW  FA
02236:  MOVWF  x89
02238:  CALL   0348
0223C:  BTFSC  19.7
0223E:  BSF    FF2.7
02240:  DECFSZ x72,F
02242:  BRA    222C
....................             start = True;
02244:  MOVLW  01
02246:  MOVWF  45
....................             str[0] = 'l'; str[1] = '1';
02248:  MOVLW  6C
0224A:  MOVWF  2A
0224C:  MOVLW  31
0224E:  MOVWF  2B
....................             
....................             while (TRUE)
....................             {
....................                enable_interrupts(INT_RDA);
02250:  BSF    F9D.5
....................                 acc_start_normal_auto();
02252:  CALL   11D4
.................... 
....................                 if (return_value == False)
02256:  MOVF   47,F
02258:  BNZ   2260
....................                 {
....................                     return_value = True;
0225A:  MOVLW  01
0225C:  MOVWF  47
....................                     break;
0225E:  BRA    22B4
....................                 }
.................... 
....................                 normal();
02260:  CALL   0D40
.................... 
....................                 if (!(input(button2)) | !(input(button3)) | !(input(button4)) | check_right_proxy() | str[0] != 'l' | str[1] != '1' )
02264:  BSF    F95.4
02266:  MOVLW  00
02268:  BTFSS  F83.4
0226A:  MOVLW  01
0226C:  MOVWF  x72
0226E:  BSF    F95.5
02270:  MOVLW  00
02272:  BTFSS  F83.5
02274:  MOVLW  01
02276:  IORWF  x72,F
02278:  BSF    F95.3
0227A:  MOVLW  00
0227C:  BTFSS  F83.3
0227E:  MOVLW  01
02280:  IORWF  x72,F
02282:  CALL   0CEA
02286:  MOVF   01,W
02288:  IORWF  x72,F
0228A:  MOVF   2A,W
0228C:  SUBLW  6C
0228E:  BNZ   2294
02290:  MOVLW  00
02292:  BRA    2296
02294:  MOVLW  01
02296:  IORWF  x72,F
02298:  MOVF   2B,W
0229A:  SUBLW  31
0229C:  BNZ   22A2
0229E:  MOVLW  00
022A0:  BRA    22A4
022A2:  MOVLW  01
022A4:  IORWF  x72,W
022A6:  BZ    22B2
....................                 {
....................                     stop();
022A8:  CALL   0BA4
....................                     str[0]="0";
022AC:  MOVLW  30
022AE:  MOVWF  2A
....................                     break;
022B0:  BRA    22B4
....................                 }
022B2:  BRA    2250
....................             }
....................         }
.................... 
....................         if (!(input(button3)) & mode_auto | (str[0] == 'r' & str[1] == '1'))
022B4:  BSF    F95.5
022B6:  MOVLW  00
022B8:  BTFSS  F83.5
022BA:  MOVLW  01
022BC:  ANDWF  26,W
022BE:  MOVWF  x72
022C0:  MOVF   2A,W
022C2:  SUBLW  72
022C4:  BZ    22CA
022C6:  MOVLW  00
022C8:  BRA    22CC
022CA:  MOVLW  01
022CC:  MOVWF  x73
022CE:  MOVF   2B,W
022D0:  SUBLW  31
022D2:  BZ    22D8
022D4:  MOVLW  00
022D6:  BRA    22DA
022D8:  MOVLW  01
022DA:  ANDWF  x73,W
022DC:  IORWF  x72,W
022DE:  BZ    236C
....................         {   
....................             delay_ms(500);
022E0:  MOVLW  02
022E2:  MOVWF  x72
022E4:  CLRF   19
022E6:  BTFSC  FF2.7
022E8:  BSF    19.7
022EA:  BCF    FF2.7
022EC:  MOVLW  FA
022EE:  MOVWF  x89
022F0:  CALL   0348
022F4:  BTFSC  19.7
022F6:  BSF    FF2.7
022F8:  DECFSZ x72,F
022FA:  BRA    22E4
....................             start = True;
022FC:  MOVLW  01
022FE:  MOVWF  45
....................             str[0] = 'r'; str[1] = '1';
02300:  MOVLW  72
02302:  MOVWF  2A
02304:  MOVLW  31
02306:  MOVWF  2B
.................... 
....................             while (TRUE)
....................             {
....................                enable_interrupts(INT_RDA);
02308:  BSF    F9D.5
....................                 acc_start_reverse_auto();
0230A:  GOTO   134E
.................... 
....................                 if (return_value == False)
0230E:  MOVF   47,F
02310:  BNZ   2318
....................                 {
....................                     return_value = True;
02312:  MOVLW  01
02314:  MOVWF  47
....................                     break;
02316:  BRA    236C
....................                 }
.................... 
....................                 reverse();
02318:  CALL   0CE0
.................... 
....................                 if (!(input(button2)) | !(input(button1)) | !(input(button4)) | check_left_proxy() | str[0] != 'r' | str[1] != '1')
0231C:  BSF    F95.4
0231E:  MOVLW  00
02320:  BTFSS  F83.4
02322:  MOVLW  01
02324:  MOVWF  x72
02326:  BSF    F95.6
02328:  MOVLW  00
0232A:  BTFSS  F83.6
0232C:  MOVLW  01
0232E:  IORWF  x72,F
02330:  BSF    F95.3
02332:  MOVLW  00
02334:  BTFSS  F83.3
02336:  MOVLW  01
02338:  IORWF  x72,F
0233A:  CALL   0B5A
0233E:  MOVF   01,W
02340:  IORWF  x72,F
02342:  MOVF   2A,W
02344:  SUBLW  72
02346:  BNZ   234C
02348:  MOVLW  00
0234A:  BRA    234E
0234C:  MOVLW  01
0234E:  IORWF  x72,F
02350:  MOVF   2B,W
02352:  SUBLW  31
02354:  BNZ   235A
02356:  MOVLW  00
02358:  BRA    235C
0235A:  MOVLW  01
0235C:  IORWF  x72,W
0235E:  BZ    236A
....................                 {
....................                     stop();
02360:  CALL   0BA4
....................                     str[0]="0";
02364:  MOVLW  30
02366:  MOVWF  2A
....................                     break;
02368:  BRA    236C
....................                 }
0236A:  BRA    2308
....................             }
....................         }
.................... 
....................         ////////////////////>>>>>> CENTER <<<<<//////////////////////
....................         if (!(input(button6)))
0236C:  BSF    F95.2
0236E:  BTFSC  F83.2
02370:  BRA    2396
....................         {
....................             delay_ms(500);
02372:  MOVLW  02
02374:  MOVWF  x72
02376:  CLRF   19
02378:  BTFSC  FF2.7
0237A:  BSF    19.7
0237C:  BCF    FF2.7
0237E:  MOVLW  FA
02380:  MOVWF  x89
02382:  CALL   0348
02386:  BTFSC  19.7
02388:  BSF    FF2.7
0238A:  DECFSZ x72,F
0238C:  BRA    2376
....................             centerline(6);
0238E:  MOVLW  06
02390:  MOVWF  x73
02392:  CALL   0D6C
....................         }
.................... 
....................         ////////////////////>>>>>> GOGO <<<<<//////////////////////
.................... 
....................         if (!(input(button4)))
02396:  BSF    F95.3
02398:  BTFSC  F83.3
0239A:  BRA    23C0
....................         {
....................             delay_ms(500);
0239C:  MOVLW  02
0239E:  MOVWF  x72
023A0:  CLRF   19
023A2:  BTFSC  FF2.7
023A4:  BSF    19.7
023A6:  BCF    FF2.7
023A8:  MOVLW  FA
023AA:  MOVWF  x89
023AC:  CALL   0348
023B0:  BTFSC  19.7
023B2:  BSF    FF2.7
023B4:  DECFSZ x72,F
023B6:  BRA    23A0
....................             str[0]='g';
023B8:  MOVLW  67
023BA:  MOVWF  2A
....................             gogo();
023BC:  CALL   0F7C
....................         }
023C0:  GOTO   1984
....................     }
.................... }
.................... 
023C4:  SLEEP 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
