CCS PCH C Compiler, Version 5.093, 4770               22-Aðu-22 12:14

               Filename:   C:\Users\furka\Desktop\Unity\lcd_stepper_control\main.lst

               ROM used:   6070 bytes (19%)
                           Largest free fragment is 26694
               RAM used:   100 (7%) at main() level
                           115 (7%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 31

0000:  GOTO   0AC8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0154
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <main.h>
.................... #include <18F4520.h>
.................... //////////// Standard Header file for the PIC18F4520 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4520
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 28,0C
00C0:  DATA 01,06
00C2:  CLRF   FF7
00C4:  ADDLW  D2
00C6:  MOVWF  FF6
00C8:  MOVLW  00
00CA:  ADDWFC FF7,F
00CC:  TBLRD*+
00CE:  MOVF   FF5,W
00D0:  RETURN 0
00D2:  DATA 00,00
00D4:  DATA 10,10
00D6:  DATA 10,10
00D8:  DATA 10,00
00DA:  DATA 00,00
00DC:  DATA 14,14
00DE:  DATA 14,14
00E0:  DATA 14,00
00E2:  DATA 00,00
00E4:  DATA 15,15
00E6:  DATA 15,15
00E8:  DATA 15,00
00EA:  DATA 00,00
00EC:  DATA 00,00
00EE:  DATA 00,00
00F0:  DATA 00,00
00F2:  DATA 01,01
00F4:  DATA 01,01
00F6:  DATA 01,01
00F8:  DATA 01,01
00FA:  DATA 1F,05
00FC:  DATA 0A,0A
00FE:  DATA 0E,0E
0100:  DATA 0E,1F
0102:  DATA 10,10
0104:  DATA 10,10
0106:  DATA 10,10
0108:  DATA 10,10
010A:  TBLRD*+
010C:  MOVFF  FF6,71
0110:  MOVFF  FF7,72
0114:  MOVF   FF5,W
0116:  BTFSS  F9E.4
0118:  BRA    0116
011A:  MOVWF  FAD
011C:  MOVFF  71,FF6
0120:  MOVFF  72,FF7
0124:  DECFSZ 70,F
0126:  BRA    010A
0128:  GOTO   018A (RETURN)
012C:  MOVF   FEF,F
012E:  BZ    0150
0130:  MOVFF  FEA,71
0134:  MOVFF  FE9,70
0138:  MOVF   FEF,W
013A:  BTFSS  F9E.4
013C:  BRA    013A
013E:  MOVWF  FAD
0140:  MOVFF  71,FEA
0144:  MOVFF  70,FE9
0148:  INCF   FE9,F
014A:  BTFSC  FD8.2
014C:  INCF   FEA,F
014E:  BRA    012C
0150:  GOTO   0192 (RETURN)
*
019A:  DATA 64,61
019C:  DATA 74,61
019E:  DATA 3A,20
01A0:  DATA 25,73
01A2:  DATA 00,00
01A4:  DATA 20,20
01A6:  DATA 20,20
01A8:  DATA 20,20
01AA:  DATA 48,6F
01AC:  DATA 6D,69
01AE:  DATA 6E,67
01B0:  DATA 2E,2E
01B2:  DATA 2E,20
01B4:  DATA 20,20
01B6:  DATA 00,00
01B8:  DATA 20,20
01BA:  DATA 20,20
01BC:  DATA 20,20
01BE:  DATA 20,20
01C0:  DATA 20,20
01C2:  DATA 20,20
01C4:  DATA 20,20
01C6:  DATA 20,20
01C8:  DATA 20,20
01CA:  DATA 20,20
01CC:  DATA 20,20
01CE:  DATA 20,00
01D0:  DATA 53,70
01D2:  DATA 65,65
01D4:  DATA 64,3A
01D6:  DATA 20,25
01D8:  DATA 00,00
01DA:  DATA 3C,4D
01DC:  DATA 61,6E
01DE:  DATA 75,65
01E0:  DATA 6C,3E
01E2:  DATA 00,00
01E4:  DATA 3C,20
01E6:  DATA 41,75
01E8:  DATA 74,6F
01EA:  DATA 20,3E
01EC:  DATA 00,00
01EE:  DATA 41,63
01F0:  DATA 63,65
01F2:  DATA 6C,3A
01F4:  DATA 20,25
01F6:  DATA 00,00
01F8:  DATA 25,00
01FA:  DATA 20,20
01FC:  DATA 20,20
01FE:  DATA 00,00
0200:  DATA 25,00
0202:  DATA 25,00
0204:  DATA 25,00
0206:  DATA 20,20
0208:  DATA 20,20
020A:  DATA 00,00
020C:  DATA 25,00
020E:  DATA 25,00
0210:  DATA 25,00
0212:  DATA 25,00
0214:  DATA 25,00
0216:  DATA 25,00
0218:  DATA 3C,20
021A:  DATA 41,75
021C:  DATA 74,6F
021E:  DATA 20,3E
0220:  DATA 00,00
*
046C:  TBLRD*+
046E:  MOVF   FF5,F
0470:  BZ    048A
0472:  MOVFF  FF6,60
0476:  MOVFF  FF7,61
047A:  MOVFF  FF5,66
047E:  RCALL  0424
0480:  MOVFF  60,FF6
0484:  MOVFF  61,FF7
0488:  BRA    046C
048A:  RETURN 0
048C:  MOVF   67,W
048E:  CLRF   01
0490:  SUBWF  66,W
0492:  BC    049A
0494:  MOVFF  66,00
0498:  BRA    04B2
049A:  CLRF   00
049C:  MOVLW  08
049E:  MOVWF  68
04A0:  RLCF   66,F
04A2:  RLCF   00,F
04A4:  MOVF   67,W
04A6:  SUBWF  00,W
04A8:  BTFSC  FD8.0
04AA:  MOVWF  00
04AC:  RLCF   01,F
04AE:  DECFSZ 68,F
04B0:  BRA    04A0
04B2:  RETURN 0
04B4:  MOVLW  20
04B6:  BTFSS  61.4
04B8:  MOVLW  30
04BA:  MOVWF  62
04BC:  MOVFF  60,00
04C0:  BTFSS  60.7
04C2:  BRA    04D4
04C4:  COMF   00,F
04C6:  INCF   00,F
04C8:  MOVFF  00,60
04CC:  MOVLW  2D
04CE:  MOVWF  62
04D0:  BSF    61.7
04D2:  BSF    61.0
04D4:  MOVF   01,W
04D6:  MOVFF  60,66
04DA:  MOVLW  64
04DC:  MOVWF  67
04DE:  RCALL  048C
04E0:  MOVFF  00,60
04E4:  MOVLW  30
04E6:  ADDWF  01,W
04E8:  MOVWF  63
04EA:  MOVFF  60,66
04EE:  MOVLW  0A
04F0:  MOVWF  67
04F2:  RCALL  048C
04F4:  MOVLW  30
04F6:  ADDWF  00,W
04F8:  MOVWF  65
04FA:  MOVLW  30
04FC:  ADDWF  01,W
04FE:  MOVWF  64
0500:  MOVFF  62,00
0504:  MOVLW  30
0506:  SUBWF  63,W
0508:  BZ    0512
050A:  BSF    61.1
050C:  BTFSC  61.7
050E:  BSF    61.2
0510:  BRA    0536
0512:  MOVFF  62,63
0516:  MOVLW  20
0518:  MOVWF  62
051A:  MOVLW  30
051C:  SUBWF  64,W
051E:  BZ    0528
0520:  BSF    61.0
0522:  BTFSC  61.7
0524:  BSF    61.1
0526:  BRA    0536
0528:  BTFSS  FD8.2
052A:  BSF    61.0
052C:  BNZ   0536
052E:  MOVFF  63,64
0532:  MOVLW  20
0534:  MOVWF  63
0536:  BTFSC  61.2
0538:  BRA    0544
053A:  BTFSC  61.1
053C:  BRA    054A
053E:  BTFSC  61.0
0540:  BRA    0550
0542:  BRA    0556
0544:  MOVFF  62,66
0548:  RCALL  0424
054A:  MOVFF  63,66
054E:  RCALL  0424
0550:  MOVFF  64,66
0554:  RCALL  0424
0556:  MOVFF  65,66
055A:  RCALL  0424
055C:  RETURN 0
055E:  MOVLW  8E
0560:  MOVWF  00
0562:  MOVFF  60,01
0566:  MOVFF  5F,02
056A:  CLRF   03
056C:  MOVF   01,F
056E:  BNZ   0582
0570:  MOVFF  02,01
0574:  CLRF   02
0576:  MOVLW  08
0578:  SUBWF  00,F
057A:  MOVF   01,F
057C:  BNZ   0582
057E:  CLRF   00
0580:  BRA    0592
0582:  BCF    FD8.0
0584:  BTFSC  01.7
0586:  BRA    0590
0588:  RLCF   02,F
058A:  RLCF   01,F
058C:  DECF   00,F
058E:  BRA    0582
0590:  BCF    01.7
0592:  GOTO   0600 (RETURN)
*
0602:  MOVLW  8E
0604:  MOVWF  00
0606:  MOVF   5F,W
0608:  SUBWF  00,F
060A:  MOVFF  60,02
060E:  MOVFF  61,01
0612:  BSF    02.7
0614:  MOVF   00,F
0616:  BZ    062A
0618:  BCF    FD8.0
061A:  MOVF   02,F
061C:  BNZ   0622
061E:  MOVF   01,F
0620:  BZ    062A
0622:  RRCF   02,F
0624:  RRCF   01,F
0626:  DECFSZ 00,F
0628:  BRA    0618
062A:  BTFSS  60.7
062C:  BRA    0638
062E:  COMF   01,F
0630:  COMF   02,F
0632:  INCF   01,F
0634:  BTFSC  FD8.2
0636:  INCF   02,F
0638:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... #use delay(internal=8MHz)
*
0222:  CLRF   FEA
0224:  MOVLW  67
0226:  MOVWF  FE9
0228:  MOVF   FEF,W
022A:  BZ    0246
022C:  MOVLW  02
022E:  MOVWF  01
0230:  CLRF   00
0232:  DECFSZ 00,F
0234:  BRA    0232
0236:  DECFSZ 01,F
0238:  BRA    0230
023A:  MOVLW  97
023C:  MOVWF  00
023E:  DECFSZ 00,F
0240:  BRA    023E
0242:  DECFSZ FEF,F
0244:  BRA    022C
0246:  RETURN 0
.................... #use timer(timer=0,tick=100us,bits=32,NOISR)
*
03A6:  MOVF   FD6,W
03A8:  MOVFF  FD7,03
03AC:  BTFSS  FF2.2
03AE:  BRA    03C8
03B0:  MOVLW  01
03B2:  ADDWF  19,F
03B4:  BTFSC  FD8.0
03B6:  INCF   1A,F
03B8:  BTFSC  FD8.2
03BA:  INCF   1B,F
03BC:  BTFSC  FD8.2
03BE:  INCF   1C,F
03C0:  BCF    FF2.2
03C2:  MOVF   FD6,W
03C4:  MOVFF  FD7,03
03C8:  MOVWF  00
03CA:  MOVFF  03,01
03CE:  MOVFF  19,02
03D2:  MOVFF  1A,03
03D6:  MOVF   1B,W
03D8:  RRCF   FE8,F
03DA:  RRCF   03,F
03DC:  RRCF   02,F
03DE:  RRCF   01,F
03E0:  RRCF   00,F
03E2:  RETURN 0
.................... #define TICK_TYPE unsigned int32
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <flex_lcd420.c>
.................... // Flex_LCD420.c
.................... 
.................... // These pins are for my Microchip PicDem2-Plus board,
.................... // which I used to test this driver.
.................... // An external 20x4 LCD is connected to these pins.
.................... // Change these pins to match your own board's connections.
.................... 
.................... #define LCD_DB4   PIN_A4
.................... #define LCD_DB5   PIN_A5
.................... #define LCD_DB6   PIN_E0
.................... #define LCD_DB7   PIN_E1
.................... 
.................... #define LCD_RS    PIN_A1
.................... #define LCD_RW    PIN_A2
.................... #define LCD_E     PIN_A3
.................... 
.................... /*
.................... // To prove that the driver can be used with random
.................... // pins, I also tested it with these pins:
.................... #define LCD_DB4   PIN_D4
.................... #define LCD_DB5   PIN_B1
.................... #define LCD_DB6   PIN_C5
.................... #define LCD_DB7   PIN_B5
.................... 
.................... #define LCD_RS    PIN_E2
.................... #define LCD_RW    PIN_B2
.................... #define LCD_E     PIN_D6
.................... */
.................... 
.................... // If you want only a 6-pin interface to your LCD, then
.................... // connect the R/W pin on the LCD to ground, and comment
.................... // out the following line.  Doing so will save one PIC
.................... // pin, but at the cost of losing the ability to read from
.................... // the LCD.  It also makes the write time a little longer
.................... // because a static delay must be used, instead of polling
.................... // the LCD's busy bit.  Normally a 6-pin interface is only
.................... // used if you are running out of PIC pins, and you need
.................... // to use as few as possible for the LCD.
.................... #define USE_RW_PIN   1     
.................... 
.................... 
.................... // These are the line addresses for most 4x20 LCDs.
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x40
.................... #define LCD_LINE_3_ADDRESS 0x14
.................... #define LCD_LINE_4_ADDRESS 0x54
.................... 
.................... // These are the line addresses for LCD's which use
.................... // the Hitachi HD66712U controller chip.
.................... /*
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x20
.................... #define LCD_LINE_3_ADDRESS 0x40
.................... #define LCD_LINE_4_ADDRESS 0x60
.................... */
.................... 
.................... 
.................... //========================================
.................... 
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)
.................... 
.................... int8 lcd_line;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots
....................  0xc,                     // Display on
....................  1,                       // Clear display
....................  6                        // Increment cursor
....................  };
....................                              
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
.................... // Note:  !! converts an integer expression
.................... // to a boolean (1 or 0).
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
0248:  BTFSC  6E.0
024A:  BRA    0250
024C:  BCF    F89.4
024E:  BRA    0252
0250:  BSF    F89.4
0252:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
0254:  BTFSC  6E.1
0256:  BRA    025C
0258:  BCF    F89.5
025A:  BRA    025E
025C:  BSF    F89.5
025E:  BCF    F92.5
....................  output_bit(LCD_DB6, !!(nibble & 4));   
0260:  BTFSC  6E.2
0262:  BRA    0268
0264:  BCF    F8D.0
0266:  BRA    026A
0268:  BSF    F8D.0
026A:  BCF    F96.0
....................  output_bit(LCD_DB7, !!(nibble & 8));   
026C:  BTFSC  6E.3
026E:  BRA    0274
0270:  BCF    F8D.1
0272:  BRA    0276
0274:  BSF    F8D.1
0276:  BCF    F96.1
.................... 
....................  delay_cycles(1);
0278:  NOP   
....................  output_high(LCD_E);
027A:  BCF    F92.3
027C:  BSF    F89.3
....................  delay_us(2);
027E:  BRA    0280
0280:  BRA    0282
....................  output_low(LCD_E);
0282:  BCF    F92.3
0284:  BCF    F89.3
0286:  RETURN 0
.................... }
.................... 
.................... //-----------------------------------
.................... // This sub-routine is only called by lcd_read_byte().
.................... // It's not a stand-alone routine.  For example, the
.................... // R/W signal is set high by lcd_read_byte() before
.................... // this routine is called.     
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... // Create bit variables so that we can easily set
.................... // individual bits in the retval variable.
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
0288:  CLRF   6F
....................    
.................... output_high(LCD_E);
028A:  BCF    F92.3
028C:  BSF    F89.3
.................... delay_us(1);
028E:  BRA    0290
.................... 
.................... retval_0 = input(LCD_DB4);
0290:  BSF    F92.4
0292:  BCF    6F.0
0294:  BTFSC  F80.4
0296:  BSF    6F.0
.................... retval_1 = input(LCD_DB5);
0298:  BSF    F92.5
029A:  BCF    6F.1
029C:  BTFSC  F80.5
029E:  BSF    6F.1
.................... retval_2 = input(LCD_DB6);
02A0:  BSF    F96.0
02A2:  BCF    6F.2
02A4:  BTFSC  F84.0
02A6:  BSF    6F.2
.................... retval_3 = input(LCD_DB7);
02A8:  BSF    F96.1
02AA:  BCF    6F.3
02AC:  BTFSC  F84.1
02AE:  BSF    6F.3
....................  
.................... output_low(LCD_E);
02B0:  BCF    F92.3
02B2:  BCF    F89.3
.................... delay_us(1);
02B4:  BRA    02B6
....................    
.................... return(retval);   
02B6:  MOVFF  6F,01
02BA:  RETURN 0
.................... }   
.................... #endif
.................... 
.................... //---------------------------------------
.................... // Read a byte from the LCD and return it.
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
02BC:  BCF    F92.2
02BE:  BSF    F89.2
.................... delay_cycles(1);
02C0:  NOP   
.................... 
.................... high = lcd_read_nibble();
02C2:  RCALL  0288
02C4:  MOVFF  01,6E
.................... 
.................... low = lcd_read_nibble();
02C8:  RCALL  0288
02CA:  MOVFF  01,6D
.................... 
.................... return( (high<<4) | low);
02CE:  SWAPF  6E,W
02D0:  MOVWF  00
02D2:  MOVLW  F0
02D4:  ANDWF  00,F
02D6:  MOVF   00,W
02D8:  IORWF  6D,W
02DA:  MOVWF  01
02DC:  GOTO   02E6 (RETURN)
.................... }
.................... #endif
.................... 
.................... //----------------------------------------
.................... // Send a byte to the LCD.
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
02E0:  BCF    F92.1
02E2:  BCF    F89.1
.................... 
.................... #ifdef USE_RW_PIN
.................... while(bit_test(lcd_read_byte(),7)) ;
02E4:  BRA    02BC
02E6:  MOVFF  01,6D
02EA:  BTFSC  01.7
02EC:  BRA    02E4
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
02EE:  MOVF   6B,F
02F0:  BZ    02F8
....................    output_high(LCD_RS);
02F2:  BCF    F92.1
02F4:  BSF    F89.1
02F6:  BRA    02FC
.................... else
....................    output_low(LCD_RS);
02F8:  BCF    F92.1
02FA:  BCF    F89.1
....................      
....................  delay_cycles(1);
02FC:  NOP   
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
02FE:  BCF    F92.2
0300:  BCF    F89.2
.................... delay_cycles(1);
0302:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
0304:  BCF    F92.3
0306:  BCF    F89.3
.................... 
.................... lcd_send_nibble(n >> 4);
0308:  SWAPF  6C,W
030A:  MOVWF  6D
030C:  MOVLW  0F
030E:  ANDWF  6D,F
0310:  MOVFF  6D,6E
0314:  RCALL  0248
.................... lcd_send_nibble(n & 0xf);
0316:  MOVF   6C,W
0318:  ANDLW  0F
031A:  MOVWF  6D
031C:  MOVWF  6E
031E:  RCALL  0248
0320:  RETURN 0
.................... }
.................... //----------------------------
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... lcd_line = 1;
0322:  MOVLW  01
0324:  MOVWF  1F
.................... 
.................... output_low(LCD_RS);
0326:  BCF    F92.1
0328:  BCF    F89.1
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
032A:  BCF    F92.2
032C:  BCF    F89.2
.................... #endif
.................... 
.................... output_low(LCD_E);
032E:  BCF    F92.3
0330:  BCF    F89.3
.................... 
.................... // Some LCDs require 15 ms minimum delay after
.................... // power-up.  Others require 30 ms.  I'm going
.................... // to set it to 35 ms, so it should work with
.................... // all of them.
.................... delay_ms(35);         
0332:  MOVLW  23
0334:  MOVWF  67
0336:  RCALL  0222
.................... 
.................... for(i=0 ;i < 3; i++)
0338:  CLRF   5F
033A:  MOVF   5F,W
033C:  SUBLW  02
033E:  BNC   0350
....................    {
....................     lcd_send_nibble(0x03);
0340:  MOVLW  03
0342:  MOVWF  6E
0344:  RCALL  0248
....................     delay_ms(5);
0346:  MOVLW  05
0348:  MOVWF  67
034A:  RCALL  0222
034C:  INCF   5F,F
034E:  BRA    033A
....................    }
.................... 
.................... lcd_send_nibble(0x02);
0350:  MOVLW  02
0352:  MOVWF  6E
0354:  RCALL  0248
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
0356:  CLRF   5F
0358:  MOVF   5F,W
035A:  SUBLW  03
035C:  BNC   0370
....................    {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
035E:  CLRF   03
0360:  MOVF   5F,W
0362:  RCALL  00AE
0364:  MOVWF  60
0366:  CLRF   6B
0368:  MOVWF  6C
036A:  RCALL  02E0
....................    
....................     // If the R/W signal is not used, then
....................     // the busy bit can't be polled.  One of
....................     // the init commands takes longer than
....................     // the hard-coded delay of 50 us, so in
....................     // that case, lets just do a 5 ms delay
....................     // after all four of them.
....................     #ifndef USE_RW_PIN
036C:  INCF   5F,F
036E:  BRA    0358
....................     delay_ms(5);
....................     #endif
....................    }
0370:  GOTO   0B56 (RETURN)
.................... 
.................... }
.................... 
.................... //----------------------------
.................... 
.................... void lcd_gotoxy(int8 x, int8 y)
.................... {
.................... int8 address;
.................... 
.................... 
.................... switch(y)
*
03E4:  MOVF   68,W
03E6:  XORLW  01
03E8:  BZ    03F8
03EA:  XORLW  03
03EC:  BZ    03FC
03EE:  XORLW  01
03F0:  BZ    0402
03F2:  XORLW  07
03F4:  BZ    0408
03F6:  BRA    040E
....................   {
....................    case 1:
....................      address = LCD_LINE_1_ADDRESS;
03F8:  CLRF   69
....................      break;
03FA:  BRA    0410
.................... 
....................    case 2:
....................      address = LCD_LINE_2_ADDRESS;
03FC:  MOVLW  40
03FE:  MOVWF  69
....................      break;
0400:  BRA    0410
.................... 
....................    case 3:
....................      address = LCD_LINE_3_ADDRESS;
0402:  MOVLW  14
0404:  MOVWF  69
....................      break;
0406:  BRA    0410
.................... 
....................    case 4:
....................      address = LCD_LINE_4_ADDRESS;
0408:  MOVLW  54
040A:  MOVWF  69
....................      break;
040C:  BRA    0410
.................... 
....................    default:
....................      address = LCD_LINE_1_ADDRESS;
040E:  CLRF   69
....................      break;
....................      
....................   }
.................... 
.................... address += x-1;
0410:  MOVLW  01
0412:  SUBWF  67,W
0414:  ADDWF  69,F
.................... lcd_send_byte(0, 0x80 | address);
0416:  MOVF   69,W
0418:  IORLW  80
041A:  MOVWF  6A
041C:  CLRF   6B
041E:  MOVWF  6C
0420:  RCALL  02E0
0422:  RETURN 0
.................... }
.................... 
.................... //-----------------------------
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
0424:  MOVF   66,W
0426:  XORLW  0C
0428:  BZ    0434
042A:  XORLW  06
042C:  BZ    0448
042E:  XORLW  02
0430:  BZ    0456
0432:  BRA    0460
....................    {
....................     case '\f':
....................       lcd_send_byte(0,1);
0434:  CLRF   6B
0436:  MOVLW  01
0438:  MOVWF  6C
043A:  RCALL  02E0
....................       lcd_line = 1;
043C:  MOVLW  01
043E:  MOVWF  1F
....................       delay_ms(2);
0440:  MOVLW  02
0442:  MOVWF  67
0444:  RCALL  0222
....................       break;
0446:  BRA    046A
....................    
....................     case '\n':
....................        lcd_gotoxy(1, ++lcd_line);
0448:  INCF   1F,F
044A:  MOVLW  01
044C:  MOVWF  67
044E:  MOVFF  1F,68
0452:  RCALL  03E4
....................        break;
0454:  BRA    046A
....................    
....................     case '\b':
....................        lcd_send_byte(0,0x10);
0456:  CLRF   6B
0458:  MOVLW  10
045A:  MOVWF  6C
045C:  RCALL  02E0
....................        break;
045E:  BRA    046A
....................    
....................     default:
....................        lcd_send_byte(1,c);
0460:  MOVLW  01
0462:  MOVWF  6B
0464:  MOVFF  66,6C
0468:  RCALL  02E0
....................        break;
....................    }
046A:  RETURN 0
.................... }
.................... 
.................... //------------------------------
.................... #ifdef USE_RW_PIN
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(LCD_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... 
.................... #INCLUDE <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #fuses XT,NOWDT,NOPROTECT,NOBROWNOUT,NOLVP,NOPUT,NOWRT,NODEBUG,NOCPD
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1)
.................... 
.................... 
.................... #define A1 PIN_D2
.................... #define A2 PIN_B1
.................... #define B1 PIN_B0
.................... #define B2 PIN_C5
.................... 
.................... #define button0  PIN_D5 // select adc or pot
.................... #define button1  PIN_D1 //right
.................... #define button2  PIN_D0 //left
.................... #define button3  PIN_C3 //mid
.................... #define button4  PIN_C2 //mode
.................... #define button5  PIN_C1 //mode
.................... 
.................... #define proxy_right PIN_D6
.................... #define proxy_left PIN_D7
.................... 
.................... #define one_dot  0
.................... #define two_dot 1
.................... #define three_dot 2
.................... #define blank 3
.................... #define m1 4
.................... #define m2 5
.................... #define m3 6
.................... 
.................... int delay_s=5;
.................... int accel=6;
.................... int accel_value=30;
.................... int c=0;
.................... 
.................... char mode_auto=False;
.................... char mode_manuel=True;
.................... char flag=TRUE;
.................... 
.................... char data;
.................... char str[8];
.................... int counter=0;
.................... char correct= False;
.................... char quit1=False;
.................... char quit2=False;
.................... 
.................... char proxy=False;
.................... int16 centercounter=0;
.................... 
.................... TICK_TYPE StartTick,FinishTick,CurrentTick;
.................... 
.................... 
.................... #int_rda
.................... 
.................... void serial_comm()
.................... {
....................    //lcd_putc ("data received: ") ;
....................    data = getc () ;
*
0154:  BTFSS  F9E.5
0156:  BRA    0154
0158:  MOVFF  FAE,2B
....................    //printf(data);
....................    //lcd_putc (data) ;
....................    str[counter] = data;
015C:  CLRF   03
015E:  MOVF   34,W
0160:  ADDLW  2C
0162:  MOVWF  FE9
0164:  MOVLW  00
0166:  ADDWFC 03,W
0168:  MOVWF  FEA
016A:  MOVFF  2B,FEF
....................    //lcd_putc (str[counter]) ;
....................    counter++;
016E:  INCF   34,F
....................    //lcd_putc (str[counter]) ;
.................... 
....................    if (data == '!')
0170:  MOVF   2B,W
0172:  SUBLW  21
0174:  BNZ   0192
....................    {
....................   /*
....................       lcd_putc ("Data: ");
....................       for (int i = 0; i < counter - 1; i++)
....................       {
....................          lcd_putc (str[i]);
....................       }
....................   */    
....................       counter = 0;
0176:  CLRF   34
....................       correct = True;
0178:  MOVLW  01
017A:  MOVWF  35
....................       printf("data: %s",data);
017C:  MOVLW  9A
017E:  MOVWF  FF6
0180:  MOVLW  01
0182:  MOVWF  FF7
0184:  MOVLW  06
0186:  MOVWF  70
0188:  BRA    010A
018A:  CLRF   FEA
018C:  MOVFF  2B,FE9
0190:  BRA    012C
....................       //delay_ms (500);
....................     //  lcd_putc ('\f');
....................    }
....................    
.................... disable_interrupts (int_rda) ;
0192:  BCF    F9D.5
....................    
0194:  BCF    F9E.5
0196:  GOTO   0060
.................... }
.................... 
.................... void delay_func(loop){
.................... 
.................... delay_cycles(200);delay_cycles(200);delay_cycles(200);
*
063A:  MOVLW  42
063C:  MOVWF  00
063E:  DECFSZ 00,F
0640:  BRA    063E
0642:  NOP   
0644:  MOVLW  42
0646:  MOVWF  00
0648:  DECFSZ 00,F
064A:  BRA    0648
064C:  NOP   
064E:  MOVLW  42
0650:  MOVWF  00
0652:  DECFSZ 00,F
0654:  BRA    0652
0656:  NOP   
.................... for(int i=0;i<10-loop;i++){
0658:  CLRF   66
065A:  MOVLW  0A
065C:  BSF    FD8.0
065E:  SUBFWB 65,W
0660:  SUBWF  66,W
0662:  BC    0672
....................    delay_cycles(150);
0664:  MOVLW  31
0666:  MOVWF  00
0668:  DECFSZ 00,F
066A:  BRA    0668
066C:  BRA    066E
066E:  INCF   66,F
0670:  BRA    065A
.................... }
0672:  RETURN 0
.................... }
.................... 
.................... void normal(loop)
.................... {
.................... 
.................... //HALF STEPPING
....................       output_high (A1) ;
0674:  BCF    F95.2
0676:  BSF    F8C.2
....................       output_low (A2) ;
0678:  BCF    F93.1
067A:  BCF    F8A.1
....................       output_low (B1) ;
067C:  BCF    F93.0
067E:  BCF    F8A.0
....................       output_low (B2) ;
0680:  BCF    F94.5
0682:  BCF    F8B.5
....................       delay_func (loop) ;
0684:  MOVFF  64,65
0688:  RCALL  063A
....................       
....................       output_high (A1) ;
068A:  BCF    F95.2
068C:  BSF    F8C.2
....................       output_low (A2) ;
068E:  BCF    F93.1
0690:  BCF    F8A.1
....................       output_high (B1) ;
0692:  BCF    F93.0
0694:  BSF    F8A.0
....................       output_low (B2) ;
0696:  BCF    F94.5
0698:  BCF    F8B.5
....................       delay_func (loop) ;
069A:  MOVFF  64,65
069E:  RCALL  063A
....................       
....................       output_low (A1) ;
06A0:  BCF    F95.2
06A2:  BCF    F8C.2
....................       output_low (A2) ;
06A4:  BCF    F93.1
06A6:  BCF    F8A.1
....................       output_high (B1) ;
06A8:  BCF    F93.0
06AA:  BSF    F8A.0
....................       output_low (B2) ;
06AC:  BCF    F94.5
06AE:  BCF    F8B.5
....................       delay_func (loop) ;
06B0:  MOVFF  64,65
06B4:  RCALL  063A
....................       
....................       output_low (A1) ;
06B6:  BCF    F95.2
06B8:  BCF    F8C.2
....................       output_high (A2) ;
06BA:  BCF    F93.1
06BC:  BSF    F8A.1
....................       output_high (B1) ;
06BE:  BCF    F93.0
06C0:  BSF    F8A.0
....................       output_low (B2) ;
06C2:  BCF    F94.5
06C4:  BCF    F8B.5
....................       delay_func (loop) ;
06C6:  MOVFF  64,65
06CA:  RCALL  063A
....................       
....................       output_low (A1) ;
06CC:  BCF    F95.2
06CE:  BCF    F8C.2
....................       output_high (A2) ;
06D0:  BCF    F93.1
06D2:  BSF    F8A.1
....................       output_low (B1) ;
06D4:  BCF    F93.0
06D6:  BCF    F8A.0
....................       output_low (B2) ;
06D8:  BCF    F94.5
06DA:  BCF    F8B.5
....................       delay_func (loop) ;
06DC:  MOVFF  64,65
06E0:  RCALL  063A
....................       
....................       output_low (A1) ;
06E2:  BCF    F95.2
06E4:  BCF    F8C.2
....................       output_high (A2) ;
06E6:  BCF    F93.1
06E8:  BSF    F8A.1
....................       output_low (B1) ;
06EA:  BCF    F93.0
06EC:  BCF    F8A.0
....................       output_high (B2) ;
06EE:  BCF    F94.5
06F0:  BSF    F8B.5
....................       delay_func (loop) ;
06F2:  MOVFF  64,65
06F6:  RCALL  063A
....................       
....................       output_low (A1) ;
06F8:  BCF    F95.2
06FA:  BCF    F8C.2
....................       output_low (A2) ;
06FC:  BCF    F93.1
06FE:  BCF    F8A.1
....................       output_low (B1) ;
0700:  BCF    F93.0
0702:  BCF    F8A.0
....................       output_high (B2) ;
0704:  BCF    F94.5
0706:  BSF    F8B.5
....................       delay_func (loop) ;
0708:  MOVFF  64,65
070C:  RCALL  063A
....................       
....................       output_high (A1) ;
070E:  BCF    F95.2
0710:  BSF    F8C.2
....................       output_low (A2) ;
0712:  BCF    F93.1
0714:  BCF    F8A.1
....................       output_low (B1) ;
0716:  BCF    F93.0
0718:  BCF    F8A.0
....................       output_high (B2) ;
071A:  BCF    F94.5
071C:  BSF    F8B.5
....................       delay_func (loop) ;
071E:  MOVFF  64,65
0722:  RCALL  063A
0724:  RETURN 0
....................  
.................... 
.................... 
.................... /*
.................... //ONE STEPPING  
....................    output_high (A1) ;
....................    output_low (A2) ;
....................    output_low (B1) ;
....................    output_low (B2) ;
....................    delay_ms (delay) ;
....................    
....................    output_low (A1) ;
....................    output_low (A2) ;
....................    output_high (B1) ;
....................    output_low (B2) ;
....................    delay_ms (delay) ;
....................    
....................    output_low (A1) ;
....................    output_high (A2) ;
....................    output_low (B1) ;
....................    output_low (B2) ;
....................    delay_ms (delay) ;
....................    
....................    output_low (A1) ;
....................    output_low (A2) ;
....................    output_low (B1) ;
....................    output_high (B2) ;
....................    delay_ms (delay) ;
.................... 
.................... 
.................... */
.................... /*
.................... //TWO STEPPING
.................... 
.................... output_high (A1) ;
....................    output_low (A2) ;
....................    output_high (B1) ;
....................    output_low (B2) ;
....................    delay_ms (delay) ;
....................    
....................    output_low (A1) ;
....................    output_high (A2) ;
....................    output_high (B1) ;
....................    output_low (B2) ;
....................    delay_ms (delay) ;
....................    
....................    output_low (A1) ;
....................    output_high (A2) ;
....................    output_low (B1) ;
....................    output_high (B2) ;
....................    delay_ms (delay) ;
....................    
....................    output_high (A1) ;
....................    output_low (A2) ;
....................    output_low (B1) ;
....................    output_high (B2) ;
....................    delay_ms (delay) ;
....................    */
.................... 
.................... }
.................... 
.................... void reverse(loop)
.................... {
....................    output_high (A1);
*
0752:  BCF    F95.2
0754:  BSF    F8C.2
....................    output_low (A2);
0756:  BCF    F93.1
0758:  BCF    F8A.1
....................    output_low (B1);
075A:  BCF    F93.0
075C:  BCF    F8A.0
....................    output_high (B2);
075E:  BCF    F94.5
0760:  BSF    F8B.5
....................    delay_func (loop) ;
0762:  MOVFF  64,65
0766:  RCALL  063A
....................    
....................    output_low (A1);
0768:  BCF    F95.2
076A:  BCF    F8C.2
....................    output_low (A2);
076C:  BCF    F93.1
076E:  BCF    F8A.1
....................    output_low (B1);
0770:  BCF    F93.0
0772:  BCF    F8A.0
....................    output_high (B2);
0774:  BCF    F94.5
0776:  BSF    F8B.5
....................    delay_func (loop) ;
0778:  MOVFF  64,65
077C:  RCALL  063A
....................    
....................    output_low (A1);
077E:  BCF    F95.2
0780:  BCF    F8C.2
....................    output_high (A2);
0782:  BCF    F93.1
0784:  BSF    F8A.1
....................    output_low (B1);
0786:  BCF    F93.0
0788:  BCF    F8A.0
....................    output_high (B2);
078A:  BCF    F94.5
078C:  BSF    F8B.5
....................    delay_func (loop) ;
078E:  MOVFF  64,65
0792:  RCALL  063A
....................    
....................    output_low (A1);
0794:  BCF    F95.2
0796:  BCF    F8C.2
....................    output_high (A2);
0798:  BCF    F93.1
079A:  BSF    F8A.1
....................    output_low (B1);
079C:  BCF    F93.0
079E:  BCF    F8A.0
....................    output_low (B2);
07A0:  BCF    F94.5
07A2:  BCF    F8B.5
....................    delay_func (loop) ;
07A4:  MOVFF  64,65
07A8:  RCALL  063A
....................    
....................    output_low (A1);
07AA:  BCF    F95.2
07AC:  BCF    F8C.2
....................    output_high (A2);
07AE:  BCF    F93.1
07B0:  BSF    F8A.1
....................    output_high (B1);
07B2:  BCF    F93.0
07B4:  BSF    F8A.0
....................    output_low (B2);
07B6:  BCF    F94.5
07B8:  BCF    F8B.5
....................    delay_func (loop) ;
07BA:  MOVFF  64,65
07BE:  RCALL  063A
....................    
....................    output_low (A1);
07C0:  BCF    F95.2
07C2:  BCF    F8C.2
....................    output_low (A2);
07C4:  BCF    F93.1
07C6:  BCF    F8A.1
....................    output_high (B1);
07C8:  BCF    F93.0
07CA:  BSF    F8A.0
....................    output_low (B2);
07CC:  BCF    F94.5
07CE:  BCF    F8B.5
....................    delay_func (loop) ;
07D0:  MOVFF  64,65
07D4:  RCALL  063A
....................    
....................    output_high (A1);
07D6:  BCF    F95.2
07D8:  BSF    F8C.2
....................    output_low (A2);
07DA:  BCF    F93.1
07DC:  BCF    F8A.1
....................    output_high (B1);
07DE:  BCF    F93.0
07E0:  BSF    F8A.0
....................    output_low (B2);
07E2:  BCF    F94.5
07E4:  BCF    F8B.5
....................    delay_func (loop) ;
07E6:  MOVFF  64,65
07EA:  RCALL  063A
....................    
....................    output_high (A1);
07EC:  BCF    F95.2
07EE:  BSF    F8C.2
....................    output_low (A2);
07F0:  BCF    F93.1
07F2:  BCF    F8A.1
....................    output_low (B1);
07F4:  BCF    F93.0
07F6:  BCF    F8A.0
....................    output_low (B2);
07F8:  BCF    F94.5
07FA:  BCF    F8B.5
....................    delay_func (loop) ;
07FC:  MOVFF  64,65
0800:  RCALL  063A
0802:  RETURN 0
.................... }
.................... 
.................... void stop()
.................... {
....................    output_low (A1);
*
073A:  BCF    F95.2
073C:  BCF    F8C.2
....................    output_low (A2);
073E:  BCF    F93.1
0740:  BCF    F8A.1
....................    output_low (B1);
0742:  BCF    F93.0
0744:  BCF    F8A.0
....................    output_low (B2);
0746:  BCF    F94.5
0748:  BCF    F8B.5
....................    delay_ms (1);
074A:  MOVLW  01
074C:  MOVWF  67
074E:  RCALL  0222
0750:  RETURN 0
.................... }
.................... 
.................... char check_right_proxy(){
.................... 
....................    if (input(proxy_right)==1) {
*
0726:  BSF    F95.6
0728:  BTFSS  F83.6
072A:  BRA    0732
....................         proxy=True;
072C:  MOVLW  01
072E:  MOVWF  38
....................       }
0730:  BRA    0734
....................        
....................    else {
....................       proxy=False;
0732:  CLRF   38
....................    }
....................    return proxy;
0734:  MOVFF  38,01
0738:  RETURN 0
.................... }
.................... 
.................... char check_left_proxy(){
.................... 
....................    if (input(proxy_left)==1) {
*
0804:  BSF    F95.7
0806:  BTFSS  F83.7
0808:  BRA    0810
....................         proxy=True;
080A:  MOVLW  01
080C:  MOVWF  38
....................       }
080E:  BRA    0812
....................        
....................    else {
....................       proxy=False;
0810:  CLRF   38
....................    }
....................    return proxy;
0812:  MOVFF  38,01
0816:  RETURN 0
.................... }
.................... void acc_start_normal_man(){
.................... 
....................     
.................... }
.................... 
.................... float read_serial_speed() 
.................... {
....................    if (str[0] == 's')
*
0596:  MOVF   2C,W
0598:  SUBLW  73
059A:  BNZ   05F8
....................    {
....................       correct = False;
059C:  CLRF   35
....................       
....................       if (str[1] == '9')
059E:  MOVF   2D,W
05A0:  SUBLW  39
05A2:  BNZ   05A8
....................       {
....................          delay_s = 5;
05A4:  MOVLW  05
05A6:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '8')
05A8:  MOVF   2D,W
05AA:  SUBLW  38
05AC:  BNZ   05B2
....................       {
....................          delay_s = 5;
05AE:  MOVLW  05
05B0:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '7')
05B2:  MOVF   2D,W
05B4:  SUBLW  37
05B6:  BNZ   05BC
....................       {
....................          delay_s = 6;
05B8:  MOVLW  06
05BA:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '6')
05BC:  MOVF   2D,W
05BE:  SUBLW  36
05C0:  BNZ   05C6
....................       {
....................          delay_s = 7;
05C2:  MOVLW  07
05C4:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '5')
05C6:  MOVF   2D,W
05C8:  SUBLW  35
05CA:  BNZ   05D0
....................       {
....................          delay_s = 8;
05CC:  MOVLW  08
05CE:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '4')
05D0:  MOVF   2D,W
05D2:  SUBLW  34
05D4:  BNZ   05DA
....................       {
....................          delay_s = 9;
05D6:  MOVLW  09
05D8:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '3')
05DA:  MOVF   2D,W
05DC:  SUBLW  33
05DE:  BNZ   05E4
....................       {
....................          delay_s = 10;
05E0:  MOVLW  0A
05E2:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '2')
05E4:  MOVF   2D,W
05E6:  SUBLW  32
05E8:  BNZ   05EE
....................       {
....................          delay_s = 11;
05EA:  MOVLW  0B
05EC:  MOVWF  24
....................       }
.................... 
....................       
....................       if (str[1] == '1')
05EE:  MOVF   2D,W
05F0:  SUBLW  31
05F2:  BNZ   05F8
....................       {
....................          delay_s = 12;
05F4:  MOVLW  0C
05F6:  MOVWF  24
....................       }
....................    }
.................... 
....................    return delay_s;
05F8:  CLRF   60
05FA:  MOVFF  24,5F
05FE:  BRA    055E
0600:  RETURN 0
.................... }
.................... 
.................... void centerline(delay){
....................   centercounter=0;
*
0818:  CLRF   3A
081A:  CLRF   39
....................   lcd_gotoxy(1,4);
081C:  MOVLW  01
081E:  MOVWF  67
0820:  MOVLW  04
0822:  MOVWF  68
0824:  RCALL  03E4
....................   lcd_putc("      Homing...   ");
0826:  MOVLW  A4
0828:  MOVWF  FF6
082A:  MOVLW  01
082C:  MOVWF  FF7
082E:  RCALL  046C
....................          
....................   while (1){
....................    
....................     
....................     if (check_left_proxy()){
0830:  RCALL  0804
0832:  MOVF   01,F
0834:  BZ    0840
....................       stop();
0836:  RCALL  073A
....................       output_toggle (PIN_D4);
0838:  BCF    F95.4
083A:  BTG    F8C.4
....................       correct = False;
083C:  CLRF   35
....................       
....................       break;
083E:  BRA    0862
....................     }
....................     
....................     if(input (button1) == 1 | input (button3) == 1){
0840:  BSF    F95.1
0842:  MOVLW  00
0844:  BTFSC  F83.1
0846:  MOVLW  01
0848:  MOVWF  61
084A:  BSF    F94.3
084C:  MOVLW  00
084E:  BTFSC  F82.3
0850:  MOVLW  01
0852:  IORWF  61,W
0854:  BZ    085A
....................       stop();
0856:  RCALL  073A
....................       return;
0858:  BRA    0976
....................       }
....................    
....................       reverse(delay);
085A:  MOVFF  5F,64
085E:  RCALL  0752
0860:  BRA    0830
....................    }
....................    
....................    StartTick = get_ticks();
0862:  RCALL  03A6
0864:  MOVFF  03,3E
0868:  MOVFF  02,3D
086C:  MOVFF  01,3C
0870:  MOVFF  00,3B
....................    
....................    
....................    
....................    while (1){
.................... 
....................       if (check_right_proxy()){
0874:  RCALL  0726
0876:  MOVF   01,F
0878:  BZ    0880
....................          stop();
087A:  RCALL  073A
....................          correct = False;
087C:  CLRF   35
....................          break;
087E:  BRA    08A8
....................       }
....................       
....................       if(input (button1) == 1 | input (button3) == 1){
0880:  BSF    F95.1
0882:  MOVLW  00
0884:  BTFSC  F83.1
0886:  MOVLW  01
0888:  MOVWF  61
088A:  BSF    F94.3
088C:  MOVLW  00
088E:  BTFSC  F82.3
0890:  MOVLW  01
0892:  IORWF  61,W
0894:  BZ    089A
....................       stop();
0896:  RCALL  073A
....................       return;
0898:  BRA    0976
....................       }
....................       
....................       
....................       centercounter++;
089A:  INCF   39,F
089C:  BTFSC  FD8.2
089E:  INCF   3A,F
....................       normal(delay);
08A0:  MOVFF  5F,64
08A4:  RCALL  0674
08A6:  BRA    0874
....................       
....................       //printf("data: %s", centercounter);
....................      }
....................      
....................     FinishTick = get_ticks();
08A8:  RCALL  03A6
08AA:  MOVFF  03,42
08AE:  MOVFF  02,41
08B2:  MOVFF  01,40
08B6:  MOVFF  00,3F
....................     CurrentTick = get_ticks();
08BA:  RCALL  03A6
08BC:  MOVFF  03,46
08C0:  MOVFF  02,45
08C4:  MOVFF  01,44
08C8:  MOVFF  00,43
....................     
....................    while (CurrentTick-FinishTick <= (FinishTick-StartTick)/2 ){
08CC:  MOVF   3F,W
08CE:  SUBWF  43,W
08D0:  MOVWF  60
08D2:  MOVF   40,W
08D4:  SUBWFB 44,W
08D6:  MOVWF  61
08D8:  MOVF   41,W
08DA:  SUBWFB 45,W
08DC:  MOVWF  62
08DE:  MOVF   42,W
08E0:  SUBWFB 46,W
08E2:  MOVWF  63
08E4:  MOVF   3B,W
08E6:  SUBWF  3F,W
08E8:  MOVWF  64
08EA:  MOVF   3C,W
08EC:  SUBWFB 40,W
08EE:  MOVWF  65
08F0:  MOVF   3D,W
08F2:  SUBWFB 41,W
08F4:  MOVWF  66
08F6:  MOVF   3E,W
08F8:  SUBWFB 42,W
08FA:  MOVWF  67
08FC:  BCF    FD8.0
08FE:  RRCF   67,W
0900:  MOVWF  03
0902:  RRCF   66,W
0904:  MOVWF  02
0906:  RRCF   65,W
0908:  MOVWF  01
090A:  RRCF   64,W
090C:  MOVWF  00
090E:  MOVF   63,W
0910:  SUBWF  03,W
0912:  BNC   0960
0914:  BNZ   092C
0916:  MOVF   62,W
0918:  SUBWF  02,W
091A:  BNC   0960
091C:  BNZ   092C
091E:  MOVF   61,W
0920:  SUBWF  01,W
0922:  BNC   0960
0924:  BNZ   092C
0926:  MOVF   60,W
0928:  SUBWF  00,W
092A:  BNC   0960
....................     CurrentTick=get_ticks();
092C:  RCALL  03A6
092E:  MOVFF  03,46
0932:  MOVFF  02,45
0936:  MOVFF  01,44
093A:  MOVFF  00,43
....................     
....................      if(input (button1) == 1 | input (button3) == 1){
093E:  BSF    F95.1
0940:  MOVLW  00
0942:  BTFSC  F83.1
0944:  MOVLW  01
0946:  MOVWF  61
0948:  BSF    F94.3
094A:  MOVLW  00
094C:  BTFSC  F82.3
094E:  MOVLW  01
0950:  IORWF  61,W
0952:  BZ    0958
....................       stop();
0954:  RCALL  073A
....................       return;
0956:  BRA    0976
....................       }
....................       
....................     reverse(delay);
0958:  MOVFF  5F,64
095C:  RCALL  0752
095E:  BRA    08CC
....................    }
....................    
.................... 
....................    stop();
0960:  RCALL  073A
....................    lcd_gotoxy(1,4);
0962:  MOVLW  01
0964:  MOVWF  67
0966:  MOVLW  04
0968:  MOVWF  68
096A:  RCALL  03E4
....................    lcd_putc("                       ");
096C:  MOVLW  B8
096E:  MOVWF  FF6
0970:  MOVLW  01
0972:  MOVWF  FF7
0974:  RCALL  046C
....................    return;
0976:  GOTO   179A (RETURN)
....................    
....................    
.................... }
.................... 
.................... void gogo(){
097A:  MOVLW  01
097C:  MOVWF  5F
.................... 
.................... char start=True;
.................... 
.................... output_toggle (PIN_D4);
097E:  BCF    F95.4
0980:  BTG    F8C.4
.................... 
.................... while(1){
.................... 
....................     while (1){
....................     
....................        while(start==True){
0982:  DECFSZ 5F,W
0984:  BRA    09EC
....................        c=abs(delay_s-(10-accel));
0986:  MOVLW  0A
0988:  BSF    FD8.0
098A:  SUBFWB 25,W
098C:  SUBWF  24,W
098E:  MOVWF  27
....................          for(int i=0;i<10-accel;i++){
0990:  CLRF   60
0992:  MOVLW  0A
0994:  BSF    FD8.0
0996:  SUBFWB 25,W
0998:  SUBWF  60,W
099A:  BC    09E8
....................             for(int j=0;j<accel_value;j++){
099C:  CLRF   61
099E:  MOVF   26,W
09A0:  SUBWF  61,W
09A2:  BC    09E0
....................             
....................                if(input (button1) == 1 | input (button3) == 1 | input (button4) == 1){
09A4:  BSF    F95.1
09A6:  MOVLW  00
09A8:  BTFSC  F83.1
09AA:  MOVLW  01
09AC:  MOVWF  65
09AE:  BSF    F94.3
09B0:  MOVLW  00
09B2:  BTFSC  F82.3
09B4:  MOVLW  01
09B6:  IORWF  65,F
09B8:  BSF    F94.2
09BA:  MOVLW  00
09BC:  BTFSC  F82.2
09BE:  MOVLW  01
09C0:  IORWF  65,W
09C2:  BZ    09C8
....................                   stop();
09C4:  RCALL  073A
....................                   return;
09C6:  BRA    0AC4
....................                   }
....................                   
....................                  if (check_left_proxy()){
09C8:  RCALL  0804
09CA:  MOVF   01,F
09CC:  BZ    09D6
....................                  start=True;
09CE:  MOVLW  01
09D0:  MOVWF  5F
....................                   stop();
09D2:  RCALL  073A
....................                   break;
09D4:  BRA    09E0
....................                  }
....................                      
....................                reverse(c);
09D6:  MOVFF  27,64
09DA:  RCALL  0752
09DC:  INCF   61,F
09DE:  BRA    099E
....................                }
....................             c=c+1;  
09E0:  MOVLW  01
09E2:  ADDWF  27,F
09E4:  INCF   60,F
09E6:  BRA    0992
....................             }
....................             start=False;
09E8:  CLRF   5F
09EA:  BRA    0982
....................          }
....................          
....................          
....................        if (check_left_proxy()){
09EC:  RCALL  0804
09EE:  MOVF   01,F
09F0:  BZ    0A00
....................          stop();
09F2:  RCALL  073A
....................          output_toggle (PIN_D4);
09F4:  BCF    F95.4
09F6:  BTG    F8C.4
....................          start=True;
09F8:  MOVLW  01
09FA:  MOVWF  5F
....................          correct = False;     
09FC:  CLRF   35
....................          break;
09FE:  BRA    0A2C
....................        }
....................        
....................        if (input (button5) == 1 | input (button1) == 1 | input (button3) == 1)
0A00:  BSF    F94.1
0A02:  MOVLW  00
0A04:  BTFSC  F82.1
0A06:  MOVLW  01
0A08:  MOVWF  65
0A0A:  BSF    F95.1
0A0C:  MOVLW  00
0A0E:  BTFSC  F83.1
0A10:  MOVLW  01
0A12:  IORWF  65,F
0A14:  BSF    F94.3
0A16:  MOVLW  00
0A18:  BTFSC  F82.3
0A1A:  MOVLW  01
0A1C:  IORWF  65,W
0A1E:  BZ    0A24
....................       {   
....................          stop();
0A20:  RCALL  073A
....................          return;
0A22:  BRA    0AC4
....................       }
....................       
....................          reverse(delay_s);
0A24:  MOVFF  24,64
0A28:  RCALL  0752
0A2A:  BRA    0982
....................       }
....................       
....................       
....................       while (1){
....................       
....................       while(start==True){
0A2C:  DECFSZ 5F,W
0A2E:  BRA    0A86
....................        c=abs(delay_s-(10-accel));
0A30:  MOVLW  0A
0A32:  BSF    FD8.0
0A34:  SUBFWB 25,W
0A36:  SUBWF  24,W
0A38:  MOVWF  27
....................          for(int i=0;i<10-accel;i++){
0A3A:  CLRF   62
0A3C:  MOVLW  0A
0A3E:  BSF    FD8.0
0A40:  SUBFWB 25,W
0A42:  SUBWF  62,W
0A44:  BC    0A82
....................          
....................               
....................             for(int j=0;j<accel_value;j++){
0A46:  CLRF   63
0A48:  MOVF   26,W
0A4A:  SUBWF  63,W
0A4C:  BC    0A7A
....................             
....................                if(input (button1) == 1){
0A4E:  BSF    F95.1
0A50:  BTFSS  F83.1
0A52:  BRA    0A58
....................                   stop();
0A54:  RCALL  073A
....................                   return;
0A56:  BRA    0AC4
....................                   }
....................                   
....................                 if(input (button3) == 1){
0A58:  BSF    F94.3
0A5A:  BTFSS  F82.3
0A5C:  BRA    0A62
....................                 stop();
0A5E:  RCALL  073A
....................                 return;
0A60:  BRA    0AC4
....................                   }
....................                   
....................                  if (check_right_proxy()){
0A62:  RCALL  0726
0A64:  MOVF   01,F
0A66:  BZ    0A70
....................                  start=True;
0A68:  MOVLW  01
0A6A:  MOVWF  5F
....................                   stop();
0A6C:  RCALL  073A
....................                   break;
0A6E:  BRA    0A7A
....................                  }
....................                      
....................                normal(c);
0A70:  MOVFF  27,64
0A74:  RCALL  0674
0A76:  INCF   63,F
0A78:  BRA    0A48
....................                }
....................             c=c+1;  
0A7A:  MOVLW  01
0A7C:  ADDWF  27,F
0A7E:  INCF   62,F
0A80:  BRA    0A3C
....................             }
....................             start=False;
0A82:  CLRF   5F
0A84:  BRA    0A2C
....................          }
....................          
....................       if (check_right_proxy()){
0A86:  RCALL  0726
0A88:  MOVF   01,F
0A8A:  BZ    0A96
....................          stop();
0A8C:  RCALL  073A
....................          start=True;
0A8E:  MOVLW  01
0A90:  MOVWF  5F
....................          correct = False;
0A92:  CLRF   35
....................          break;
0A94:  BRA    0AC2
....................       }
....................       
....................        if (input (button5) == 1 | input (button1) == 1 | input (button3) == 1)
0A96:  BSF    F94.1
0A98:  MOVLW  00
0A9A:  BTFSC  F82.1
0A9C:  MOVLW  01
0A9E:  MOVWF  65
0AA0:  BSF    F95.1
0AA2:  MOVLW  00
0AA4:  BTFSC  F83.1
0AA6:  MOVLW  01
0AA8:  IORWF  65,F
0AAA:  BSF    F94.3
0AAC:  MOVLW  00
0AAE:  BTFSC  F82.3
0AB0:  MOVLW  01
0AB2:  IORWF  65,W
0AB4:  BZ    0ABA
....................       {
....................          stop();
0AB6:  RCALL  073A
....................          return;
0AB8:  BRA    0AC4
....................       }
....................       
....................       normal(delay_s);
0ABA:  MOVFF  24,64
0ABE:  RCALL  0674
0AC0:  BRA    0A2C
....................       
....................       
....................      }
0AC2:  BRA    0982
....................      
.................... }
0AC4:  GOTO   17B4 (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////
.................... 
.................... const int8 lcd_custom_chars[] =
.................... {
.................... // Char Number 0 -- ONE
....................   0x00,
....................   0x00,
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x00,
....................   
....................  // Char Number 1 -- TWO
....................   0x00,
....................   0x00,
....................   0x14,
....................   0x14,
....................   0x14,
....................   0x14,
....................   0x14,
....................   0x00,
....................   
....................   // Char Number 2 -- THREE
....................   0x00,
....................   0x00,
....................   0x15,
....................   0x15,
....................   0x15,
....................   0x15,
....................   0x15,
....................   0x00,
.................... 
.................... // Char Number 3 -- BLANK
....................   0x00,
....................   0x00,
....................   0x00,
....................   0x00,
....................   0x00,
....................   0x00,
....................   0x00,
....................   0x00,
....................   
....................   // Char Number 4 -- M1
....................   0x01,
....................   0x01,
....................   0x01,
....................   0x01,
....................   0x01,
....................   0x01,
....................   0x01,
....................   0x01,
....................   
....................    // Char Number 5 -- M2
....................   0x1F,
....................   0x05,
....................   0x0A,
....................   0x0A,
....................   0x0E,
....................   0x0E,
....................   0x0E,
....................   0x1F,
....................   
....................    // Char Number 6 -- M3
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x10,
....................   0x10
.................... };
.................... void lcd_load_custom_chars()
.................... {
.................... int8 i;
.................... 
.................... // Set address counter pointing to CGRAM address 0.
.................... lcd_send_byte(0, 0x40); 
*
0374:  CLRF   6B
0376:  MOVLW  40
0378:  MOVWF  6C
037A:  RCALL  02E0
.................... 
.................... // Load custom lcd character data into CGRAM.
.................... // It can only hold a maximum of 8 custom characters.
.................... for(i = 0; i < sizeof(lcd_custom_chars); i++)
037C:  CLRF   5F
037E:  MOVF   5F,W
0380:  SUBLW  37
0382:  BNC   039A
....................    {
....................     lcd_send_byte(1, lcd_custom_chars[i]);
0384:  CLRF   03
0386:  MOVF   5F,W
0388:  RCALL  00C2
038A:  MOVWF  60
038C:  MOVLW  01
038E:  MOVWF  6B
0390:  MOVFF  60,6C
0394:  RCALL  02E0
0396:  INCF   5F,F
0398:  BRA    037E
....................    }
.................... 
.................... // Set address counter pointing back to the DDRAM.
.................... lcd_send_byte(0, 0x80);
039A:  CLRF   6B
039C:  MOVLW  80
039E:  MOVWF  6C
03A0:  RCALL  02E0
03A2:  GOTO   0B58 (RETURN)
.................... }
.................... 
.................... void main()
*
0AC8:  CLRF   FF8
0ACA:  BCF    FD0.7
0ACC:  BSF    07.7
0ACE:  MOVLW  70
0AD0:  MOVWF  FD3
0AD2:  CLRF   F9B
0AD4:  MOVF   FD3,W
0AD6:  CLRF   1C
0AD8:  CLRF   1B
0ADA:  CLRF   1A
0ADC:  CLRF   19
0ADE:  BCF    FD5.7
0AE0:  MOVLW  86
0AE2:  MOVWF  FD5
0AE4:  CLRF   FD7
0AE6:  CLRF   FD6
0AE8:  BCF    FF2.2
0AEA:  BCF    FB8.3
0AEC:  MOVLW  0C
0AEE:  MOVWF  FAF
0AF0:  MOVLW  A2
0AF2:  MOVWF  FAC
0AF4:  MOVLW  90
0AF6:  MOVWF  FAB
0AF8:  NOP   
0AFA:  NOP   
0AFC:  MOVLW  05
0AFE:  MOVWF  24
0B00:  MOVLW  06
0B02:  MOVWF  25
0B04:  MOVLW  1E
0B06:  MOVWF  26
0B08:  CLRF   27
0B0A:  CLRF   28
0B0C:  MOVLW  01
0B0E:  MOVWF  29
0B10:  MOVLW  01
0B12:  MOVWF  2A
0B14:  CLRF   34
0B16:  CLRF   35
0B18:  CLRF   36
0B1A:  CLRF   37
0B1C:  CLRF   38
0B1E:  CLRF   3A
0B20:  CLRF   39
0B22:  CLRF   48
0B24:  CLRF   47
0B26:  MOVF   FC1,W
0B28:  ANDLW  C0
0B2A:  IORLW  0F
0B2C:  MOVWF  FC1
0B2E:  MOVLW  07
0B30:  MOVWF  FB4
0B32:  CLRF   1D
0B34:  CLRF   1E
.................... {
....................    setup_adc_ports (AN0, VSS_VDD);
0B36:  MOVF   FC1,W
0B38:  ANDLW  C0
0B3A:  IORLW  0E
0B3C:  MOVWF  FC1
....................    setup_adc (ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0);
0B3E:  MOVF   FC0,W
0B40:  ANDLW  C0
0B42:  IORLW  07
0B44:  MOVWF  FC0
0B46:  BSF    FC0.7
0B48:  BSF    FC2.0
....................    
....................    setup_CCP1 (CCP_OFF);
0B4A:  MOVLW  F0
0B4C:  ANDWF  FBD,F
....................    enable_interrupts (GLOBAL);
0B4E:  MOVLW  C0
0B50:  IORWF  FF2,F
....................    
....................    lcd_init();
0B52:  GOTO   0322
.................... 
....................    lcd_load_custom_chars(); 
0B56:  BRA    0374
.................... 
....................   
....................    
....................    FinishTick = StartTick = CurrentTick = get_ticks(); //timers for centering
0B58:  RCALL  03A6
0B5A:  MOVFF  03,46
0B5E:  MOVFF  02,45
0B62:  MOVFF  01,44
0B66:  MOVFF  00,43
0B6A:  MOVFF  46,3E
0B6E:  MOVFF  45,3D
0B72:  MOVFF  44,3C
0B76:  MOVFF  43,3B
0B7A:  MOVFF  3E,42
0B7E:  MOVFF  3D,41
0B82:  MOVFF  3C,40
0B86:  MOVFF  3B,3F
....................    
....................    while (TRUE)
....................    {
....................       enable_interrupts (int_rda);
0B8A:  BSF    F9D.5
....................       output_toggle (PIN_D4);
0B8C:  BCF    F95.4
0B8E:  BTG    F8C.4
....................        
....................       lcd_gotoxy(1,1);
0B90:  MOVLW  01
0B92:  MOVWF  67
0B94:  MOVWF  68
0B96:  RCALL  03E4
....................       
....................       lcd_gotoxy(1,1);
0B98:  MOVLW  01
0B9A:  MOVWF  67
0B9C:  MOVWF  68
0B9E:  RCALL  03E4
....................       lcd_putc("Speed: %");
0BA0:  MOVLW  D0
0BA2:  MOVWF  FF6
0BA4:  MOVLW  01
0BA6:  MOVWF  FF7
0BA8:  RCALL  046C
....................       printf(lcd_putc,"%d",delay_s*10);
0BAA:  MOVF   24,W
0BAC:  MULLW  0A
0BAE:  MOVFF  FF3,60
0BB2:  MOVLW  18
0BB4:  MOVWF  61
0BB6:  RCALL  04B4
....................       
....................       lcd_gotoxy(13,1);
0BB8:  MOVLW  0D
0BBA:  MOVWF  67
0BBC:  MOVLW  01
0BBE:  MOVWF  68
0BC0:  RCALL  03E4
....................       if (mode_manuel==True){
0BC2:  DECFSZ 29,W
0BC4:  BRA    0BD0
....................       lcd_putc("<Manuel>");
0BC6:  MOVLW  DA
0BC8:  MOVWF  FF6
0BCA:  MOVLW  01
0BCC:  MOVWF  FF7
0BCE:  RCALL  046C
....................       }
....................       
....................       if (mode_auto==True){
0BD0:  DECFSZ 28,W
0BD2:  BRA    0BDE
....................       lcd_putc("< Auto >");
0BD4:  MOVLW  E4
0BD6:  MOVWF  FF6
0BD8:  MOVLW  01
0BDA:  MOVWF  FF7
0BDC:  RCALL  046C
....................       }
....................       
....................       lcd_gotoxy(1,2);
0BDE:  MOVLW  01
0BE0:  MOVWF  67
0BE2:  MOVLW  02
0BE4:  MOVWF  68
0BE6:  CALL   03E4
....................       lcd_putc("Accel: %");
0BEA:  MOVLW  EE
0BEC:  MOVWF  FF6
0BEE:  MOVLW  01
0BF0:  MOVWF  FF7
0BF2:  RCALL  046C
....................       printf(lcd_putc,"%d",accel*10);
0BF4:  MOVF   25,W
0BF6:  MULLW  0A
0BF8:  MOVFF  FF3,60
0BFC:  MOVLW  18
0BFE:  MOVWF  61
0C00:  RCALL  04B4
....................      
....................       
.................... ///////////////////>>>>>> MODE CHANGE  <<<<<//////////////////////
.................... 
....................       if (input (button5) == 1)
0C02:  BSF    F94.1
0C04:  BTFSS  F82.1
0C06:  BRA    1094
....................       {
....................          while(input (button5) == 1);
0C08:  BSF    F94.1
0C0A:  BTFSC  F82.1
0C0C:  BRA    0C08
....................          int mode_cursor=1;
....................          char mod_flag=False;
0C0E:  MOVLW  01
0C10:  MOVWF  49
0C12:  CLRF   4A
....................          
....................          StartTick=get_ticks();
0C14:  CALL   03A6
0C18:  MOVFF  03,3E
0C1C:  MOVFF  02,3D
0C20:  MOVFF  01,3C
0C24:  MOVFF  00,3B
....................          delay_ms(500);
0C28:  MOVLW  02
0C2A:  MOVWF  5F
0C2C:  MOVLW  FA
0C2E:  MOVWF  67
0C30:  CALL   0222
0C34:  DECFSZ 5F,F
0C36:  BRA    0C2C
....................          while(1){
....................          
....................           if(mode_cursor==1){ //SET SPEED
0C38:  DECFSZ 49,W
0C3A:  BRA    0DE6
....................             
....................             CurrentTick=get_ticks();
0C3C:  CALL   03A6
0C40:  MOVFF  03,46
0C44:  MOVFF  02,45
0C48:  MOVFF  01,44
0C4C:  MOVFF  00,43
....................             
....................             if(CurrentTick-StartTick>2500 & mod_flag==True){
0C50:  MOVF   3B,W
0C52:  SUBWF  43,W
0C54:  MOVWF  5F
0C56:  MOVF   3C,W
0C58:  SUBWFB 44,W
0C5A:  MOVWF  60
0C5C:  MOVF   3D,W
0C5E:  SUBWFB 45,W
0C60:  MOVWF  61
0C62:  MOVF   3E,W
0C64:  SUBWFB 46,W
0C66:  MOVWF  62
0C68:  MOVF   62,F
0C6A:  BNZ   0C84
0C6C:  MOVF   61,F
0C6E:  BNZ   0C84
0C70:  MOVF   60,W
0C72:  SUBLW  08
0C74:  BC    0C80
0C76:  XORLW  FF
0C78:  BNZ   0C84
0C7A:  MOVF   5F,W
0C7C:  SUBLW  C4
0C7E:  BNC   0C84
0C80:  MOVLW  00
0C82:  BRA    0C86
0C84:  MOVLW  01
0C86:  MOVWF  5F
0C88:  DECFSZ 4A,W
0C8A:  BRA    0C8E
0C8C:  BRA    0C92
0C8E:  MOVLW  00
0C90:  BRA    0C94
0C92:  MOVLW  01
0C94:  ANDWF  5F,W
0C96:  BZ    0CD2
....................             
....................             lcd_gotoxy(8,mode_cursor);
0C98:  MOVLW  08
0C9A:  MOVWF  67
0C9C:  MOVFF  49,68
0CA0:  CALL   03E4
....................             lcd_putc("%");
0CA4:  MOVLW  F8
0CA6:  MOVWF  FF6
0CA8:  MOVLW  01
0CAA:  MOVWF  FF7
0CAC:  CALL   046C
....................             printf(lcd_putc,"%d",delay_s*10);
0CB0:  MOVF   24,W
0CB2:  MULLW  0A
0CB4:  MOVFF  FF3,60
0CB8:  MOVLW  18
0CBA:  MOVWF  61
0CBC:  CALL   04B4
....................             
....................             mod_flag=False;
0CC0:  CLRF   4A
....................             StartTick=CurrentTick;
0CC2:  MOVFF  46,3E
0CC6:  MOVFF  45,3D
0CCA:  MOVFF  44,3C
0CCE:  MOVFF  43,3B
....................             }
....................             
....................             if(CurrentTick-StartTick>2500 & mod_flag==False){
0CD2:  MOVF   3B,W
0CD4:  SUBWF  43,W
0CD6:  MOVWF  5F
0CD8:  MOVF   3C,W
0CDA:  SUBWFB 44,W
0CDC:  MOVWF  60
0CDE:  MOVF   3D,W
0CE0:  SUBWFB 45,W
0CE2:  MOVWF  61
0CE4:  MOVF   3E,W
0CE6:  SUBWFB 46,W
0CE8:  MOVWF  62
0CEA:  MOVF   62,F
0CEC:  BNZ   0D06
0CEE:  MOVF   61,F
0CF0:  BNZ   0D06
0CF2:  MOVF   60,W
0CF4:  SUBLW  08
0CF6:  BC    0D02
0CF8:  XORLW  FF
0CFA:  BNZ   0D06
0CFC:  MOVF   5F,W
0CFE:  SUBLW  C4
0D00:  BNC   0D06
0D02:  MOVLW  00
0D04:  BRA    0D08
0D06:  MOVLW  01
0D08:  MOVWF  5F
0D0A:  MOVF   4A,F
0D0C:  BZ    0D12
0D0E:  MOVLW  00
0D10:  BRA    0D14
0D12:  MOVLW  01
0D14:  ANDWF  5F,W
0D16:  BZ    0D44
....................             
....................             lcd_gotoxy(8,mode_cursor);
0D18:  MOVLW  08
0D1A:  MOVWF  67
0D1C:  MOVFF  49,68
0D20:  CALL   03E4
....................             lcd_putc("    ");
0D24:  MOVLW  FA
0D26:  MOVWF  FF6
0D28:  MOVLW  01
0D2A:  MOVWF  FF7
0D2C:  CALL   046C
....................             
....................             mod_flag=True;
0D30:  MOVLW  01
0D32:  MOVWF  4A
....................             StartTick=CurrentTick;
0D34:  MOVFF  46,3E
0D38:  MOVFF  45,3D
0D3C:  MOVFF  44,3C
0D40:  MOVFF  43,3B
....................             }
....................             
....................             if(input(button1)==1){
0D44:  BSF    F95.1
0D46:  BTFSS  F83.1
0D48:  BRA    0D94
....................             delay_s--;
0D4A:  DECF   24,F
....................             
....................             if(delay_s<=0){
0D4C:  MOVF   24,F
0D4E:  BNZ   0D54
....................                delay_s=1;
0D50:  MOVLW  01
0D52:  MOVWF  24
....................             }
....................             
....................             lcd_gotoxy(8,mode_cursor);
0D54:  MOVLW  08
0D56:  MOVWF  67
0D58:  MOVFF  49,68
0D5C:  CALL   03E4
....................             lcd_putc("%");
0D60:  MOVLW  00
0D62:  MOVWF  FF6
0D64:  MOVLW  02
0D66:  MOVWF  FF7
0D68:  CALL   046C
....................             printf(lcd_putc,"%d ",delay_s*10);
0D6C:  MOVF   24,W
0D6E:  MULLW  0A
0D70:  MOVFF  FF3,60
0D74:  MOVLW  18
0D76:  MOVWF  61
0D78:  CALL   04B4
0D7C:  MOVLW  20
0D7E:  MOVWF  66
0D80:  CALL   0424
....................             
....................             delay_ms(500);
0D84:  MOVLW  02
0D86:  MOVWF  5F
0D88:  MOVLW  FA
0D8A:  MOVWF  67
0D8C:  CALL   0222
0D90:  DECFSZ 5F,F
0D92:  BRA    0D88
....................             
....................             }
....................             
....................             if(input(button3)==1){
0D94:  BSF    F94.3
0D96:  BTFSS  F82.3
0D98:  BRA    0DE6
....................             delay_s++;
0D9A:  INCF   24,F
....................             
....................             if(delay_s>=10){
0D9C:  MOVF   24,W
0D9E:  SUBLW  09
0DA0:  BC    0DA6
....................                delay_s=10;
0DA2:  MOVLW  0A
0DA4:  MOVWF  24
....................             }
....................             
....................             lcd_gotoxy(8,mode_cursor);
0DA6:  MOVLW  08
0DA8:  MOVWF  67
0DAA:  MOVFF  49,68
0DAE:  CALL   03E4
....................             lcd_putc("%");
0DB2:  MOVLW  02
0DB4:  MOVWF  FF6
0DB6:  MOVLW  02
0DB8:  MOVWF  FF7
0DBA:  CALL   046C
....................             printf(lcd_putc,"%d ",delay_s*10);
0DBE:  MOVF   24,W
0DC0:  MULLW  0A
0DC2:  MOVFF  FF3,60
0DC6:  MOVLW  18
0DC8:  MOVWF  61
0DCA:  CALL   04B4
0DCE:  MOVLW  20
0DD0:  MOVWF  66
0DD2:  CALL   0424
....................             
....................             delay_ms(500);
0DD6:  MOVLW  02
0DD8:  MOVWF  5F
0DDA:  MOVLW  FA
0DDC:  MOVWF  67
0DDE:  CALL   0222
0DE2:  DECFSZ 5F,F
0DE4:  BRA    0DDA
....................             
....................             }  
....................          }
....................  
....................  ////////////////////////
....................  
....................          if(mode_cursor==2){ // SET ACCEL
0DE6:  MOVF   49,W
0DE8:  SUBLW  02
0DEA:  BTFSS  FD8.2
0DEC:  BRA    0F98
....................             CurrentTick=get_ticks();
0DEE:  CALL   03A6
0DF2:  MOVFF  03,46
0DF6:  MOVFF  02,45
0DFA:  MOVFF  01,44
0DFE:  MOVFF  00,43
....................             
....................             if(CurrentTick-StartTick>2500 & mod_flag==True){
0E02:  MOVF   3B,W
0E04:  SUBWF  43,W
0E06:  MOVWF  5F
0E08:  MOVF   3C,W
0E0A:  SUBWFB 44,W
0E0C:  MOVWF  60
0E0E:  MOVF   3D,W
0E10:  SUBWFB 45,W
0E12:  MOVWF  61
0E14:  MOVF   3E,W
0E16:  SUBWFB 46,W
0E18:  MOVWF  62
0E1A:  MOVF   62,F
0E1C:  BNZ   0E36
0E1E:  MOVF   61,F
0E20:  BNZ   0E36
0E22:  MOVF   60,W
0E24:  SUBLW  08
0E26:  BC    0E32
0E28:  XORLW  FF
0E2A:  BNZ   0E36
0E2C:  MOVF   5F,W
0E2E:  SUBLW  C4
0E30:  BNC   0E36
0E32:  MOVLW  00
0E34:  BRA    0E38
0E36:  MOVLW  01
0E38:  MOVWF  5F
0E3A:  DECFSZ 4A,W
0E3C:  BRA    0E40
0E3E:  BRA    0E44
0E40:  MOVLW  00
0E42:  BRA    0E46
0E44:  MOVLW  01
0E46:  ANDWF  5F,W
0E48:  BZ    0E84
....................             
....................             lcd_gotoxy(8,mode_cursor);
0E4A:  MOVLW  08
0E4C:  MOVWF  67
0E4E:  MOVFF  49,68
0E52:  CALL   03E4
....................             lcd_putc("%");
0E56:  MOVLW  04
0E58:  MOVWF  FF6
0E5A:  MOVLW  02
0E5C:  MOVWF  FF7
0E5E:  CALL   046C
....................             printf(lcd_putc,"%d",accel*10);
0E62:  MOVF   25,W
0E64:  MULLW  0A
0E66:  MOVFF  FF3,60
0E6A:  MOVLW  18
0E6C:  MOVWF  61
0E6E:  CALL   04B4
....................             
....................             mod_flag=False;
0E72:  CLRF   4A
....................             StartTick=CurrentTick;
0E74:  MOVFF  46,3E
0E78:  MOVFF  45,3D
0E7C:  MOVFF  44,3C
0E80:  MOVFF  43,3B
....................             }
....................             
....................             if(CurrentTick-StartTick>2500 & mod_flag==False){
0E84:  MOVF   3B,W
0E86:  SUBWF  43,W
0E88:  MOVWF  5F
0E8A:  MOVF   3C,W
0E8C:  SUBWFB 44,W
0E8E:  MOVWF  60
0E90:  MOVF   3D,W
0E92:  SUBWFB 45,W
0E94:  MOVWF  61
0E96:  MOVF   3E,W
0E98:  SUBWFB 46,W
0E9A:  MOVWF  62
0E9C:  MOVF   62,F
0E9E:  BNZ   0EB8
0EA0:  MOVF   61,F
0EA2:  BNZ   0EB8
0EA4:  MOVF   60,W
0EA6:  SUBLW  08
0EA8:  BC    0EB4
0EAA:  XORLW  FF
0EAC:  BNZ   0EB8
0EAE:  MOVF   5F,W
0EB0:  SUBLW  C4
0EB2:  BNC   0EB8
0EB4:  MOVLW  00
0EB6:  BRA    0EBA
0EB8:  MOVLW  01
0EBA:  MOVWF  5F
0EBC:  MOVF   4A,F
0EBE:  BZ    0EC4
0EC0:  MOVLW  00
0EC2:  BRA    0EC6
0EC4:  MOVLW  01
0EC6:  ANDWF  5F,W
0EC8:  BZ    0EF6
....................             
....................             lcd_gotoxy(8,mode_cursor);
0ECA:  MOVLW  08
0ECC:  MOVWF  67
0ECE:  MOVFF  49,68
0ED2:  CALL   03E4
....................             lcd_putc("    ");
0ED6:  MOVLW  06
0ED8:  MOVWF  FF6
0EDA:  MOVLW  02
0EDC:  MOVWF  FF7
0EDE:  CALL   046C
....................             
....................             mod_flag=True;
0EE2:  MOVLW  01
0EE4:  MOVWF  4A
....................             StartTick=CurrentTick;
0EE6:  MOVFF  46,3E
0EEA:  MOVFF  45,3D
0EEE:  MOVFF  44,3C
0EF2:  MOVFF  43,3B
....................             }
....................             
....................               if(input(button1)==1){
0EF6:  BSF    F95.1
0EF8:  BTFSS  F83.1
0EFA:  BRA    0F46
....................                accel--;
0EFC:  DECF   25,F
....................                
....................                if(accel<=0){
0EFE:  MOVF   25,F
0F00:  BNZ   0F06
....................                   accel=1;
0F02:  MOVLW  01
0F04:  MOVWF  25
....................                }
....................                
....................                lcd_gotoxy(8,mode_cursor);
0F06:  MOVLW  08
0F08:  MOVWF  67
0F0A:  MOVFF  49,68
0F0E:  CALL   03E4
....................                lcd_putc("%");
0F12:  MOVLW  0C
0F14:  MOVWF  FF6
0F16:  MOVLW  02
0F18:  MOVWF  FF7
0F1A:  CALL   046C
....................                printf(lcd_putc,"%d ",accel*10);
0F1E:  MOVF   25,W
0F20:  MULLW  0A
0F22:  MOVFF  FF3,60
0F26:  MOVLW  18
0F28:  MOVWF  61
0F2A:  CALL   04B4
0F2E:  MOVLW  20
0F30:  MOVWF  66
0F32:  CALL   0424
....................                
....................                delay_ms(500);
0F36:  MOVLW  02
0F38:  MOVWF  5F
0F3A:  MOVLW  FA
0F3C:  MOVWF  67
0F3E:  CALL   0222
0F42:  DECFSZ 5F,F
0F44:  BRA    0F3A
....................                
....................                }
....................             
....................             if(input(button3)==1){
0F46:  BSF    F94.3
0F48:  BTFSS  F82.3
0F4A:  BRA    0F98
....................                accel++;
0F4C:  INCF   25,F
....................                
....................                if(accel>=11){
0F4E:  MOVF   25,W
0F50:  SUBLW  0A
0F52:  BC    0F58
....................                   accel=10;
0F54:  MOVLW  0A
0F56:  MOVWF  25
....................                }
....................                
....................                lcd_gotoxy(8,mode_cursor);
0F58:  MOVLW  08
0F5A:  MOVWF  67
0F5C:  MOVFF  49,68
0F60:  CALL   03E4
....................                lcd_putc("%");
0F64:  MOVLW  0E
0F66:  MOVWF  FF6
0F68:  MOVLW  02
0F6A:  MOVWF  FF7
0F6C:  CALL   046C
....................                printf(lcd_putc,"%d ",accel*10);
0F70:  MOVF   25,W
0F72:  MULLW  0A
0F74:  MOVFF  FF3,60
0F78:  MOVLW  18
0F7A:  MOVWF  61
0F7C:  CALL   04B4
0F80:  MOVLW  20
0F82:  MOVWF  66
0F84:  CALL   0424
....................             
....................                delay_ms(500);
0F88:  MOVLW  02
0F8A:  MOVWF  5F
0F8C:  MOVLW  FA
0F8E:  MOVWF  67
0F90:  CALL   0222
0F94:  DECFSZ 5F,F
0F96:  BRA    0F8C
....................             
....................             } 
....................          }
....................          
....................          ////////////////////////
....................          
....................          if(input(button4)==1){
0F98:  BSF    F94.2
0F9A:  BTFSS  F82.2
0F9C:  BRA    1008
....................          
....................          lcd_gotoxy(8,1);
0F9E:  MOVLW  08
0FA0:  MOVWF  67
0FA2:  MOVLW  01
0FA4:  MOVWF  68
0FA6:  CALL   03E4
....................          lcd_putc("%");
0FAA:  MOVLW  10
0FAC:  MOVWF  FF6
0FAE:  MOVLW  02
0FB0:  MOVWF  FF7
0FB2:  CALL   046C
....................          printf(lcd_putc,"%d",delay_s*10);
0FB6:  MOVF   24,W
0FB8:  MULLW  0A
0FBA:  MOVFF  FF3,60
0FBE:  MOVLW  18
0FC0:  MOVWF  61
0FC2:  CALL   04B4
....................          
....................          lcd_gotoxy(8,2);
0FC6:  MOVLW  08
0FC8:  MOVWF  67
0FCA:  MOVLW  02
0FCC:  MOVWF  68
0FCE:  CALL   03E4
....................          lcd_putc("%");
0FD2:  MOVLW  12
0FD4:  MOVWF  FF6
0FD6:  MOVLW  02
0FD8:  MOVWF  FF7
0FDA:  CALL   046C
....................          printf(lcd_putc,"%d",accel*10);
0FDE:  MOVF   25,W
0FE0:  MULLW  0A
0FE2:  MOVFF  FF3,60
0FE6:  MOVLW  18
0FE8:  MOVWF  61
0FEA:  CALL   04B4
....................          
....................          mode_cursor--;
0FEE:  DECF   49,F
....................          
....................          if (mode_cursor<=0){
0FF0:  MOVF   49,F
0FF2:  BNZ   0FF8
....................          mode_cursor=2;
0FF4:  MOVLW  02
0FF6:  MOVWF  49
....................          }
....................          delay_ms(500);
0FF8:  MOVLW  02
0FFA:  MOVWF  5F
0FFC:  MOVLW  FA
0FFE:  MOVWF  67
1000:  CALL   0222
1004:  DECFSZ 5F,F
1006:  BRA    0FFC
....................          }
....................          
....................          if(input(button2)==1){
1008:  BSF    F95.0
100A:  BTFSS  F83.0
100C:  BRA    107A
....................                 
....................          lcd_gotoxy(8,1);
100E:  MOVLW  08
1010:  MOVWF  67
1012:  MOVLW  01
1014:  MOVWF  68
1016:  CALL   03E4
....................          lcd_putc("%");
101A:  MOVLW  14
101C:  MOVWF  FF6
101E:  MOVLW  02
1020:  MOVWF  FF7
1022:  CALL   046C
....................          printf(lcd_putc,"%d",delay_s*10);
1026:  MOVF   24,W
1028:  MULLW  0A
102A:  MOVFF  FF3,60
102E:  MOVLW  18
1030:  MOVWF  61
1032:  CALL   04B4
....................          
....................          lcd_gotoxy(8,2);
1036:  MOVLW  08
1038:  MOVWF  67
103A:  MOVLW  02
103C:  MOVWF  68
103E:  CALL   03E4
....................          lcd_putc("%");
1042:  MOVLW  16
1044:  MOVWF  FF6
1046:  MOVLW  02
1048:  MOVWF  FF7
104A:  CALL   046C
....................          printf(lcd_putc,"%d",accel*10);
104E:  MOVF   25,W
1050:  MULLW  0A
1052:  MOVFF  FF3,60
1056:  MOVLW  18
1058:  MOVWF  61
105A:  CALL   04B4
....................                
....................           mode_cursor++;
105E:  INCF   49,F
....................           
....................          if (mode_cursor>=3){
1060:  MOVF   49,W
1062:  SUBLW  02
1064:  BC    106A
....................          mode_cursor=1;
1066:  MOVLW  01
1068:  MOVWF  49
....................          }
....................          delay_ms(500);
106A:  MOVLW  02
106C:  MOVWF  5F
106E:  MOVLW  FA
1070:  MOVWF  67
1072:  CALL   0222
1076:  DECFSZ 5F,F
1078:  BRA    106E
....................          }  
....................          
....................          if (input (button5) == 1){
107A:  BSF    F94.1
107C:  BTFSS  F82.1
107E:  BRA    1092
....................           delay_ms(500);
1080:  MOVLW  02
1082:  MOVWF  5F
1084:  MOVLW  FA
1086:  MOVWF  67
1088:  CALL   0222
108C:  DECFSZ 5F,F
108E:  BRA    1084
....................          break;
1090:  BRA    1094
....................          }
1092:  BRA    0C38
....................          
....................       }   
....................       }
....................       
.................... 
.................... ////////////////>>>>>>>>> SERIAL COMM <<<<<<<<///////////   
....................       if (correct == True){ // full data received
1094:  DECFSZ 35,W
1096:  BRA    127C
....................          read_serial_speed();
1098:  CALL   0596
....................         
....................          if (str[0] == 'r'){
109C:  MOVF   2C,W
109E:  SUBLW  72
10A0:  BTFSS  FD8.2
10A2:  BRA    118C
....................             if (str[1] == '0'){ //r0
10A4:  MOVF   2D,W
10A6:  SUBLW  30
10A8:  BNZ   10FA
....................             
....................                output_toggle (PIN_D4);
10AA:  BCF    F95.4
10AC:  BTG    F8C.4
....................  
....................                for (int i=0; i<50;i++ )
10AE:  CLRF   4B
10B0:  MOVF   4B,W
10B2:  SUBLW  31
10B4:  BNC   10F0
....................                {
....................                   enable_interrupts (int_rda);
10B6:  BSF    F9D.5
....................                   normal (read_serial_speed ());
10B8:  CALL   0596
10BC:  MOVFF  03,62
10C0:  MOVFF  02,61
10C4:  MOVFF  01,60
10C8:  MOVFF  00,5F
10CC:  CALL   0602
10D0:  MOVFF  01,5F
10D4:  MOVFF  01,64
10D8:  CALL   0674
....................                   
....................                   if (check_right_proxy()){
10DC:  CALL   0726
10E0:  MOVF   01,F
10E2:  BZ    10EC
....................                      stop();
10E4:  CALL   073A
....................                      correct = False;
10E8:  CLRF   35
....................                      break;
10EA:  BRA    10F0
....................                   }
10EC:  INCF   4B,F
10EE:  BRA    10B0
....................                  
....................                }
....................                output_toggle (PIN_D4);
10F0:  BCF    F95.4
10F2:  BTG    F8C.4
....................                stop();
10F4:  CALL   073A
....................                correct = False;
10F8:  CLRF   35
....................             }
....................          
.................... 
....................             if (str[1] == '1'){ //r1
10FA:  MOVF   2D,W
10FC:  SUBLW  31
10FE:  BNZ   118C
....................                output_toggle (PIN_D4);
1100:  BCF    F95.4
1102:  BTG    F8C.4
....................  
....................                while ((str[0] == 'r' & str[1] == '1') | str[0] == 's' )
1104:  MOVF   2C,W
1106:  SUBLW  72
1108:  BZ    110E
110A:  MOVLW  00
110C:  BRA    1110
110E:  MOVLW  01
1110:  MOVWF  5F
1112:  MOVF   2D,W
1114:  SUBLW  31
1116:  BZ    111C
1118:  MOVLW  00
111A:  BRA    111E
111C:  MOVLW  01
111E:  ANDWF  5F,F
1120:  MOVF   2C,W
1122:  SUBLW  73
1124:  BZ    112A
1126:  MOVLW  00
1128:  BRA    112C
112A:  MOVLW  01
112C:  IORWF  5F,W
112E:  BZ    118C
....................                {
....................                   enable_interrupts (int_rda);
1130:  BSF    F9D.5
....................                   normal (read_serial_speed () );
1132:  CALL   0596
1136:  MOVFF  03,62
113A:  MOVFF  02,61
113E:  MOVFF  01,60
1142:  MOVFF  00,5F
1146:  CALL   0602
114A:  MOVFF  01,5F
114E:  MOVFF  01,64
1152:  CALL   0674
....................                   
....................                   if (check_right_proxy()){
1156:  CALL   0726
115A:  MOVF   01,F
115C:  BZ    1166
....................                      stop();
115E:  CALL   073A
....................                      correct = False;
1162:  CLRF   35
....................                      break;
1164:  BRA    118C
....................                   }
....................                   
....................                   if(str[0]!='s' & kbhit()){
1166:  MOVF   2C,W
1168:  SUBLW  73
116A:  BNZ   1170
116C:  MOVLW  00
116E:  BRA    1172
1170:  MOVLW  01
1172:  MOVWF  5F
1174:  MOVLW  00
1176:  BTFSC  F9E.5
1178:  MOVLW  01
117A:  ANDWF  5F,W
117C:  BZ    118A
....................                      output_toggle (PIN_D4);
117E:  BCF    F95.4
1180:  BTG    F8C.4
....................                      stop();
1182:  CALL   073A
....................                      correct = False;
1186:  CLRF   35
....................                      break;
1188:  BRA    118C
....................                   }           
118A:  BRA    1104
....................                }  
....................             }
....................          }
.................... ///////////// ///////// ///////////////
.................... 
....................          if (str[0] == 'l'){
118C:  MOVF   2C,W
118E:  SUBLW  6C
1190:  BTFSS  FD8.2
1192:  BRA    127C
....................             if (str[1] == '0'){ //l0
1194:  MOVF   2D,W
1196:  SUBLW  30
1198:  BNZ   11EA
....................                output_toggle (PIN_D4);
119A:  BCF    F95.4
119C:  BTG    F8C.4
....................  
....................                for (int i=0; i<50;i++ )
119E:  CLRF   4C
11A0:  MOVF   4C,W
11A2:  SUBLW  31
11A4:  BNC   11E0
....................                {
....................                   enable_interrupts (int_rda);
11A6:  BSF    F9D.5
....................                   reverse (read_serial_speed () );
11A8:  CALL   0596
11AC:  MOVFF  03,62
11B0:  MOVFF  02,61
11B4:  MOVFF  01,60
11B8:  MOVFF  00,5F
11BC:  CALL   0602
11C0:  MOVFF  01,5F
11C4:  MOVFF  01,64
11C8:  CALL   0752
....................                   
....................                   if (check_left_proxy()){
11CC:  CALL   0804
11D0:  MOVF   01,F
11D2:  BZ    11DC
....................                      stop();
11D4:  CALL   073A
....................                      correct = False;
11D8:  CLRF   35
....................                      break;
11DA:  BRA    11E0
....................                   }
11DC:  INCF   4C,F
11DE:  BRA    11A0
....................                  
....................                }
....................                output_toggle (PIN_D4);
11E0:  BCF    F95.4
11E2:  BTG    F8C.4
....................                stop();
11E4:  CALL   073A
....................                correct = False;
11E8:  CLRF   35
....................             }
....................          
....................             if (str[1] == '1'){ //l1
11EA:  MOVF   2D,W
11EC:  SUBLW  31
11EE:  BNZ   127C
....................                output_toggle (PIN_D4);
11F0:  BCF    F95.4
11F2:  BTG    F8C.4
....................  
....................                while ((str[0] == 'l' & str[1] == '1') | str[0] == 's' )
11F4:  MOVF   2C,W
11F6:  SUBLW  6C
11F8:  BZ    11FE
11FA:  MOVLW  00
11FC:  BRA    1200
11FE:  MOVLW  01
1200:  MOVWF  5F
1202:  MOVF   2D,W
1204:  SUBLW  31
1206:  BZ    120C
1208:  MOVLW  00
120A:  BRA    120E
120C:  MOVLW  01
120E:  ANDWF  5F,F
1210:  MOVF   2C,W
1212:  SUBLW  73
1214:  BZ    121A
1216:  MOVLW  00
1218:  BRA    121C
121A:  MOVLW  01
121C:  IORWF  5F,W
121E:  BZ    127C
....................                {
....................                   enable_interrupts (int_rda);
1220:  BSF    F9D.5
....................                   reverse (read_serial_speed () );
1222:  CALL   0596
1226:  MOVFF  03,62
122A:  MOVFF  02,61
122E:  MOVFF  01,60
1232:  MOVFF  00,5F
1236:  CALL   0602
123A:  MOVFF  01,5F
123E:  MOVFF  01,64
1242:  CALL   0752
....................                   
....................                   if (check_left_proxy()){
1246:  CALL   0804
124A:  MOVF   01,F
124C:  BZ    1256
....................                      correct = False;
124E:  CLRF   35
....................                      stop();
1250:  CALL   073A
....................                      break;
1254:  BRA    127C
....................                   }
....................                   
....................                   if(str[0]!='s' & kbhit()){
1256:  MOVF   2C,W
1258:  SUBLW  73
125A:  BNZ   1260
125C:  MOVLW  00
125E:  BRA    1262
1260:  MOVLW  01
1262:  MOVWF  5F
1264:  MOVLW  00
1266:  BTFSC  F9E.5
1268:  MOVLW  01
126A:  ANDWF  5F,W
126C:  BZ    127A
....................                      output_toggle (PIN_D4);
126E:  BCF    F95.4
1270:  BTG    F8C.4
....................                      stop();
1272:  CALL   073A
....................                      correct = False;
1276:  CLRF   35
....................                      break;
1278:  BRA    127C
....................                   }           
127A:  BRA    11F4
....................                }  
....................             }
....................             
....................          }
....................      }     
....................          
.................... 
.................... ///////////>>>>>>> SELECT MANUEL or AUTO <<<<<<<<<///////
....................       while (input (button0)== 1)  //select auto
127C:  BSF    F95.5
127E:  BTFSS  F83.5
1280:  BRA    138A
....................       {  
....................          char start=True;
....................          char q=False;
1282:  MOVLW  01
1284:  MOVWF  4D
1286:  CLRF   4E
....................          delay_ms (500);
1288:  MOVLW  02
128A:  MOVWF  5F
128C:  MOVLW  FA
128E:  MOVWF  67
1290:  CALL   0222
1294:  DECFSZ 5F,F
1296:  BRA    128C
....................          
....................          if (flag == True)
1298:  DECFSZ 2A,W
129A:  BRA    137A
....................          {
....................             flag = False;
129C:  CLRF   2A
....................             mode_AUTO = True;
129E:  MOVLW  01
12A0:  MOVWF  28
....................             mode_manuel = False;
12A2:  CLRF   29
....................             
....................             lcd_gotoxy(13,1);
12A4:  MOVLW  0D
12A6:  MOVWF  67
12A8:  MOVLW  01
12AA:  MOVWF  68
12AC:  CALL   03E4
....................             lcd_putc("< Auto >");
12B0:  MOVLW  18
12B2:  MOVWF  FF6
12B4:  MOVLW  02
12B6:  MOVWF  FF7
12B8:  CALL   046C
....................             
....................             while (1) //start with normal() in auto
....................             {  
....................                
....................                while (start==True){
12BC:  DECFSZ 4D,W
12BE:  BRA    132E
....................                c=abs(delay_s-(10-accel));
12C0:  MOVLW  0A
12C2:  BSF    FD8.0
12C4:  SUBFWB 25,W
12C6:  SUBWF  24,W
12C8:  MOVWF  27
....................                for(int i=0;i<10-accel;i++){
12CA:  CLRF   4F
12CC:  MOVLW  0A
12CE:  BSF    FD8.0
12D0:  SUBFWB 25,W
12D2:  SUBWF  4F,W
12D4:  BC    132A
....................                
....................                    if (q==True){
12D6:  DECFSZ 4E,W
12D8:  BRA    12DC
....................                      break;
12DA:  BRA    132A
....................                      }
....................                     
....................                   for(int j=0;j<accel_value;j++){
12DC:  CLRF   50
12DE:  MOVF   26,W
12E0:  SUBWF  50,W
12E2:  BC    1322
....................                   
....................                      if(input (button1) == 1 | input (button3) == 1){
12E4:  BSF    F95.1
12E6:  MOVLW  00
12E8:  BTFSC  F83.1
12EA:  MOVLW  01
12EC:  MOVWF  60
12EE:  BSF    F94.3
12F0:  MOVLW  00
12F2:  BTFSC  F82.3
12F4:  MOVLW  01
12F6:  IORWF  60,W
12F8:  BZ    1304
....................                         stop();
12FA:  CALL   073A
....................                         q=True;
12FE:  MOVLW  01
1300:  MOVWF  4E
....................                         break;
1302:  BRA    1322
....................                         }
....................                         
....................                        if (check_right_proxy()){
1304:  CALL   0726
1308:  MOVF   01,F
130A:  BZ    1316
....................                         stop();
130C:  CALL   073A
....................                         q=True;
1310:  MOVLW  01
1312:  MOVWF  4E
....................                         break;
1314:  BRA    1322
....................                        }
....................                            
....................                      normal(c);
1316:  MOVFF  27,64
131A:  CALL   0674
131E:  INCF   50,F
1320:  BRA    12DE
....................                      }
....................                   c=c+1;  
1322:  MOVLW  01
1324:  ADDWF  27,F
1326:  INCF   4F,F
1328:  BRA    12CC
....................                   }
....................                   start=False;
132A:  CLRF   4D
132C:  BRA    12BC
....................                }
....................          
....................                if (check_right_proxy()){
132E:  CALL   0726
1332:  MOVF   01,F
1334:  BZ    133E
....................                stop();
1336:  CALL   073A
....................                correct = False;
133A:  CLRF   35
....................                break;
133C:  BRA    1378
....................                }
....................                  
....................                normal (delay_s);
133E:  MOVFF  24,64
1342:  CALL   0674
....................     
....................                
....................                if (input (button2) == 1 |input (button3) == 1 | input (button3) == 1 | input (button4) == 1)
1346:  BSF    F95.0
1348:  MOVLW  00
134A:  BTFSC  F83.0
134C:  MOVLW  01
134E:  MOVWF  60
1350:  BSF    F94.3
1352:  MOVLW  00
1354:  BTFSC  F82.3
1356:  MOVLW  01
1358:  IORWF  60,F
135A:  BSF    F94.3
135C:  MOVLW  00
135E:  BTFSC  F82.3
1360:  MOVLW  01
1362:  IORWF  60,F
1364:  BSF    F94.2
1366:  MOVLW  00
1368:  BTFSC  F82.2
136A:  MOVLW  01
136C:  IORWF  60,W
136E:  BZ    1376
....................                {
....................                   stop ();
1370:  CALL   073A
....................                   break;
1374:  BRA    1378
....................                }
1376:  BRA    12BC
.................... 
....................             }
.................... 
....................             
....................             break;
1378:  BRA    138A
....................          }
.................... 
....................          
....................          if (flag == FALSE)
137A:  MOVF   2A,F
137C:  BNZ   1388
....................          {
....................             flag = TRUE;
137E:  MOVLW  01
1380:  MOVWF  2A
....................             mode_AUTO = FALSE;
1382:  CLRF   28
....................             mode_manuel = TRUE;
1384:  MOVWF  29
....................             break;
1386:  BRA    138A
....................          }
1388:  BRA    127C
.................... }
....................          
....................       
.................... 
.................... ////////////////>>>>>> MANUEL <<<<< ////////////////////
.................... char start=True;
.................... char q=False;
138A:  MOVLW  01
138C:  MOVWF  51
138E:  CLRF   52
.................... 
....................       while (input (button1) == 1  & mode_manuel == TRUE)
1390:  BSF    F95.1
1392:  MOVLW  00
1394:  BTFSC  F83.1
1396:  MOVLW  01
1398:  MOVWF  60
139A:  DECFSZ 29,W
139C:  BRA    13A0
139E:  BRA    13A4
13A0:  MOVLW  00
13A2:  BRA    13A6
13A4:  MOVLW  01
13A6:  ANDWF  60,W
13A8:  BZ    1458
....................       {
....................          if (check_right_proxy()){
13AA:  CALL   0726
13AE:  MOVF   01,F
13B0:  BZ    13BA
....................                stop();
13B2:  CALL   073A
....................                correct = False;
13B6:  CLRF   35
....................                break;
13B8:  BRA    1458
....................           }
....................          
....................         while (start==True){
13BA:  DECFSZ 51,W
13BC:  BRA    142C
....................          c=abs(delay_s-(10-accel));
13BE:  MOVLW  0A
13C0:  BSF    FD8.0
13C2:  SUBFWB 25,W
13C4:  SUBWF  24,W
13C6:  MOVWF  27
....................          for(int i=0;i<10-accel;i++){
13C8:  CLRF   53
13CA:  MOVLW  0A
13CC:  BSF    FD8.0
13CE:  SUBFWB 25,W
13D0:  SUBWF  53,W
13D2:  BC    1428
....................          
....................              if (q==True){
13D4:  DECFSZ 52,W
13D6:  BRA    13DA
....................                break;
13D8:  BRA    1428
....................                }
....................               
....................             for(int j=0;j<accel_value;j++){
13DA:  CLRF   54
13DC:  MOVF   26,W
13DE:  SUBWF  54,W
13E0:  BC    1420
....................             
....................                if(input (button1) == 0 | input(button3) == 1){
13E2:  BSF    F95.1
13E4:  MOVLW  00
13E6:  BTFSS  F83.1
13E8:  MOVLW  01
13EA:  MOVWF  60
13EC:  BSF    F94.3
13EE:  MOVLW  00
13F0:  BTFSC  F82.3
13F2:  MOVLW  01
13F4:  IORWF  60,W
13F6:  BZ    1402
....................                   stop();
13F8:  CALL   073A
....................                   q=True;
13FC:  MOVLW  01
13FE:  MOVWF  52
....................                   break;
1400:  BRA    1420
....................                   }
....................                   
....................                  if (check_right_proxy()){
1402:  CALL   0726
1406:  MOVF   01,F
1408:  BZ    1414
....................                   stop();
140A:  CALL   073A
....................                   q=True;
140E:  MOVLW  01
1410:  MOVWF  52
....................                   break;
1412:  BRA    1420
....................                  }
....................                      
....................                normal(c);
1414:  MOVFF  27,64
1418:  CALL   0674
141C:  INCF   54,F
141E:  BRA    13DC
....................                }
....................             c=c+1;  
1420:  MOVLW  01
1422:  ADDWF  27,F
1424:  INCF   53,F
1426:  BRA    13CA
....................             }
....................             start=False;
1428:  CLRF   51
142A:  BRA    13BA
....................          }  
....................          
....................          if(input (button3) == 1){
142C:  BSF    F94.3
142E:  BTFSS  F82.3
1430:  BRA    1438
....................          stop();
1432:  CALL   073A
....................          break;
1436:  BRA    1458
....................          }
....................          
....................          
....................          
....................           if (q==True){
1438:  DECFSZ 52,W
143A:  BRA    144A
....................             q=!q;
143C:  MOVF   52,F
143E:  BZ    1444
1440:  MOVLW  00
1442:  BRA    1446
1444:  MOVLW  01
1446:  MOVWF  52
....................             break;
1448:  BRA    1458
....................             }
.................... 
....................          normal (delay_s);
144A:  MOVFF  24,64
144E:  CALL   0674
....................          quit1=True;
1452:  MOVLW  01
1454:  MOVWF  36
1456:  BRA    1390
....................       }
....................          
....................       while (input (button3) == 1 & mode_manuel == TRUE)
1458:  BSF    F94.3
145A:  MOVLW  00
145C:  BTFSC  F82.3
145E:  MOVLW  01
1460:  MOVWF  60
1462:  DECFSZ 29,W
1464:  BRA    1468
1466:  BRA    146C
1468:  MOVLW  00
146A:  BRA    146E
146C:  MOVLW  01
146E:  ANDWF  60,W
1470:  BZ    1520
....................       {
....................          if (check_left_proxy()){
1472:  CALL   0804
1476:  MOVF   01,F
1478:  BZ    1482
....................                stop();
147A:  CALL   073A
....................                correct = False;
147E:  CLRF   35
....................                break;
1480:  BRA    1520
....................           }
....................           
....................          while (start==True){
1482:  DECFSZ 51,W
1484:  BRA    14F4
....................          c=abs(delay_s-(10-accel));
1486:  MOVLW  0A
1488:  BSF    FD8.0
148A:  SUBFWB 25,W
148C:  SUBWF  24,W
148E:  MOVWF  27
....................          for(int i=0;i<10-accel;i++){   
1490:  CLRF   55
1492:  MOVLW  0A
1494:  BSF    FD8.0
1496:  SUBFWB 25,W
1498:  SUBWF  55,W
149A:  BC    14F0
....................             
....................             if (q==True){
149C:  DECFSZ 52,W
149E:  BRA    14A2
....................             break;
14A0:  BRA    14F0
....................             }
....................             
....................             for(int j=0;j<accel_value;j++){
14A2:  CLRF   56
14A4:  MOVF   26,W
14A6:  SUBWF  56,W
14A8:  BC    14E8
....................             
....................                if(input (button3) == 0){
14AA:  BSF    F94.3
14AC:  BTFSC  F82.3
14AE:  BRA    14BA
....................                   stop();
14B0:  CALL   073A
....................                   q=True;
14B4:  MOVLW  01
14B6:  MOVWF  52
....................                   break;
14B8:  BRA    14E8
....................                   }
....................                   
....................                 if(input (button1) == 1){
14BA:  BSF    F95.1
14BC:  BTFSS  F83.1
14BE:  BRA    14CA
....................                    stop();
14C0:  CALL   073A
....................                   q=True;
14C4:  MOVLW  01
14C6:  MOVWF  52
....................                   break;
14C8:  BRA    14E8
....................                   }
....................                   
....................                  if (check_left_proxy()){
14CA:  CALL   0804
14CE:  MOVF   01,F
14D0:  BZ    14DC
....................                   stop();
14D2:  CALL   073A
....................                   q=True;
14D6:  MOVLW  01
14D8:  MOVWF  52
....................                   break;
14DA:  BRA    14E8
....................                  }
....................                   
....................                reverse(c);
14DC:  MOVFF  27,64
14E0:  CALL   0752
14E4:  INCF   56,F
14E6:  BRA    14A4
....................                }
....................          c=c+1;  
14E8:  MOVLW  01
14EA:  ADDWF  27,F
14EC:  INCF   55,F
14EE:  BRA    1492
....................          }
....................          start=False;
14F0:  CLRF   51
14F2:  BRA    1482
....................          }
....................          
....................          if (input (button1) == 1){
14F4:  BSF    F95.1
14F6:  BTFSS  F83.1
14F8:  BRA    1500
....................          stop();
14FA:  CALL   073A
....................          break;
14FE:  BRA    1520
....................          }
....................          
....................          if (q==True){
1500:  DECFSZ 52,W
1502:  BRA    1512
....................             q=!q;
1504:  MOVF   52,F
1506:  BZ    150C
1508:  MOVLW  00
150A:  BRA    150E
150C:  MOVLW  01
150E:  MOVWF  52
....................             break;
1510:  BRA    1520
....................             }
....................         
....................          reverse (delay_s);
1512:  MOVFF  24,64
1516:  CALL   0752
....................          quit2=True;
151A:  MOVLW  01
151C:  MOVWF  37
151E:  BRA    1458
....................       }
....................       
....................       while(quit2==True){
1520:  DECFSZ 37,W
1522:  BRA    156E
....................          for(int i=0;i<10-accel;i++){                
1524:  CLRF   57
1526:  MOVLW  0A
1528:  BSF    FD8.0
152A:  SUBFWB 25,W
152C:  SUBWF  57,W
152E:  BC    1566
....................             for(int j=0;j<accel_value;j++){        
1530:  CLRF   58
1532:  MOVF   26,W
1534:  SUBWF  58,W
1536:  BC    1544
....................                reverse(c);
1538:  MOVFF  27,64
153C:  CALL   0752
1540:  INCF   58,F
1542:  BRA    1532
....................                }
....................                c=c-1;  
1544:  MOVLW  01
1546:  SUBWF  27,F
....................   
....................                if(input (button1) == 1){
1548:  BSF    F95.1
154A:  BTFSS  F83.1
154C:  BRA    1554
....................                stop();
154E:  CALL   073A
....................                break;
1552:  BRA    1566
....................                }
....................                
....................                if (check_left_proxy()){
1554:  CALL   0804
1558:  MOVF   01,F
155A:  BZ    1562
....................                   stop();
155C:  CALL   073A
....................                   break;
1560:  BRA    1566
....................                  }
1562:  INCF   57,F
1564:  BRA    1526
....................          }
....................          quit2=False;
1566:  CLRF   37
....................          stop();
1568:  CALL   073A
156C:  BRA    1520
....................          }
....................        
....................       while(quit1==True){
156E:  DECFSZ 36,W
1570:  BRA    15BC
....................          for(int i=0;i<10-accel;i++){                
1572:  CLRF   59
1574:  MOVLW  0A
1576:  BSF    FD8.0
1578:  SUBFWB 25,W
157A:  SUBWF  59,W
157C:  BC    15B4
....................             for(int j=0;j<accel_value;j++){        
157E:  CLRF   5A
1580:  MOVF   26,W
1582:  SUBWF  5A,W
1584:  BC    1592
....................                normal(c);
1586:  MOVFF  27,64
158A:  CALL   0674
158E:  INCF   5A,F
1590:  BRA    1580
....................                }
....................                c=c-1;  
1592:  MOVLW  01
1594:  SUBWF  27,F
....................             
....................                if(input (button3) == 1){
1596:  BSF    F94.3
1598:  BTFSS  F82.3
159A:  BRA    15A2
....................                stop();
159C:  CALL   073A
....................                break;
15A0:  BRA    15B4
....................                }
....................                
....................                if (check_right_proxy()){
15A2:  CALL   0726
15A6:  MOVF   01,F
15A8:  BZ    15B0
....................                   stop();
15AA:  CALL   073A
....................                   break;
15AE:  BRA    15B4
....................                  }
15B0:  INCF   59,F
15B2:  BRA    1574
....................          }
....................          quit1=False;
15B4:  CLRF   36
....................          stop();
15B6:  CALL   073A
15BA:  BRA    156E
....................          }
....................          
....................       stop();
15BC:  CALL   073A
....................       
.................... 
.................... ////////////////////>>>>>> AUTO <<<<</////////////////////
.................... 
....................       if (input (button1) == 1 & mode_auto == TRUE)
15C0:  BSF    F95.1
15C2:  MOVLW  00
15C4:  BTFSC  F83.1
15C6:  MOVLW  01
15C8:  MOVWF  60
15CA:  DECFSZ 28,W
15CC:  BRA    15D0
15CE:  BRA    15D4
15D0:  MOVLW  00
15D2:  BRA    15D6
15D4:  MOVLW  01
15D6:  ANDWF  60,W
15D8:  BZ    169E
....................       {
....................       start=True;
15DA:  MOVLW  01
15DC:  MOVWF  51
....................       q=False;
15DE:  CLRF   52
....................       delay_ms(500);
15E0:  MOVLW  02
15E2:  MOVWF  5F
15E4:  MOVLW  FA
15E6:  MOVWF  67
15E8:  CALL   0222
15EC:  DECFSZ 5F,F
15EE:  BRA    15E4
....................       
....................          while (TRUE)
....................          {  
....................          while (start==True){
15F0:  DECFSZ 51,W
15F2:  BRA    1662
....................             c=abs(delay_s-(10-accel));
15F4:  MOVLW  0A
15F6:  BSF    FD8.0
15F8:  SUBFWB 25,W
15FA:  SUBWF  24,W
15FC:  MOVWF  27
....................             for(int i=0;i<10-accel;i++){
15FE:  CLRF   5B
1600:  MOVLW  0A
1602:  BSF    FD8.0
1604:  SUBFWB 25,W
1606:  SUBWF  5B,W
1608:  BC    165E
....................             
....................                 if (q==True){
160A:  DECFSZ 52,W
160C:  BRA    1610
....................                   break;
160E:  BRA    165E
....................                   }
....................                  
....................                for(int j=0;j<accel_value;j++){
1610:  CLRF   5C
1612:  MOVF   26,W
1614:  SUBWF  5C,W
1616:  BC    1656
....................                
....................                   if(input (button1) == 1 | input (button3) == 1){
1618:  BSF    F95.1
161A:  MOVLW  00
161C:  BTFSC  F83.1
161E:  MOVLW  01
1620:  MOVWF  60
1622:  BSF    F94.3
1624:  MOVLW  00
1626:  BTFSC  F82.3
1628:  MOVLW  01
162A:  IORWF  60,W
162C:  BZ    1638
....................                      stop();
162E:  CALL   073A
....................                      q=True;
1632:  MOVLW  01
1634:  MOVWF  52
....................                      break;
1636:  BRA    1656
....................                      }
....................                      
....................                     if (check_right_proxy()){
1638:  CALL   0726
163C:  MOVF   01,F
163E:  BZ    164A
....................                      stop();
1640:  CALL   073A
....................                      q=True;
1644:  MOVLW  01
1646:  MOVWF  52
....................                      break;
1648:  BRA    1656
....................                     }
....................                         
....................                   normal(c);
164A:  MOVFF  27,64
164E:  CALL   0674
1652:  INCF   5C,F
1654:  BRA    1612
....................                   }
....................                c=c+1;  
1656:  MOVLW  01
1658:  ADDWF  27,F
165A:  INCF   5B,F
165C:  BRA    1600
....................                }
....................                start=False;
165E:  CLRF   51
1660:  BRA    15F0
....................             }
....................          
....................             if (check_right_proxy()){
1662:  CALL   0726
1666:  MOVF   01,F
1668:  BZ    1672
....................                stop();
166A:  CALL   073A
....................                correct = False;
166E:  CLRF   35
....................                break;
1670:  BRA    169E
....................           }
....................           
....................             normal (delay_s);
1672:  MOVFF  24,64
1676:  CALL   0674
....................             
....................             if (input (button2) == 1|input (button3) == 1|input (button4) == 1)
167A:  BSF    F95.0
167C:  MOVLW  00
167E:  BTFSC  F83.0
1680:  MOVLW  01
1682:  MOVWF  60
1684:  BSF    F94.3
1686:  MOVLW  00
1688:  BTFSC  F82.3
168A:  MOVLW  01
168C:  IORWF  60,F
168E:  BSF    F94.2
1690:  MOVLW  00
1692:  BTFSC  F82.2
1694:  MOVLW  01
1696:  IORWF  60,W
1698:  BZ    169C
....................             {
....................                break;
169A:  BRA    169E
....................             }
169C:  BRA    15F0
....................          }
....................       }
.................... 
....................       if (input (button3) == 1 & mode_auto == TRUE)
169E:  BSF    F94.3
16A0:  MOVLW  00
16A2:  BTFSC  F82.3
16A4:  MOVLW  01
16A6:  MOVWF  60
16A8:  DECFSZ 28,W
16AA:  BRA    16AE
16AC:  BRA    16B2
16AE:  MOVLW  00
16B0:  BRA    16B4
16B2:  MOVLW  01
16B4:  ANDWF  60,W
16B6:  BZ    177C
....................       {
....................          start=True;
16B8:  MOVLW  01
16BA:  MOVWF  51
....................          q=False;
16BC:  CLRF   52
....................          delay_ms(500);
16BE:  MOVLW  02
16C0:  MOVWF  5F
16C2:  MOVLW  FA
16C4:  MOVWF  67
16C6:  CALL   0222
16CA:  DECFSZ 5F,F
16CC:  BRA    16C2
....................          
....................       
....................          while (TRUE)
....................          {  
....................             
....................             while (start==True){
16CE:  DECFSZ 51,W
16D0:  BRA    1740
....................             c=abs(delay_s-(10-accel));
16D2:  MOVLW  0A
16D4:  BSF    FD8.0
16D6:  SUBFWB 25,W
16D8:  SUBWF  24,W
16DA:  MOVWF  27
....................             for(int i=0;i<10-accel;i++){
16DC:  CLRF   5D
16DE:  MOVLW  0A
16E0:  BSF    FD8.0
16E2:  SUBFWB 25,W
16E4:  SUBWF  5D,W
16E6:  BC    173C
....................             
....................                 if (q==True){
16E8:  DECFSZ 52,W
16EA:  BRA    16EE
....................                   break;
16EC:  BRA    173C
....................                   }
....................                  
....................                for(int j=0;j<accel_value;j++){
16EE:  CLRF   5E
16F0:  MOVF   26,W
16F2:  SUBWF  5E,W
16F4:  BC    1734
....................                
....................                   if(input (button1) == 1 | input (button3) == 1){
16F6:  BSF    F95.1
16F8:  MOVLW  00
16FA:  BTFSC  F83.1
16FC:  MOVLW  01
16FE:  MOVWF  60
1700:  BSF    F94.3
1702:  MOVLW  00
1704:  BTFSC  F82.3
1706:  MOVLW  01
1708:  IORWF  60,W
170A:  BZ    1716
....................                      stop();
170C:  CALL   073A
....................                      q=True;
1710:  MOVLW  01
1712:  MOVWF  52
....................                      break;
1714:  BRA    1734
....................                      }
....................                      
....................                     if (check_left_proxy()){
1716:  CALL   0804
171A:  MOVF   01,F
171C:  BZ    1728
....................                      stop();
171E:  CALL   073A
....................                      q=True;
1722:  MOVLW  01
1724:  MOVWF  52
....................                      break;
1726:  BRA    1734
....................                     }
....................                         
....................                   reverse(c);
1728:  MOVFF  27,64
172C:  CALL   0752
1730:  INCF   5E,F
1732:  BRA    16F0
....................                   }
....................                c=c+1;  
1734:  MOVLW  01
1736:  ADDWF  27,F
1738:  INCF   5D,F
173A:  BRA    16DE
....................                }
....................                start=False;
173C:  CLRF   51
173E:  BRA    16CE
....................             }
....................             
....................          
....................             if (check_left_proxy()){
1740:  CALL   0804
1744:  MOVF   01,F
1746:  BZ    1750
....................                stop();
1748:  CALL   073A
....................                correct = False;              
174C:  CLRF   35
....................                break;
174E:  BRA    177C
....................           }
....................             reverse (delay_s);
1750:  MOVFF  24,64
1754:  CALL   0752
....................             
....................             if (input (button2) == 1|input (button1) == 1|input (button4) == 1)
1758:  BSF    F95.0
175A:  MOVLW  00
175C:  BTFSC  F83.0
175E:  MOVLW  01
1760:  MOVWF  60
1762:  BSF    F95.1
1764:  MOVLW  00
1766:  BTFSC  F83.1
1768:  MOVLW  01
176A:  IORWF  60,F
176C:  BSF    F94.2
176E:  MOVLW  00
1770:  BTFSC  F82.2
1772:  MOVLW  01
1774:  IORWF  60,W
1776:  BZ    177A
....................             {
....................                break;
1778:  BRA    177C
....................             }
177A:  BRA    16CE
....................          }
....................       }
.................... 
.................... ////////////////////>>>>>> CENTER <<<<<//////////////////////
....................       if (input (button2) == 1)
177C:  BSF    F95.0
177E:  BTFSS  F83.0
1780:  BRA    179A
....................       {  
....................       delay_ms (500);
1782:  MOVLW  02
1784:  MOVWF  5F
1786:  MOVLW  FA
1788:  MOVWF  67
178A:  CALL   0222
178E:  DECFSZ 5F,F
1790:  BRA    1786
....................          centerline(6);
1792:  MOVLW  06
1794:  MOVWF  5F
1796:  GOTO   0818
....................          
....................       }
....................   
....................      
.................... ////////////////////>>>>>> GOGO <<<<<//////////////////////
.................... 
....................        if (input (button4) == 1)
179A:  BSF    F94.2
179C:  BTFSS  F82.2
179E:  BRA    17B4
....................       {
....................          delay_ms (500);
17A0:  MOVLW  02
17A2:  MOVWF  5F
17A4:  MOVLW  FA
17A6:  MOVWF  67
17A8:  CALL   0222
17AC:  DECFSZ 5F,F
17AE:  BRA    17A4
....................          gogo();
17B0:  GOTO   097A
....................          
....................       }
17B4:  GOTO   0B8A
....................       
....................       
....................    } 
....................    
....................  }
.................... 
17B8:  SLEEP 
.................... 

Configuration Fuses:
   Word  1: C100   XT FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
