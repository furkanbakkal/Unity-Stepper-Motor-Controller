CCS PCH C Compiler, Version 5.093, 4770               09-Eyl-22 18:09

               Filename:   C:\Users\furka\Desktop\Unity\lcd_stepper_control\main.lst

               ROM used:   9712 bytes (15%)
                           Largest free fragment is 55820
               RAM used:   117 (3%) at main() level
                           142 (4%) worst case
               Stack used: 10 locations (8 in main + 2 for interrupts)
               Stack size: 31

00000:  GOTO   15AE
*
00008:  GOTO   0128
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  F9D.0
00066:  GOTO   0070
0006A:  BTFSC  F9E.0
0006C:  GOTO   01A2
00070:  BTFSS  FA0.2
00072:  GOTO   007C
00076:  BTFSC  FA1.2
00078:  GOTO   0346
0007C:  MOVFF  0E,00
00080:  MOVFF  0F,01
00084:  MOVFF  10,02
00088:  MOVFF  11,03
0008C:  MOVFF  0C,FE9
00090:  MOVFF  07,FEA
00094:  BSF    07.7
00096:  MOVFF  08,FE1
0009A:  MOVFF  09,FE2
0009E:  MOVFF  0A,FD9
000A2:  MOVFF  0B,FDA
000A6:  MOVFF  12,FF3
000AA:  MOVFF  13,FF4
000AE:  MOVFF  14,FFA
000B2:  MOVFF  15,FF5
000B6:  MOVFF  16,FF6
000BA:  MOVFF  17,FF7
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
000CA:  CLRF   FF7
000CC:  ADDLW  DA
000CE:  MOVWF  FF6
000D0:  MOVLW  00
000D2:  ADDWFC FF7,F
000D4:  TBLRD*+
000D6:  MOVF   FF5,W
000D8:  RETURN 0
000DA:  DATA 28,0C
000DC:  DATA 01,06
000DE:  CLRF   FF7
000E0:  ADDLW  EE
000E2:  MOVWF  FF6
000E4:  MOVLW  00
000E6:  ADDWFC FF7,F
000E8:  TBLRD*+
000EA:  MOVF   FF5,W
000EC:  RETURN 0
000EE:  DATA 00,00
000F0:  DATA 15,15
000F2:  DATA 15,15
000F4:  DATA 15,00
000F6:  DATA 1F,1F
000F8:  DATA 1F,1F
000FA:  DATA 1F,1F
000FC:  DATA 1F,1F
000FE:  DATA 1F,11
00100:  DATA 11,11
00102:  DATA 11,11
00104:  DATA 11,1F
00106:  DATA 20,00
00108:  DATA 20,00
0010A:  DATA 20,00
0010C:  DATA 20,20
0010E:  DATA 00,00
00110:  DATA 3C,43
00112:  DATA 65,6E
00114:  DATA 74,65
00116:  DATA 72,3E
00118:  DATA 00,00
0011A:  DATA 0C,00
0011C:  DATA 63,6F
0011E:  DATA 75,6E
00120:  DATA 74,3A
00122:  DATA 20,25
00124:  DATA 4C,75
00126:  DATA 00,00
*
00554:  DATA 45,65
00556:  DATA 70,72
00558:  DATA 6F,6D
0055A:  DATA 20,46
0055C:  DATA 61,69
0055E:  DATA 6C,00
00560:  DATA 43,65
00562:  DATA 6E,74
00564:  DATA 65,65
00566:  DATA 20,4D
00568:  DATA 61,63
0056A:  DATA 68,69
0056C:  DATA 6E,65
0056E:  DATA 00,00
00570:  DATA 53,70
00572:  DATA 65,65
00574:  DATA 64,3A
00576:  DATA 20,25
00578:  DATA 20,20
0057A:  DATA 20,00
0057C:  DATA 3C,4D
0057E:  DATA 61,6E
00580:  DATA 75,65
00582:  DATA 6C,3E
00584:  DATA 00,00
00586:  DATA 3C,20
00588:  DATA 41,75
0058A:  DATA 74,6F
0058C:  DATA 20,3E
0058E:  DATA 00,00
00590:  DATA 41,63
00592:  DATA 63,65
00594:  DATA 6C,3A
00596:  DATA 20,25
00598:  DATA 20,20
0059A:  DATA 20,00
0059C:  DATA 25,00
0059E:  DATA 20,20
005A0:  DATA 20,20
005A2:  DATA 00,00
005A4:  DATA 25,00
005A6:  DATA 25,00
005A8:  DATA 68,31
005AA:  DATA 30,00
005AC:  DATA 25,00
005AE:  DATA 20,20
005B0:  DATA 20,20
005B2:  DATA 00,00
005B4:  DATA 25,00
005B6:  DATA 25,00
005B8:  DATA 61,31
005BA:  DATA 30,00
005BC:  DATA 25,00
005BE:  DATA 25,00
005C0:  DATA 25,00
005C2:  DATA 25,00
005C4:  DATA 3C,20
005C6:  DATA 41,75
005C8:  DATA 74,6F
005CA:  DATA 20,3E
005CC:  DATA 00,00
*
00840:  TBLRD*+
00842:  MOVF   FF5,F
00844:  BZ    085E
00846:  MOVFF  FF6,78
0084A:  MOVFF  FF7,79
0084E:  MOVFF  FF5,7E
00852:  RCALL  07F8
00854:  MOVFF  78,FF6
00858:  MOVFF  79,FF7
0085C:  BRA    0840
0085E:  RETURN 0
00860:  MOVFF  FEA,7D
00864:  MOVFF  FE9,7C
00868:  SWAPF  x76,W
0086A:  IORLW  F0
0086C:  MOVWF  x78
0086E:  ADDWF  x78,F
00870:  ADDLW  E2
00872:  MOVWF  x79
00874:  ADDLW  32
00876:  MOVWF  x7B
00878:  MOVF   x76,W
0087A:  ANDLW  0F
0087C:  ADDWF  x79,F
0087E:  ADDWF  x79,F
00880:  ADDWF  x7B,F
00882:  ADDLW  E9
00884:  MOVWF  x7A
00886:  ADDWF  x7A,F
00888:  ADDWF  x7A,F
0088A:  SWAPF  x75,W
0088C:  ANDLW  0F
0088E:  ADDWF  x7A,F
00890:  ADDWF  x7B,F
00892:  RLCF   x7A,F
00894:  RLCF   x7B,F
00896:  COMF   x7B,F
00898:  RLCF   x7B,F
0089A:  MOVF   x75,W
0089C:  ANDLW  0F
0089E:  ADDWF  x7B,F
008A0:  RLCF   x78,F
008A2:  MOVLW  07
008A4:  MOVWF  x77
008A6:  MOVLW  0A
008A8:  DECF   x7A,F
008AA:  ADDWF  x7B,F
008AC:  BNC   08A8
008AE:  DECF   x79,F
008B0:  ADDWF  x7A,F
008B2:  BNC   08AE
008B4:  DECF   x78,F
008B6:  ADDWF  x79,F
008B8:  BNC   08B4
008BA:  DECF   x77,F
008BC:  ADDWF  x78,F
008BE:  BNC   08BA
008C0:  CLRF   FEA
008C2:  MOVLW  77
008C4:  MOVWF  FE9
008C6:  MOVLW  07
008C8:  ANDWF  x7C,W
008CA:  BCF    x7C.6
008CC:  ADDWF  FE9,F
008CE:  MOVLW  00
008D0:  ADDWFC FEA,F
008D2:  MOVF   FE9,W
008D4:  SUBLW  7B
008D6:  BNZ   08DE
008D8:  MOVF   FEA,F
008DA:  BNZ   08DE
008DC:  BSF    x7C.6
008DE:  MOVF   FEF,W
008E0:  MOVWF  00
008E2:  BNZ   08F4
008E4:  BTFSC  x7C.6
008E6:  BRA    08F4
008E8:  BTFSC  x7C.4
008EA:  BRA    0912
008EC:  BTFSC  x7C.3
008EE:  BRA    08F4
008F0:  MOVLW  20
008F2:  BRA    08FA
008F4:  BSF    x7C.3
008F6:  BCF    x7C.4
008F8:  MOVLW  30
008FA:  ADDWF  00,F
008FC:  MOVFF  FEA,76
00900:  MOVFF  FE9,75
00904:  MOVFF  00,7E
00908:  RCALL  07F8
0090A:  MOVFF  76,FEA
0090E:  MOVFF  75,FE9
00912:  MOVF   FEE,W
00914:  BTFSS  x7C.6
00916:  BRA    08D2
00918:  RETURN 0
0091A:  MOVF   x7F,W
0091C:  CLRF   01
0091E:  SUBWF  x7E,W
00920:  BC    0928
00922:  MOVFF  7E,00
00926:  BRA    0940
00928:  CLRF   00
0092A:  MOVLW  08
0092C:  MOVWF  x80
0092E:  RLCF   x7E,F
00930:  RLCF   00,F
00932:  MOVF   x7F,W
00934:  SUBWF  00,W
00936:  BTFSC  FD8.0
00938:  MOVWF  00
0093A:  RLCF   01,F
0093C:  DECFSZ x80,F
0093E:  BRA    092E
00940:  RETURN 0
00942:  MOVLW  20
00944:  BTFSS  x73.4
00946:  MOVLW  30
00948:  MOVWF  x74
0094A:  MOVFF  72,00
0094E:  BTFSS  x72.7
00950:  BRA    0962
00952:  COMF   00,F
00954:  INCF   00,F
00956:  MOVFF  00,72
0095A:  MOVLW  2D
0095C:  MOVWF  x74
0095E:  BSF    x73.7
00960:  BSF    x73.0
00962:  MOVF   01,W
00964:  MOVFF  72,7E
00968:  MOVLW  64
0096A:  MOVWF  x7F
0096C:  RCALL  091A
0096E:  MOVFF  00,72
00972:  MOVLW  30
00974:  ADDWF  01,W
00976:  MOVWF  x75
00978:  MOVFF  72,7E
0097C:  MOVLW  0A
0097E:  MOVWF  x7F
00980:  RCALL  091A
00982:  MOVLW  30
00984:  ADDWF  00,W
00986:  MOVWF  x77
00988:  MOVLW  30
0098A:  ADDWF  01,W
0098C:  MOVWF  x76
0098E:  MOVFF  74,00
00992:  MOVLW  30
00994:  SUBWF  x75,W
00996:  BZ    09A0
00998:  BSF    x73.1
0099A:  BTFSC  x73.7
0099C:  BSF    x73.2
0099E:  BRA    09C4
009A0:  MOVFF  74,75
009A4:  MOVLW  20
009A6:  MOVWF  x74
009A8:  MOVLW  30
009AA:  SUBWF  x76,W
009AC:  BZ    09B6
009AE:  BSF    x73.0
009B0:  BTFSC  x73.7
009B2:  BSF    x73.1
009B4:  BRA    09C4
009B6:  BTFSS  FD8.2
009B8:  BSF    x73.0
009BA:  BNZ   09C4
009BC:  MOVFF  75,76
009C0:  MOVLW  20
009C2:  MOVWF  x75
009C4:  BTFSC  x73.2
009C6:  BRA    09D2
009C8:  BTFSC  x73.1
009CA:  BRA    09D8
009CC:  BTFSC  x73.0
009CE:  BRA    09DE
009D0:  BRA    09E4
009D2:  MOVFF  74,7E
009D6:  RCALL  07F8
009D8:  MOVFF  75,7E
009DC:  RCALL  07F8
009DE:  MOVFF  76,7E
009E2:  RCALL  07F8
009E4:  MOVFF  77,7E
009E8:  RCALL  07F8
009EA:  RETURN 0
009EC:  MOVF   01,W
009EE:  MOVFF  72,7E
009F2:  MOVLW  64
009F4:  MOVWF  x7F
009F6:  RCALL  091A
009F8:  MOVFF  00,72
009FC:  MOVF   01,W
009FE:  MOVLW  30
00A00:  BNZ   0A10
00A02:  BTFSS  x73.1
00A04:  BRA    0A1E
00A06:  BTFSC  x73.3
00A08:  BRA    0A1E
00A0A:  BTFSC  x73.4
00A0C:  MOVLW  20
00A0E:  BRA    0A16
00A10:  BCF    x73.3
00A12:  BCF    x73.4
00A14:  BSF    x73.0
00A16:  ADDWF  01,F
00A18:  MOVFF  01,7E
00A1C:  RCALL  07F8
00A1E:  MOVFF  72,7E
00A22:  MOVLW  0A
00A24:  MOVWF  x7F
00A26:  RCALL  091A
00A28:  MOVFF  00,72
00A2C:  MOVF   01,W
00A2E:  MOVLW  30
00A30:  BNZ   0A3E
00A32:  BTFSC  x73.3
00A34:  BRA    0A46
00A36:  BTFSS  x73.0
00A38:  BRA    0A46
00A3A:  BTFSC  x73.4
00A3C:  MOVLW  20
00A3E:  ADDWF  01,F
00A40:  MOVFF  01,7E
00A44:  RCALL  07F8
00A46:  MOVLW  30
00A48:  ADDWF  x72,F
00A4A:  MOVFF  72,7E
00A4E:  RCALL  07F8
00A50:  RETURN 0
*
00A76:  MOVLW  8E
00A78:  MOVWF  00
00A7A:  MOVFF  73,01
00A7E:  MOVFF  72,02
00A82:  CLRF   03
00A84:  MOVF   01,F
00A86:  BNZ   0A9A
00A88:  MOVFF  02,01
00A8C:  CLRF   02
00A8E:  MOVLW  08
00A90:  SUBWF  00,F
00A92:  MOVF   01,F
00A94:  BNZ   0A9A
00A96:  CLRF   00
00A98:  BRA    0AAA
00A9A:  BCF    FD8.0
00A9C:  BTFSC  01.7
00A9E:  BRA    0AA8
00AA0:  RLCF   02,F
00AA2:  RLCF   01,F
00AA4:  DECF   00,F
00AA6:  BRA    0A9A
00AA8:  BCF    01.7
00AAA:  RETURN 0
*
00C12:  CLRF   01
00C14:  CLRF   02
00C16:  CLRF   00
00C18:  CLRF   03
00C1A:  MOVF   x7B,W
00C1C:  BNZ   0C22
00C1E:  MOVF   x7A,W
00C20:  BZ    0C52
00C22:  MOVLW  10
00C24:  MOVWF  x7C
00C26:  BCF    FD8.0
00C28:  RLCF   x78,F
00C2A:  RLCF   x79,F
00C2C:  RLCF   00,F
00C2E:  RLCF   03,F
00C30:  MOVF   x7B,W
00C32:  SUBWF  03,W
00C34:  BNZ   0C3A
00C36:  MOVF   x7A,W
00C38:  SUBWF  00,W
00C3A:  BNC   0C4A
00C3C:  MOVF   x7A,W
00C3E:  SUBWF  00,F
00C40:  BTFSS  FD8.0
00C42:  DECF   03,F
00C44:  MOVF   x7B,W
00C46:  SUBWF  03,F
00C48:  BSF    FD8.0
00C4A:  RLCF   01,F
00C4C:  RLCF   02,F
00C4E:  DECFSZ x7C,F
00C50:  BRA    0C26
00C52:  RETURN 0
00C54:  MOVLW  20
00C56:  BTFSS  x79.4
00C58:  MOVLW  30
00C5A:  MOVWF  x7A
00C5C:  MOVFF  78,00
00C60:  BTFSS  x78.7
00C62:  BRA    0C74
00C64:  COMF   00,F
00C66:  INCF   00,F
00C68:  MOVFF  00,78
00C6C:  MOVLW  2D
00C6E:  MOVWF  x7A
00C70:  BSF    x79.7
00C72:  BSF    x79.0
00C74:  MOVF   01,W
00C76:  MOVFF  78,7E
00C7A:  MOVLW  64
00C7C:  MOVWF  x7F
00C7E:  RCALL  091A
00C80:  MOVFF  00,78
00C84:  MOVLW  30
00C86:  ADDWF  01,W
00C88:  MOVWF  x7B
00C8A:  MOVFF  78,7E
00C8E:  MOVLW  0A
00C90:  MOVWF  x7F
00C92:  RCALL  091A
00C94:  MOVLW  30
00C96:  ADDWF  00,W
00C98:  MOVWF  x7D
00C9A:  MOVLW  30
00C9C:  ADDWF  01,W
00C9E:  MOVWF  x7C
00CA0:  MOVFF  7A,00
00CA4:  MOVLW  30
00CA6:  SUBWF  x7B,W
00CA8:  BZ    0CB2
00CAA:  BSF    x79.1
00CAC:  BTFSC  x79.7
00CAE:  BSF    x79.2
00CB0:  BRA    0CD6
00CB2:  MOVFF  7A,7B
00CB6:  MOVLW  20
00CB8:  MOVWF  x7A
00CBA:  MOVLW  30
00CBC:  SUBWF  x7C,W
00CBE:  BZ    0CC8
00CC0:  BSF    x79.0
00CC2:  BTFSC  x79.7
00CC4:  BSF    x79.1
00CC6:  BRA    0CD6
00CC8:  BTFSS  FD8.2
00CCA:  BSF    x79.0
00CCC:  BNZ   0CD6
00CCE:  MOVFF  7B,7C
00CD2:  MOVLW  20
00CD4:  MOVWF  x7B
00CD6:  BTFSC  x79.2
00CD8:  BRA    0CE4
00CDA:  BTFSC  x79.1
00CDC:  BRA    0CEC
00CDE:  BTFSC  x79.0
00CE0:  BRA    0CF4
00CE2:  BRA    0CFC
00CE4:  MOVF   x7A,W
00CE6:  BTFSS  F9E.4
00CE8:  BRA    0CE6
00CEA:  MOVWF  FAD
00CEC:  MOVF   x7B,W
00CEE:  BTFSS  F9E.4
00CF0:  BRA    0CEE
00CF2:  MOVWF  FAD
00CF4:  MOVF   x7C,W
00CF6:  BTFSS  F9E.4
00CF8:  BRA    0CF6
00CFA:  MOVWF  FAD
00CFC:  MOVF   x7D,W
00CFE:  BTFSS  F9E.4
00D00:  BRA    0CFE
00D02:  MOVWF  FAD
00D04:  RETURN 0
*
00E7A:  TBLRD*+
00E7C:  MOVFF  FF6,76
00E80:  MOVFF  FF7,77
00E84:  MOVFF  FF5,7E
00E88:  RCALL  07F8
00E8A:  MOVFF  76,FF6
00E8E:  MOVFF  77,FF7
00E92:  DECFSZ x75,F
00E94:  BRA    0E7A
00E96:  GOTO   0FF8 (RETURN)
*
0138E:  TBLRD*+
01390:  MOVF   FF5,F
01392:  BZ    13AE
01394:  MOVFF  FF6,71
01398:  MOVFF  FF7,72
0139C:  MOVF   FF5,W
0139E:  BTFSS  F9E.4
013A0:  BRA    139E
013A2:  MOVWF  FAD
013A4:  MOVFF  71,FF6
013A8:  MOVFF  72,FF7
013AC:  BRA    138E
013AE:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #fuses NOWDT      //No Watch Dog Timer
.................... 
.................... #use delay(internal=64MHz)
*
0015A:  MOVLW  01
0015C:  SUBWF  x8B,F
0015E:  BNC   0176
00160:  CLRF   FEA
00162:  MOVLW  8B
00164:  MOVWF  FE9
00166:  MOVF   FEF,W
00168:  BZ    0176
0016A:  MOVLW  04
0016C:  MOVWF  00
0016E:  DECFSZ 00,F
00170:  BRA    016E
00172:  DECFSZ FEF,F
00174:  BRA    016A
00176:  GOTO   0184 (RETURN)
*
005CE:  CLRF   FEA
005D0:  MOVLW  7F
005D2:  MOVWF  FE9
005D4:  MOVF   FEF,W
005D6:  BZ    05F4
005D8:  MOVLW  14
005DA:  MOVWF  01
005DC:  CLRF   00
005DE:  DECFSZ 00,F
005E0:  BRA    05DE
005E2:  DECFSZ 01,F
005E4:  BRA    05DC
005E6:  MOVLW  BF
005E8:  MOVWF  00
005EA:  DECFSZ 00,F
005EC:  BRA    05EA
005EE:  BRA    05F0
005F0:  DECFSZ FEF,F
005F2:  BRA    05D8
005F4:  RETURN 0
.................... #device HIGH_INTS = TRUE 
.................... #use timer(timer=0,tick=100us,bits=32,NOISR)
*
00766:  MOVF   FD6,W
00768:  MOVFF  FD7,03
0076C:  BTFSS  FF2.2
0076E:  BRA    0788
00770:  MOVLW  01
00772:  ADDWF  19,F
00774:  BTFSC  FD8.0
00776:  INCF   1A,F
00778:  BTFSC  FD8.2
0077A:  INCF   1B,F
0077C:  BTFSC  FD8.2
0077E:  INCF   1C,F
00780:  BCF    FF2.2
00782:  MOVF   FD6,W
00784:  MOVFF  FD7,03
00788:  MOVWF  00
0078A:  MOVFF  03,01
0078E:  MOVFF  19,02
00792:  MOVFF  1A,03
00796:  MOVF   1B,W
00798:  RRCF   FE8,F
0079A:  RRCF   03,F
0079C:  RRCF   02,F
0079E:  RRCF   01,F
007A0:  RRCF   00,F
007A2:  RRCF   FE8,F
007A4:  RRCF   03,F
007A6:  RRCF   02,F
007A8:  RRCF   01,F
007AA:  RRCF   00,F
007AC:  RRCF   FE8,F
007AE:  RRCF   03,F
007B0:  RRCF   02,F
007B2:  RRCF   01,F
007B4:  RRCF   00,F
007B6:  RETURN 0
.................... #define TICK_TYPE unsigned int32
.................... 
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <flex_lcd420.c>
.................... // Flex_LCD420.c
.................... 
.................... // These pins are for my Microchip PicDem2-Plus board,
.................... // which I used to test this driver.
.................... // An external 20x4 LCD is connected to these pins.
.................... // Change these pins to match your own board's connections.
.................... 
.................... #define LCD_DB4   PIN_A4
.................... #define LCD_DB5   PIN_A5
.................... #define LCD_DB6   PIN_E0
.................... #define LCD_DB7   PIN_E1
.................... 
.................... #define LCD_RS    PIN_A1
.................... #define LCD_RW    PIN_A2
.................... #define LCD_E     PIN_A3
.................... 
.................... /*
.................... // To prove that the driver can be used with random
.................... // pins, I also tested it with these pins:
.................... #define LCD_DB4   PIN_D4
.................... #define LCD_DB5   PIN_B1
.................... #define LCD_DB6   PIN_C5
.................... #define LCD_DB7   PIN_B5
.................... 
.................... #define LCD_RS    PIN_E2
.................... #define LCD_RW    PIN_B2
.................... #define LCD_E     PIN_D6
.................... */
.................... 
.................... // If you want only a 6-pin interface to your LCD, then
.................... // connect the R/W pin on the LCD to ground, and comment
.................... // out the following line.  Doing so will save one PIC
.................... // pin, but at the cost of losing the ability to read from
.................... // the LCD.  It also makes the write time a little longer
.................... // because a static delay must be used, instead of polling
.................... // the LCD's busy bit.  Normally a 6-pin interface is only
.................... // used if you are running out of PIC pins, and you need
.................... // to use as few as possible for the LCD.
.................... #define USE_RW_PIN   1     
.................... 
.................... 
.................... // These are the line addresses for most 4x20 LCDs.
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x40
.................... #define LCD_LINE_3_ADDRESS 0x14
.................... #define LCD_LINE_4_ADDRESS 0x54
.................... 
.................... // These are the line addresses for LCD's which use
.................... // the Hitachi HD66712U controller chip.
.................... /*
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x20
.................... #define LCD_LINE_3_ADDRESS 0x40
.................... #define LCD_LINE_4_ADDRESS 0x60
.................... */
.................... 
.................... 
.................... //========================================
.................... 
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)
.................... 
.................... int8 lcd_line;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots
....................  0xc,                     // Display on
....................  1,                       // Clear display
....................  6                        // Increment cursor
....................  };
....................                              
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
.................... // Note:  !! converts an integer expression
.................... // to a boolean (1 or 0).
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
005F6:  BTFSC  x86.0
005F8:  BRA    05FE
005FA:  BCF    F89.4
005FC:  BRA    0600
005FE:  BSF    F89.4
00600:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
00602:  BTFSC  x86.1
00604:  BRA    060A
00606:  BCF    F89.5
00608:  BRA    060C
0060A:  BSF    F89.5
0060C:  BCF    F92.5
....................  output_bit(LCD_DB6, !!(nibble & 4));   
0060E:  BTFSC  x86.2
00610:  BRA    0616
00612:  BCF    F8D.0
00614:  BRA    0618
00616:  BSF    F8D.0
00618:  BCF    F96.0
....................  output_bit(LCD_DB7, !!(nibble & 8));   
0061A:  BTFSC  x86.3
0061C:  BRA    0622
0061E:  BCF    F8D.1
00620:  BRA    0624
00622:  BSF    F8D.1
00624:  BCF    F96.1
.................... 
....................  delay_cycles(1);
00626:  NOP   
....................  output_high(LCD_E);
00628:  BCF    F92.3
0062A:  BSF    F89.3
....................  delay_us(2);
0062C:  MOVLW  0A
0062E:  MOVWF  00
00630:  DECFSZ 00,F
00632:  BRA    0630
00634:  NOP   
....................  output_low(LCD_E);
00636:  BCF    F92.3
00638:  BCF    F89.3
0063A:  RETURN 0
.................... }
.................... 
.................... //-----------------------------------
.................... // This sub-routine is only called by lcd_read_byte().
.................... // It's not a stand-alone routine.  For example, the
.................... // R/W signal is set high by lcd_read_byte() before
.................... // this routine is called.     
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... // Create bit variables so that we can easily set
.................... // individual bits in the retval variable.
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
0063C:  CLRF   x87
....................    
.................... output_high(LCD_E);
0063E:  BCF    F92.3
00640:  BSF    F89.3
.................... delay_us(1);
00642:  MOVLW  05
00644:  MOVWF  00
00646:  DECFSZ 00,F
00648:  BRA    0646
.................... 
.................... retval_0 = input(LCD_DB4);
0064A:  BSF    F92.4
0064C:  BCF    x87.0
0064E:  BTFSC  F80.4
00650:  BSF    x87.0
.................... retval_1 = input(LCD_DB5);
00652:  BSF    F92.5
00654:  BCF    x87.1
00656:  BTFSC  F80.5
00658:  BSF    x87.1
.................... retval_2 = input(LCD_DB6);
0065A:  BSF    F96.0
0065C:  BCF    x87.2
0065E:  BTFSC  F84.0
00660:  BSF    x87.2
.................... retval_3 = input(LCD_DB7);
00662:  BSF    F96.1
00664:  BCF    x87.3
00666:  BTFSC  F84.1
00668:  BSF    x87.3
....................  
.................... output_low(LCD_E);
0066A:  BCF    F92.3
0066C:  BCF    F89.3
.................... delay_us(1);
0066E:  MOVLW  05
00670:  MOVWF  00
00672:  DECFSZ 00,F
00674:  BRA    0672
....................    
.................... return(retval);   
00676:  MOVFF  87,01
0067A:  RETURN 0
.................... }   
.................... #endif
.................... 
.................... //---------------------------------------
.................... // Read a byte from the LCD and return it.
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
0067C:  BCF    F92.2
0067E:  BSF    F89.2
.................... delay_cycles(1);
00680:  NOP   
.................... 
.................... high = lcd_read_nibble();
00682:  RCALL  063C
00684:  MOVFF  01,86
.................... 
.................... low = lcd_read_nibble();
00688:  RCALL  063C
0068A:  MOVFF  01,85
.................... 
.................... return( (high<<4) | low);
0068E:  SWAPF  x86,W
00690:  MOVWF  00
00692:  MOVLW  F0
00694:  ANDWF  00,F
00696:  MOVF   00,W
00698:  IORWF  x85,W
0069A:  MOVWF  01
0069C:  GOTO   06A6 (RETURN)
.................... }
.................... #endif
.................... 
.................... //----------------------------------------
.................... // Send a byte to the LCD.
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
006A0:  BCF    F92.1
006A2:  BCF    F89.1
.................... 
.................... #ifdef USE_RW_PIN
.................... while(bit_test(lcd_read_byte(),7)) ;
006A4:  BRA    067C
006A6:  MOVFF  01,85
006AA:  BTFSC  01.7
006AC:  BRA    06A4
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
006AE:  MOVF   x83,F
006B0:  BZ    06B8
....................    output_high(LCD_RS);
006B2:  BCF    F92.1
006B4:  BSF    F89.1
006B6:  BRA    06BC
.................... else
....................    output_low(LCD_RS);
006B8:  BCF    F92.1
006BA:  BCF    F89.1
....................      
....................  delay_cycles(1);
006BC:  NOP   
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
006BE:  BCF    F92.2
006C0:  BCF    F89.2
.................... delay_cycles(1);
006C2:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
006C4:  BCF    F92.3
006C6:  BCF    F89.3
.................... 
.................... lcd_send_nibble(n >> 4);
006C8:  SWAPF  x84,W
006CA:  MOVWF  x85
006CC:  MOVLW  0F
006CE:  ANDWF  x85,F
006D0:  MOVFF  85,86
006D4:  RCALL  05F6
.................... lcd_send_nibble(n & 0xf);
006D6:  MOVF   x84,W
006D8:  ANDLW  0F
006DA:  MOVWF  x85
006DC:  MOVWF  x86
006DE:  RCALL  05F6
006E0:  RETURN 0
.................... }
.................... //----------------------------
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... lcd_line = 1;
006E2:  MOVLW  01
006E4:  MOVWF  1F
.................... 
.................... output_low(LCD_RS);
006E6:  BCF    F92.1
006E8:  BCF    F89.1
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
006EA:  BCF    F92.2
006EC:  BCF    F89.2
.................... #endif
.................... 
.................... output_low(LCD_E);
006EE:  BCF    F92.3
006F0:  BCF    F89.3
.................... 
.................... // Some LCDs require 15 ms minimum delay after
.................... // power-up.  Others require 30 ms.  I'm going
.................... // to set it to 35 ms, so it should work with
.................... // all of them.
.................... delay_ms(35);         
006F2:  MOVLW  23
006F4:  MOVWF  x7F
006F6:  RCALL  05CE
.................... 
.................... for(i=0 ;i < 3; i++)
006F8:  CLRF   x71
006FA:  MOVF   x71,W
006FC:  SUBLW  02
006FE:  BNC   0710
....................    {
....................     lcd_send_nibble(0x03);
00700:  MOVLW  03
00702:  MOVWF  x86
00704:  RCALL  05F6
....................     delay_ms(5);
00706:  MOVLW  05
00708:  MOVWF  x7F
0070A:  RCALL  05CE
0070C:  INCF   x71,F
0070E:  BRA    06FA
....................    }
.................... 
.................... lcd_send_nibble(0x02);
00710:  MOVLW  02
00712:  MOVWF  x86
00714:  RCALL  05F6
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
00716:  CLRF   x71
00718:  MOVF   x71,W
0071A:  SUBLW  03
0071C:  BNC   0730
....................    {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
0071E:  CLRF   03
00720:  MOVF   x71,W
00722:  RCALL  00CA
00724:  MOVWF  x72
00726:  CLRF   x83
00728:  MOVWF  x84
0072A:  RCALL  06A0
....................    
....................     // If the R/W signal is not used, then
....................     // the busy bit can't be polled.  One of
....................     // the init commands takes longer than
....................     // the hard-coded delay of 50 us, so in
....................     // that case, lets just do a 5 ms delay
....................     // after all four of them.
....................     #ifndef USE_RW_PIN
0072C:  INCF   x71,F
0072E:  BRA    0718
....................     delay_ms(5);
....................     #endif
....................    }
00730:  GOTO   16C0 (RETURN)
.................... 
.................... }
.................... 
.................... //----------------------------
.................... 
.................... void lcd_gotoxy(int8 x, int8 y)
.................... {
.................... int8 address;
.................... 
.................... 
.................... switch(y)
*
007B8:  MOVF   x80,W
007BA:  XORLW  01
007BC:  BZ    07CC
007BE:  XORLW  03
007C0:  BZ    07D0
007C2:  XORLW  01
007C4:  BZ    07D6
007C6:  XORLW  07
007C8:  BZ    07DC
007CA:  BRA    07E2
....................   {
....................    case 1:
....................      address = LCD_LINE_1_ADDRESS;
007CC:  CLRF   x81
....................      break;
007CE:  BRA    07E4
.................... 
....................    case 2:
....................      address = LCD_LINE_2_ADDRESS;
007D0:  MOVLW  40
007D2:  MOVWF  x81
....................      break;
007D4:  BRA    07E4
.................... 
....................    case 3:
....................      address = LCD_LINE_3_ADDRESS;
007D6:  MOVLW  14
007D8:  MOVWF  x81
....................      break;
007DA:  BRA    07E4
.................... 
....................    case 4:
....................      address = LCD_LINE_4_ADDRESS;
007DC:  MOVLW  54
007DE:  MOVWF  x81
....................      break;
007E0:  BRA    07E4
.................... 
....................    default:
....................      address = LCD_LINE_1_ADDRESS;
007E2:  CLRF   x81
....................      break;
....................      
....................   }
.................... 
.................... address += x-1;
007E4:  MOVLW  01
007E6:  SUBWF  x7F,W
007E8:  ADDWF  x81,F
.................... lcd_send_byte(0, 0x80 | address);
007EA:  MOVF   x81,W
007EC:  IORLW  80
007EE:  MOVWF  x82
007F0:  CLRF   x83
007F2:  MOVWF  x84
007F4:  RCALL  06A0
007F6:  RETURN 0
.................... }
.................... 
.................... //-----------------------------
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
007F8:  MOVF   x7E,W
007FA:  XORLW  0C
007FC:  BZ    0808
007FE:  XORLW  06
00800:  BZ    081C
00802:  XORLW  02
00804:  BZ    082A
00806:  BRA    0834
....................    {
....................     case '\f':
....................       lcd_send_byte(0,1);
00808:  CLRF   x83
0080A:  MOVLW  01
0080C:  MOVWF  x84
0080E:  RCALL  06A0
....................       lcd_line = 1;
00810:  MOVLW  01
00812:  MOVWF  1F
....................       delay_ms(2);
00814:  MOVLW  02
00816:  MOVWF  x7F
00818:  RCALL  05CE
....................       break;
0081A:  BRA    083E
....................    
....................     case '\n':
....................        lcd_gotoxy(1, ++lcd_line);
0081C:  INCF   1F,F
0081E:  MOVLW  01
00820:  MOVWF  x7F
00822:  MOVFF  1F,80
00826:  RCALL  07B8
....................        break;
00828:  BRA    083E
....................    
....................     case '\b':
....................        lcd_send_byte(0,0x10);
0082A:  CLRF   x83
0082C:  MOVLW  10
0082E:  MOVWF  x84
00830:  RCALL  06A0
....................        break;
00832:  BRA    083E
....................    
....................     default:
....................        lcd_send_byte(1,c);
00834:  MOVLW  01
00836:  MOVWF  x83
00838:  MOVFF  7E,84
0083C:  RCALL  06A0
....................        break;
....................    }
0083E:  RETURN 0
.................... }
.................... 
.................... //------------------------------
.................... #ifdef USE_RW_PIN
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(LCD_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... 
.................... #include <internal_eeprom.c>
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////                          internal_eeprom.c                             ////
.................... ////                                                                        ////
.................... ////       Utilities to write various data types to internal eeprom         ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                        ////
.................... ////   void write_int1_eeprom(address, int8 bitPosition, int1 data)         ////
.................... ////     Call to write one bit of data                                      ////
.................... ////                                                                        ////
.................... ////   int1 read_int1_eeprom(address, int8 bitPosition)                     ////
.................... ////     Call to read one bit of data                                       ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_int16_eeprom(address, int16 data)                         ////
.................... ////     Call to write a 16 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   void write_int16_eeprom(address, int16 data)                         ////
.................... ////     Call to read a 16 bit integer                                      ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_int32_eeprom(address, int32 data)                         ////
.................... ////     Call to write a 32 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int16 read_int32_eeprom(address)                                     ////
.................... ////     Call to read a 32 bit integer                                      ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_float_eeprom(address, float data)                         ////
.................... ////     Call to write a 32 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float read_float_eeprom(address)                                     ////
.................... ////     Call to read a 32 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////  PCD only:                                                             ////
.................... ////   void write_int48_eeprom(address, int48 data)                         ////
.................... ////     Call to write a 48 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int48 read_int48_eeprom(address)                                     ////
.................... ////     Call to read a 48 bit integer                                      ////
.................... ////                                                                        ////
.................... ////   void write_int64_eeprom(address, int64 data)                         ////
.................... ////     Call to write a 64 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int64 read_int64_eeprom(address)                                     ////
.................... ////     Call to read a 64 bit integer                                      ////
.................... ////                                                                        ////
.................... ////   void write_float48_eeprom(address, float48 data)                     ////
.................... ////     Call to write a 48 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float48 read_float48_eeprom(address)                                 ////
.................... ////     Call to read a 48 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////   void write_float64_eeprom(address, float64 data)                     ////
.................... ////     Call to write a 64 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float64 read_float64_eeprom(address)                                 ////
.................... ////     Call to read a 64 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2012 Custom Computer Services               ////
.................... //// This source code may only be used by licensed users of the CCS C       ////
.................... //// compiler.  This source code may only be distributed to other licensed  ////
.................... //// users of the CCS C compiler.  No other use, reproduction or            ////
.................... //// distribution is permitted without written permission. Derivative       ////
.................... //// programs created using this software in object code form are not       ////
.................... //// restricted in any way.                                                 ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef INTERNAL_EEPROM_UTILITIES
.................... #define INTERNAL_EEPROM_UTILITIES
.................... 
.................... // Used to adjust the address range
.................... #ifndef INT_EEPROM_ADDRESS
....................    #if getenv("DATA_EEPROM") > 255
....................       #define INT_EEPROM_ADDRESS  unsigned int16
....................    #else
....................       #define INT_EEPROM_ADDRESS  unsigned int8
....................    #endif
.................... #endif
.................... 
.................... #ifndef INT_EEPROM_DATA_SIZE
....................    #ifdef (__PCD__)
....................       #define INT_EEPROM_DATA_SIZE unsigned int16
....................    #else
....................       #define INT_EEPROM_DATA_SIZE unsigned int8
....................    #endif
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //// Internal EEPROM Functions
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Write one bit to internal eeprom
.................... // Inputs:     1) An eeprom address
.................... //             2) The bit position (LSB == 0)
.................... //             3) The bit to write
.................... // Outputs:    None
.................... void write_int1_eeprom(INT_EEPROM_ADDRESS address, unsigned int8 bitPosition, int1 data)
.................... {
....................    INT_EEPROM_DATA_SIZE stored_data;
.................... 
....................    stored_data = read_eeprom(address);
.................... 
....................    if(data)
....................    {
....................       bit_set(stored_data, bitPosition);
....................    }
....................    else
....................    {
....................       bit_clear(stored_data, bitPosition);
....................    }
.................... 
....................    write_eeprom(address, stored_data);
.................... }
.................... 
.................... 
.................... // Purpose:    Read one bit from internal eeprom
.................... // Inputs:     1) An eeprom address
.................... //             2) The bit position (LSB == 0)
.................... // Outputs:    The bit read from internal eeprom
.................... int1 read_int1_eeprom(INT_EEPROM_ADDRESS address, unsigned int8 bitPosition)
.................... {
....................    return bit_test(read_eeprom(address), bitPosition);
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 16 bit number to internal eeprom
.................... // Inputs:     1) An eeprom address. Two eeprom locations will be used.
.................... //             2) The 16 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int16_eeprom(INT_EEPROM_ADDRESS address, unsigned int16 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address,data);
....................    #else
....................    int8 i;
.................... 
....................    for(i = 0; i < 2; ++i)
....................    {
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    }
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 16 bit number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 16 bit number read from internal eeprom
.................... unsigned int16 read_int16_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    #ifdef __PCD__
....................    return(read_eeprom(address));
....................    #else
....................    int8  i;
....................    int16 data;
.................... 
....................    for(i = 0; i < 2; ++i)
....................    {
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
....................    }
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 32 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used.
.................... //             2) The 32 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int32_eeprom(INT_EEPROM_ADDRESS address, unsigned int32 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address, &data, 4);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 32 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 32 bit integer read from internal eeprom
.................... unsigned int32 read_int32_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    #ifdef __PCD__
....................    return(read_eeprom(address, 4));
....................    #else
....................    int8  i;
....................    int32 data;
....................    
....................    for(i = 0; i < 4; i++)
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 32 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float_eeprom(INT_EEPROM_ADDRESS address, float32 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address, &data, 4);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 32 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float32 read_float_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float32 data;
.................... 
....................    #ifdef __PCD__
....................    read_eeprom(address, &data, 4);
....................    
....................    return(data);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... #ifdef __PCD__
.................... // Purpose:    Write a 48 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Six eeprom locations will be used.
.................... //             2) The 48 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int48_eeprom(INT_EEPROM_ADDRESS address, unsigned int48 data)
.................... {
....................    write_eeprom(address, &data, 6);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 48 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 48 bit integer read from internal eeprom
.................... unsigned int48 read_int48_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    return(read_eeprom(address, 6));
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 64 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Eight eeprom locations will be used.
.................... //             2) The 64 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int64_eeprom(INT_EEPROM_ADDRESS address, unsigned int64 data)
.................... {
....................    write_eeprom(address, &data, 8);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 64 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 64 bit integer read from internal eeprom
.................... unsigned int64 read_int64_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    return(read_eeprom(address, 8));
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 48 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Six eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float48_eeprom(INT_EEPROM_ADDRESS address, float48 data)
.................... {
....................    write_eeprom(address, &data, 6);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 48 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float48 read_float48_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float48 data;
.................... 
....................    read_eeprom(address, &data, 6);
....................    
....................    return(data);
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 64 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Eight eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float64_eeprom(INT_EEPROM_ADDRESS address, float64 data)
.................... {
....................    write_eeprom(address, &data, 8);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 64 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float64 read_float64_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float64 data;
.................... 
....................    read_eeprom(address, &data, 8);
....................    
....................    return(data);
.................... }
.................... 
.................... #endif   //__PCD__
....................    
.................... 
.................... #endif   //INTERNAL_EEPROM_UTILITIES
.................... 
.................... 
.................... #use rs232(baud = 9600, parity = N, xmit = PIN_C6, rcv = PIN_C7, bits = 8, stream = PORT1)
.................... 
.................... #define A1 PIN_D2
.................... #define A2 PIN_B1
.................... #define B1 PIN_B0
.................... #define B2 PIN_C5
.................... 
.................... #define button0 PIN_D5 // select adc or pot
.................... #define button1 PIN_D1 // right
.................... #define button2 PIN_D0 // left
.................... #define button3 PIN_C3 // mid
.................... #define button4 PIN_C2 // mode
.................... #define button5 PIN_C1 // mode
.................... 
.................... #define proxy_right PIN_D6
.................... #define proxy_left PIN_D7
.................... 
.................... #define three_dot 0
.................... #define swon 1
.................... #define swoff 2
.................... 
.................... int8 delay_s = 5;
.................... int speed = 0;
.................... int8 accel = 6;
.................... int accel_value = 30;
.................... int c = 0;
.................... 
.................... char mode_auto = False;
.................... char mode_manuel = True;
.................... char flag = TRUE;
.................... 
.................... char data;
.................... char str[4];
.................... int counter = 0;
.................... char correct = False;
.................... char quit1 = False;
.................... char quit2 = False;
.................... 
.................... char proxy = False;
.................... int control_left = 1;
.................... int control_right = 1;
.................... 
.................... char centered = True;
.................... unsigned int16 centercounter = 65535;
.................... int8 cc1, cc2;
.................... char center_flag = False;
.................... 
.................... unsigned int16 step = 350;
.................... int8 step1, step2;
.................... int line1 = 0;
.................... int linecheck = 0;
.................... int8 threshold = 0;
.................... int comm_counter = threshold - 1;
.................... unsigned int16 last_centercounter=65535;
.................... 
.................... char start = True;
.................... char q = False;
.................... char return_value = True;
.................... char check=False;
.................... 
.................... int dir = 0;
.................... char array1[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};
.................... int8 array2[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
.................... TICK_TYPE StartTick, FinishTick, CurrentTick;
.................... 
.................... void delay_func(loop)
.................... {
.................... 
....................     // delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(250);delay_cycles(200);delay_cycles(200);
....................     delay_us(330);
*
0017A:  MOVLW  02
0017C:  MOVWF  x8A
0017E:  MOVLW  A5
00180:  MOVWF  x8B
00182:  BRA    015A
00184:  DECFSZ x8A,F
00186:  BRA    017E
....................     for (int i = 0; i < 10 - loop; i++)
00188:  CLRF   x89
0018A:  MOVLW  0A
0018C:  BSF    FD8.0
0018E:  SUBFWB x88,W
00190:  SUBWF  x89,W
00192:  BC    01A0
....................     {
....................         // delay_cycles(200);
....................         delay_us(40);
00194:  MOVLW  D5
00196:  MOVWF  00
00198:  DECFSZ 00,F
0019A:  BRA    0198
0019C:  INCF   x89,F
0019E:  BRA    018A
....................     }
001A0:  RETURN 0
.................... }
.................... 
.................... void stop()
.................... {
....................     output_low(A1);
*
00C00:  BCF    F95.2
00C02:  BCF    F8C.2
....................     output_low(A2);
00C04:  BCF    F93.1
00C06:  BCF    F8A.1
....................     output_low(B1);
00C08:  BCF    F93.0
00C0A:  BCF    F8A.0
....................     output_low(B2);
00C0C:  BCF    F94.5
00C0E:  BCF    F8B.5
00C10:  RETURN 0
.................... }
.................... 
.................... char check_right_proxy()
.................... {
.................... 
....................     if (input(proxy_right))
*
00E08:  BSF    F95.6
00E0A:  BTFSS  F83.6
00E0C:  BRA    0E50
....................     {
....................         proxy = True;
00E0E:  MOVLW  01
00E10:  MOVWF  31
.................... 
....................         if (!(control_right))
00E12:  MOVF   33,F
00E14:  BNZ   0E4E
....................         {
....................             lcd_gotoxy(1, 4);
00E16:  MOVLW  01
00E18:  MOVWF  x7F
00E1A:  MOVLW  04
00E1C:  MOVWF  x80
00E1E:  RCALL  07B8
....................             lcd_putc(swon);
00E20:  MOVLW  01
00E22:  MOVWF  x7E
00E24:  RCALL  07F8
....................             delay_ms(10);
00E26:  MOVLW  0A
00E28:  MOVWF  x7F
00E2A:  CALL   05CE
....................             printf("y");
00E2E:  MOVLW  79
00E30:  BTFSS  F9E.4
00E32:  BRA    0E30
00E34:  MOVWF  FAD
.................... 
....................             lcd_gotoxy(2, 4);
00E36:  MOVLW  02
00E38:  MOVWF  x7F
00E3A:  MOVLW  04
00E3C:  MOVWF  x80
00E3E:  RCALL  07B8
....................             lcd_putc(" ");
00E40:  MOVLW  06
00E42:  MOVWF  FF6
00E44:  MOVLW  01
00E46:  MOVWF  FF7
00E48:  RCALL  0840
.................... 
....................             control_right = True;
00E4A:  MOVLW  01
00E4C:  MOVWF  33
....................         }
....................     }
00E4E:  BRA    0E68
.................... 
....................     else
....................     {
.................... 
....................         proxy = False;
00E50:  CLRF   31
.................... 
....................         if (control_left)
00E52:  MOVF   32,F
00E54:  BZ    0E68
....................         {
....................             lcd_gotoxy(20, 4);
00E56:  MOVLW  14
00E58:  MOVWF  x7F
00E5A:  MOVLW  04
00E5C:  MOVWF  x80
00E5E:  RCALL  07B8
....................             lcd_putc(swoff);
00E60:  MOVLW  02
00E62:  MOVWF  x7E
00E64:  RCALL  07F8
....................             control_left = False;
00E66:  CLRF   32
....................         }
....................     }
....................     return proxy;
00E68:  MOVFF  31,01
00E6C:  RETURN 0
.................... }
.................... 
.................... char check_left_proxy()
.................... {
.................... 
....................     if (input(proxy_left))
*
00BA8:  BSF    F95.7
00BAA:  BTFSS  F83.7
00BAC:  BRA    0BE2
....................     {
....................         proxy = True;
00BAE:  MOVLW  01
00BB0:  MOVWF  31
....................         step = centercounter;
00BB2:  MOVFF  36,3B
00BB6:  MOVFF  35,3A
....................         
....................         if (!(control_left))
00BBA:  MOVF   32,F
00BBC:  BNZ   0BE0
....................         {
.................... 
....................         lcd_gotoxy(20, 4);
00BBE:  MOVLW  14
00BC0:  MOVWF  x7F
00BC2:  MOVLW  04
00BC4:  MOVWF  x80
00BC6:  RCALL  07B8
....................         lcd_putc(swon);
00BC8:  MOVLW  01
00BCA:  MOVWF  x7E
00BCC:  RCALL  07F8
....................         delay_ms(10);
00BCE:  MOVLW  0A
00BD0:  MOVWF  x7F
00BD2:  RCALL  05CE
....................         printf("x");
00BD4:  MOVLW  78
00BD6:  BTFSS  F9E.4
00BD8:  BRA    0BD6
00BDA:  MOVWF  FAD
....................         control_left = True;
00BDC:  MOVLW  01
00BDE:  MOVWF  32
.................... 
....................     }
....................     }
00BE0:  BRA    0BFA
.................... 
....................     else
....................     {
.................... 
....................         proxy = False;
00BE2:  CLRF   31
.................... 
....................         if (control_right)
00BE4:  MOVF   33,F
00BE6:  BZ    0BFA
....................         {
....................             lcd_gotoxy(1, 4);
00BE8:  MOVLW  01
00BEA:  MOVWF  x7F
00BEC:  MOVLW  04
00BEE:  MOVWF  x80
00BF0:  RCALL  07B8
....................             lcd_putc(swoff);
00BF2:  MOVLW  02
00BF4:  MOVWF  x7E
00BF6:  RCALL  07F8
....................             control_right = False;
00BF8:  CLRF   33
....................         }
....................     }
.................... 
....................     return proxy;
00BFA:  MOVFF  31,01
00BFE:  RETURN 0
.................... }
.................... 
.................... void distance_measure()
.................... {
....................     comm_counter++;
*
00D06:  INCF   41,F
.................... 
....................     if (step < threshold)
00D08:  MOVF   3B,F
00D0A:  BNZ   0D1A
00D0C:  MOVF   40,W
00D0E:  SUBWF  3A,W
00D10:  BC    0D1A
....................     {
....................         step = threshold - 1;
00D12:  MOVLW  01
00D14:  SUBWF  40,W
00D16:  MOVWF  3A
00D18:  CLRF   3B
....................     }
.................... 
....................     if (comm_counter == 20)
00D1A:  MOVF   41,W
00D1C:  SUBLW  14
00D1E:  BNZ   0D46
....................     { 
....................         int8 step_data = step / 10;
00D20:  MOVFF  3B,79
00D24:  MOVFF  3A,78
00D28:  CLRF   x7B
00D2A:  MOVLW  0A
00D2C:  MOVWF  x7A
00D2E:  RCALL  0C12
00D30:  MOVFF  01,77
....................         printf("q%d", step_data);
00D34:  MOVLW  71
00D36:  BTFSS  F9E.4
00D38:  BRA    0D36
00D3A:  MOVWF  FAD
00D3C:  MOVFF  77,78
00D40:  MOVLW  18
00D42:  MOVWF  x79
00D44:  RCALL  0C54
....................     }
.................... 
....................     if (comm_counter == threshold | step <= threshold) //centered &
00D46:  MOVF   40,W
00D48:  SUBWF  41,W
00D4A:  BZ    0D50
00D4C:  MOVLW  00
00D4E:  BRA    0D52
00D50:  MOVLW  01
00D52:  MOVWF  x78
00D54:  MOVF   3B,F
00D56:  BNZ   0D5E
00D58:  MOVF   3A,W
00D5A:  SUBWF  40,W
00D5C:  BC    0D62
00D5E:  MOVLW  00
00D60:  BRA    0D64
00D62:  MOVLW  01
00D64:  IORWF  x78,W
00D66:  BZ    0DFC
....................     { 
....................         comm_counter = 0;
00D68:  CLRF   41
....................         line1 = (step / threshold);
00D6A:  MOVFF  3B,79
00D6E:  MOVFF  3A,78
00D72:  CLRF   x7B
00D74:  MOVFF  40,7A
00D78:  RCALL  0C12
00D7A:  MOVFF  01,3E
.................... 
....................         if (line1 > 18)
00D7E:  MOVF   3E,W
00D80:  SUBLW  12
00D82:  BC    0D88
....................         {
....................             line1 = 19;
00D84:  MOVLW  13
00D86:  MOVWF  3E
....................         }
.................... 
....................         if (line1 < 2)
00D88:  MOVF   3E,W
00D8A:  SUBLW  01
00D8C:  BNC   0D92
....................         {
....................             line1 = 2;
00D8E:  MOVLW  02
00D90:  MOVWF  3E
....................         }
.................... 
....................         if (line1 < linecheck)
00D92:  MOVF   3F,W
00D94:  SUBWF  3E,W
00D96:  BC    0DEA
....................         {
.................... 
....................             if (line1 == 18)
00D98:  MOVF   3E,W
00D9A:  SUBLW  12
00D9C:  BNZ   0DB8
....................             {
....................                 lcd_gotoxy(19, 4);
00D9E:  MOVLW  13
00DA0:  MOVWF  x7F
00DA2:  MOVLW  04
00DA4:  MOVWF  x80
00DA6:  RCALL  07B8
....................                 lcd_putc(" ");
00DA8:  MOVLW  08
00DAA:  MOVWF  FF6
00DAC:  MOVLW  01
00DAE:  MOVWF  FF7
00DB0:  RCALL  0840
....................                 linecheck = line1;
00DB2:  MOVFF  3E,3F
....................                 return;
00DB6:  BRA    0DFC
....................             }
.................... 
....................             if (line1 == 1)
00DB8:  DECFSZ 3E,W
00DBA:  BRA    0DD6
....................             {
....................                 lcd_gotoxy(2, 4);
00DBC:  MOVLW  02
00DBE:  MOVWF  x7F
00DC0:  MOVLW  04
00DC2:  MOVWF  x80
00DC4:  RCALL  07B8
....................                 lcd_putc(" ");
00DC6:  MOVLW  0A
00DC8:  MOVWF  FF6
00DCA:  MOVLW  01
00DCC:  MOVWF  FF7
00DCE:  RCALL  0840
....................                 linecheck = line1;
00DD0:  MOVFF  3E,3F
....................                 return;
00DD4:  BRA    0DFC
....................             }
.................... 
....................             lcd_gotoxy(line1, 4);
00DD6:  MOVFF  3E,7F
00DDA:  MOVLW  04
00DDC:  MOVWF  x80
00DDE:  RCALL  07B8
....................             lcd_putc("  ");
00DE0:  MOVLW  0C
00DE2:  MOVWF  FF6
00DE4:  MOVLW  01
00DE6:  MOVWF  FF7
00DE8:  RCALL  0840
....................         }
.................... 
....................         lcd_gotoxy(line1, 4);
00DEA:  MOVFF  3E,7F
00DEE:  MOVLW  04
00DF0:  MOVWF  x80
00DF2:  RCALL  07B8
....................         lcd_putc(three_dot);
00DF4:  CLRF   x7E
00DF6:  RCALL  07F8
.................... 
....................         linecheck = line1;
00DF8:  MOVFF  3E,3F
....................     }
00DFC:  RETURN 0
.................... }
.................... 
.................... void normal()
.................... {
....................     dir = 1;
*
00E6E:  MOVLW  01
00E70:  MOVWF  48
....................     enable_interrupts(INT_TIMER1);
00E72:  BSF    F9D.0
....................     distance_measure();
00E74:  RCALL  0D06
....................     disable_interrupts(INT_TIMER1);
00E76:  BCF    F9D.0
00E78:  RETURN 0
.................... 
....................     /*
....................           output_high (A1) ;
....................           output_low (A2) ;
....................           output_low (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_high (A1) ;
....................           output_low (A2) ;
....................           output_high (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_low (A2) ;
....................           output_high (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_high (A2) ;
....................           output_high (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_high (A2) ;
....................           output_low (B1) ;
....................           output_low (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_high (A2) ;
....................           output_low (B1) ;
....................           output_high (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_low (A1) ;
....................           output_low (A2) ;
....................           output_low (B1) ;
....................           output_high (B2) ;
....................           delay_func (loop) ;
.................... 
....................           output_high (A1) ;
....................           output_low (A2) ;
....................           output_low (B1) ;
....................           output_high (B2) ;
....................           delay_func (loop) ;
.................... 
....................           if(center_flag==True){
....................           centercounter=centercounter+1;
....................           }
.................... 
....................           step--;
.................... 
....................       */
.................... }
.................... 
.................... void reverse()
.................... {
....................     dir = 0;
*
00DFE:  CLRF   48
....................     enable_interrupts(INT_TIMER1);
00E00:  BSF    F9D.0
....................     distance_measure();
00E02:  RCALL  0D06
....................     disable_interrupts(INT_TIMER1);
00E04:  BCF    F9D.0
00E06:  RETURN 0
.................... 
....................     /*
....................        output_high (A1);
....................        output_low (A2);
....................        output_low (B1);
....................        output_high (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_low (A2);
....................        output_low (B1);
....................        output_high (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_high (A2);
....................        output_low (B1);
....................        output_high (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_high (A2);
....................        output_low (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_high (A2);
....................        output_high (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_low (A1);
....................        output_low (A2);
....................        output_high (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_high (A1);
....................        output_low (A2);
....................        output_high (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        output_high (A1);
....................        output_low (A2);
....................        output_low (B1);
....................        output_low (B2);
....................        delay_func (loop) ;
.................... 
....................        step++;
....................     */
.................... }
.................... 
.................... char acc_start_normal_man()
.................... {
....................     output_high(pin_d4);
*
0143C:  BCF    F95.4
0143E:  BSF    F8C.4
....................     while (start)
01440:  MOVF   44,F
01442:  BZ    14A4
....................     {   
....................       enable_interrupts(INT_RDA);
01444:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
01446:  MOVLW  0A
01448:  BSF    FD8.0
0144A:  SUBFWB 22,W
0144C:  SUBWF  20,W
0144E:  MOVWF  24
....................         for (int i = 0; i < 10 - accel; i++)
01450:  CLRF   x71
01452:  MOVLW  0A
01454:  BSF    FD8.0
01456:  SUBFWB 22,W
01458:  SUBWF  x71,W
0145A:  BC    1498
....................         {   
....................             enable_interrupts(INT_RDA);
0145C:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
0145E:  CLRF   x72
01460:  MOVF   23,W
01462:  SUBWF  x72,W
01464:  BC    1490
....................             {
....................                enable_interrupts(INT_RDA);
01466:  BSF    F9D.5
....................                 if ( input(button3) | check_right_proxy() ) //!(input(button1)) 
01468:  BSF    F94.3
0146A:  MOVLW  00
0146C:  BTFSC  F82.3
0146E:  MOVLW  01
01470:  MOVWF  x73
01472:  RCALL  0E08
01474:  MOVF   x73,W
01476:  IORWF  01,W
01478:  BZ    1486
....................                 {
....................                     stop();
0147A:  CALL   0C00
....................                     return return_value = False;
0147E:  CLRF   46
01480:  MOVFF  46,01
01484:  BRA    14A8
....................                 }
.................... 
....................                 speed = c;
01486:  MOVFF  24,21
....................                 normal();
0148A:  RCALL  0E6E
0148C:  INCF   x72,F
0148E:  BRA    1460
....................             }
....................             c = c + 1;
01490:  MOVLW  01
01492:  ADDWF  24,F
01494:  INCF   x71,F
01496:  BRA    1452
....................         }
....................         start = False;
01498:  CLRF   44
....................         return return_value = True;
0149A:  MOVLW  01
0149C:  MOVWF  46
0149E:  MOVWF  01
014A0:  BRA    14A8
014A2:  BRA    1440
....................     }
....................     output_low(pin_d4);
014A4:  BCF    F95.4
014A6:  BCF    F8C.4
014A8:  GOTO   2340 (RETURN)
.................... }
.................... 
.................... char acc_start_reverse_man()
.................... {
....................     output_high(pin_d4);
014AC:  BCF    F95.4
014AE:  BSF    F8C.4
....................     while (start == True)
014B0:  DECFSZ 44,W
014B2:  BRA    1516
....................     {
....................          enable_interrupts(INT_RDA);
014B4:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
014B6:  MOVLW  0A
014B8:  BSF    FD8.0
014BA:  SUBFWB 22,W
014BC:  SUBWF  20,W
014BE:  MOVWF  24
....................         for (int i = 0; i < 10 - accel; i++)
014C0:  CLRF   x71
014C2:  MOVLW  0A
014C4:  BSF    FD8.0
014C6:  SUBFWB 22,W
014C8:  SUBWF  x71,W
014CA:  BC    150A
....................         {   
....................             enable_interrupts(INT_RDA);
014CC:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
014CE:  CLRF   x72
014D0:  MOVF   23,W
014D2:  SUBWF  x72,W
014D4:  BC    1502
....................             {
....................                 enable_interrupts(INT_RDA);
014D6:  BSF    F9D.5
....................                 if ( input(button1) | check_left_proxy() ) //!(input(button3))
014D8:  BSF    F95.1
014DA:  MOVLW  00
014DC:  BTFSC  F83.1
014DE:  MOVLW  01
014E0:  MOVWF  x73
014E2:  CALL   0BA8
014E6:  MOVF   x73,W
014E8:  IORWF  01,W
014EA:  BZ    14F8
....................                 {
....................                     stop();
014EC:  CALL   0C00
....................                     return return_value = False;
014F0:  CLRF   46
014F2:  MOVFF  46,01
014F6:  BRA    151A
....................                 }
....................                 speed = c;
014F8:  MOVFF  24,21
....................                 reverse();
014FC:  RCALL  0DFE
014FE:  INCF   x72,F
01500:  BRA    14D0
....................             }
....................             c = c + 1;
01502:  MOVLW  01
01504:  ADDWF  24,F
01506:  INCF   x71,F
01508:  BRA    14C2
....................         }
....................         start = False;
0150A:  CLRF   44
....................         return return_value = True;
0150C:  MOVLW  01
0150E:  MOVWF  46
01510:  MOVWF  01
01512:  BRA    151A
01514:  BRA    14B0
....................     }
....................     output_low(pin_d4);
01516:  BCF    F95.4
01518:  BCF    F8C.4
0151A:  GOTO   23A6 (RETURN)
.................... }
.................... 
.................... char acc_start_normal_auto()
.................... {
....................     while (start == True)
*
013B0:  DECFSZ 44,W
013B2:  BRA    143A
....................     {
....................         enable_interrupts(INT_RDA);
013B4:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
013B6:  MOVLW  0A
013B8:  BSF    FD8.0
013BA:  SUBFWB 22,W
013BC:  SUBWF  20,W
013BE:  MOVWF  24
....................         for (int i = 0; i < 10 - accel; i++)
013C0:  CLRF   x71
013C2:  MOVLW  0A
013C4:  BSF    FD8.0
013C6:  SUBFWB 22,W
013C8:  SUBWF  x71,W
013CA:  BC    142E
....................         {   
....................             enable_interrupts(INT_RDA);
013CC:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
013CE:  CLRF   x72
013D0:  MOVF   23,W
013D2:  SUBWF  x72,W
013D4:  BC    1426
....................             {
....................                 enable_interrupts(INT_RDA);
013D6:  BSF    F9D.5
....................                 if (input(button1) | input(button3) | check_right_proxy() | str[0] != 'l' | str[1] != '1' )
013D8:  BSF    F95.1
013DA:  MOVLW  00
013DC:  BTFSC  F83.1
013DE:  MOVLW  01
013E0:  MOVWF  x73
013E2:  BSF    F94.3
013E4:  MOVLW  00
013E6:  BTFSC  F82.3
013E8:  MOVLW  01
013EA:  IORWF  x73,F
013EC:  RCALL  0E08
013EE:  MOVF   01,W
013F0:  IORWF  x73,F
013F2:  MOVF   29,W
013F4:  SUBLW  6C
013F6:  BNZ   13FC
013F8:  MOVLW  00
013FA:  BRA    13FE
013FC:  MOVLW  01
013FE:  IORWF  x73,F
01400:  MOVF   2A,W
01402:  SUBLW  31
01404:  BNZ   140A
01406:  MOVLW  00
01408:  BRA    140C
0140A:  MOVLW  01
0140C:  IORWF  x73,W
0140E:  BZ    141C
....................                 {
....................                     stop();
01410:  CALL   0C00
....................                     return return_value = False;
01414:  CLRF   46
01416:  MOVFF  46,01
0141A:  BRA    143A
....................                 }
....................                 speed = c;
0141C:  MOVFF  24,21
....................                 normal();
01420:  RCALL  0E6E
01422:  INCF   x72,F
01424:  BRA    13D0
....................             }
....................             c = c + 1;
01426:  MOVLW  01
01428:  ADDWF  24,F
0142A:  INCF   x71,F
0142C:  BRA    13C2
....................         }
....................         start = False;
0142E:  CLRF   44
....................         return return_value = True;
01430:  MOVLW  01
01432:  MOVWF  46
01434:  MOVWF  01
01436:  BRA    143A
01438:  BRA    13B0
....................     }
0143A:  RETURN 0
.................... }
.................... 
.................... char acc_start_reverse_auto()
.................... {
.................... 
....................     while (start == True)
*
0151E:  DECFSZ 44,W
01520:  BRA    15AA
....................     {   
....................         enable_interrupts(INT_RDA);
01522:  BSF    F9D.5
....................         c = abs(delay_s - (10 - accel));
01524:  MOVLW  0A
01526:  BSF    FD8.0
01528:  SUBFWB 22,W
0152A:  SUBWF  20,W
0152C:  MOVWF  24
....................         for (int i = 0; i < 10 - accel; i++)
0152E:  CLRF   x71
01530:  MOVLW  0A
01532:  BSF    FD8.0
01534:  SUBFWB 22,W
01536:  SUBWF  x71,W
01538:  BC    159E
....................         {   
....................             enable_interrupts(INT_RDA);
0153A:  BSF    F9D.5
....................             for (int j = 0; j < accel_value; j++)
0153C:  CLRF   x72
0153E:  MOVF   23,W
01540:  SUBWF  x72,W
01542:  BC    1596
....................             {
....................                 enable_interrupts(INT_RDA);
01544:  BSF    F9D.5
....................                 if (input(button1) == 1 | input(button3) == 1 | check_left_proxy() | str[0] != 'r' | str[1] != '1' )
01546:  BSF    F95.1
01548:  MOVLW  00
0154A:  BTFSC  F83.1
0154C:  MOVLW  01
0154E:  MOVWF  x74
01550:  BSF    F94.3
01552:  MOVLW  00
01554:  BTFSC  F82.3
01556:  MOVLW  01
01558:  IORWF  x74,F
0155A:  CALL   0BA8
0155E:  MOVF   01,W
01560:  IORWF  x74,F
01562:  MOVF   29,W
01564:  SUBLW  72
01566:  BNZ   156C
01568:  MOVLW  00
0156A:  BRA    156E
0156C:  MOVLW  01
0156E:  IORWF  x74,F
01570:  MOVF   2A,W
01572:  SUBLW  31
01574:  BNZ   157A
01576:  MOVLW  00
01578:  BRA    157C
0157A:  MOVLW  01
0157C:  IORWF  x74,W
0157E:  BZ    158C
....................                 {
....................                     stop();
01580:  CALL   0C00
....................                     return return_value = False;
01584:  CLRF   46
01586:  MOVFF  46,01
0158A:  BRA    15AA
....................                 }
....................                 speed = c;
0158C:  MOVFF  24,21
....................                 reverse();
01590:  RCALL  0DFE
01592:  INCF   x72,F
01594:  BRA    153E
....................             }
....................             c = c + 1;
01596:  MOVLW  01
01598:  ADDWF  24,F
0159A:  INCF   x71,F
0159C:  BRA    1530
....................         }
....................         start = False;
0159E:  CLRF   44
....................         return return_value = True;
015A0:  MOVLW  01
015A2:  MOVWF  46
015A4:  MOVWF  01
015A6:  BRA    15AA
015A8:  BRA    151E
....................     }
015AA:  GOTO   2554 (RETURN)
.................... }
.................... 
.................... float read_serial_speed()
.................... {
....................     /*
....................      if (str[0] == 's'){
....................         output_toggle(pin_d4);
.................... 
....................         if (str[1] == '0'){
.................... 
....................            for(int i=0;i<=8;i++){
....................               if(str[2]==array1[i])
....................               {
....................                  delay_s=array2[i];
....................                  break;
....................               }
....................            }
.................... 
....................         }
.................... 
....................         if (str[1] == '1'){
....................            delay_s=10;
....................         }
.................... 
....................      }
.................... 
....................      return delay_s;
....................      */
.................... 
....................     if (str[0] == 'h')
*
00AAC:  MOVF   29,W
00AAE:  SUBLW  68
00AB0:  BNZ   0B20
....................     {
....................         output_toggle(pin_d4);
00AB2:  BCF    F95.4
00AB4:  BTG    F8C.4
....................         if (str[1] == '0')
00AB6:  MOVF   2A,W
00AB8:  SUBLW  30
00ABA:  BNZ   0B16
....................         {
.................... 
....................             if (str[2] == '1')
00ABC:  MOVF   2B,W
00ABE:  SUBLW  31
00AC0:  BNZ   0AC6
....................             {
....................                 delay_s = 1;
00AC2:  MOVLW  01
00AC4:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '2')
00AC6:  MOVF   2B,W
00AC8:  SUBLW  32
00ACA:  BNZ   0AD0
....................             {
....................                 delay_s = 2;
00ACC:  MOVLW  02
00ACE:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '3')
00AD0:  MOVF   2B,W
00AD2:  SUBLW  33
00AD4:  BNZ   0ADA
....................             {
....................                 delay_s = 3;
00AD6:  MOVLW  03
00AD8:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '4')
00ADA:  MOVF   2B,W
00ADC:  SUBLW  34
00ADE:  BNZ   0AE4
....................             {
....................                 delay_s = 4;
00AE0:  MOVLW  04
00AE2:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '5')
00AE4:  MOVF   2B,W
00AE6:  SUBLW  35
00AE8:  BNZ   0AEE
....................             {
....................                 delay_s = 5;
00AEA:  MOVLW  05
00AEC:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '6')
00AEE:  MOVF   2B,W
00AF0:  SUBLW  36
00AF2:  BNZ   0AF8
....................             {
....................                 delay_s = 6;
00AF4:  MOVLW  06
00AF6:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '7')
00AF8:  MOVF   2B,W
00AFA:  SUBLW  37
00AFC:  BNZ   0B02
....................             {
....................                 delay_s = 7;
00AFE:  MOVLW  07
00B00:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '8')
00B02:  MOVF   2B,W
00B04:  SUBLW  38
00B06:  BNZ   0B0C
....................             {
....................                 delay_s = 8;
00B08:  MOVLW  08
00B0A:  MOVWF  20
....................             }
.................... 
....................             if (str[2] == '9')
00B0C:  MOVF   2B,W
00B0E:  SUBLW  39
00B10:  BNZ   0B16
....................             {
....................                 delay_s = 9;
00B12:  MOVLW  09
00B14:  MOVWF  20
....................             }
....................         }
.................... 
....................         if (str[1] == '1')
00B16:  MOVF   2A,W
00B18:  SUBLW  31
00B1A:  BNZ   0B20
....................         {
....................             delay_s = 10;
00B1C:  MOVLW  0A
00B1E:  MOVWF  20
....................         }
....................     }
....................     return delay_s;
00B20:  CLRF   x73
00B22:  MOVFF  20,72
00B26:  RCALL  0A76
00B28:  RETURN 0
.................... }
.................... 
.................... void read_serial_mode()
.................... {
.................... 
....................     if (str[0] == 'm')
*
00A52:  MOVF   29,W
00A54:  SUBLW  6D
00A56:  BNZ   0A74
....................     {
....................         output_toggle(pin_d4);
00A58:  BCF    F95.4
00A5A:  BTG    F8C.4
.................... 
....................         if (str[1] == '0')
00A5C:  MOVF   2A,W
00A5E:  SUBLW  30
00A60:  BNZ   0A68
....................         {
....................             mode_AUTO = False;
00A62:  CLRF   25
....................             mode_manuel = True;
00A64:  MOVLW  01
00A66:  MOVWF  26
....................         }
.................... 
....................         if (str[1] == '1')
00A68:  MOVF   2A,W
00A6A:  SUBLW  31
00A6C:  BNZ   0A74
....................         {
....................             mode_AUTO = True;
00A6E:  MOVLW  01
00A70:  MOVWF  25
....................             mode_manuel = False;
00A72:  CLRF   26
....................         }
....................     }
00A74:  RETURN 0
.................... }
.................... 
.................... float read_serial_acc()
.................... {
.................... 
....................     if (str[0] == 'a')
*
00B2A:  MOVF   29,W
00B2C:  SUBLW  61
00B2E:  BNZ   0B9E
....................     {
....................         output_toggle(pin_d4);
00B30:  BCF    F95.4
00B32:  BTG    F8C.4
....................         if (str[1] == '0')
00B34:  MOVF   2A,W
00B36:  SUBLW  30
00B38:  BNZ   0B94
....................         {
.................... 
....................             if (str[2] == '1')
00B3A:  MOVF   2B,W
00B3C:  SUBLW  31
00B3E:  BNZ   0B44
....................             {
....................                 accel = 1;
00B40:  MOVLW  01
00B42:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '2')
00B44:  MOVF   2B,W
00B46:  SUBLW  32
00B48:  BNZ   0B4E
....................             {
....................                 accel = 2;
00B4A:  MOVLW  02
00B4C:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '3')
00B4E:  MOVF   2B,W
00B50:  SUBLW  33
00B52:  BNZ   0B58
....................             {
....................                 accel = 3;
00B54:  MOVLW  03
00B56:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '4')
00B58:  MOVF   2B,W
00B5A:  SUBLW  34
00B5C:  BNZ   0B62
....................             {
....................                 accel = 4;
00B5E:  MOVLW  04
00B60:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '5')
00B62:  MOVF   2B,W
00B64:  SUBLW  35
00B66:  BNZ   0B6C
....................             {
....................                 accel = 5;
00B68:  MOVLW  05
00B6A:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '6')
00B6C:  MOVF   2B,W
00B6E:  SUBLW  36
00B70:  BNZ   0B76
....................             {
....................                 accel = 6;
00B72:  MOVLW  06
00B74:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '7')
00B76:  MOVF   2B,W
00B78:  SUBLW  37
00B7A:  BNZ   0B80
....................             {
....................                 accel = 7;
00B7C:  MOVLW  07
00B7E:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '8')
00B80:  MOVF   2B,W
00B82:  SUBLW  38
00B84:  BNZ   0B8A
....................             {
....................                 accel = 8;
00B86:  MOVLW  08
00B88:  MOVWF  22
....................             }
.................... 
....................             if (str[2] == '9')
00B8A:  MOVF   2B,W
00B8C:  SUBLW  39
00B8E:  BNZ   0B94
....................             {
....................                 accel = 9;
00B90:  MOVLW  09
00B92:  MOVWF  22
....................             }
....................         }
.................... 
....................         if (str[1] == '1')
00B94:  MOVF   2A,W
00B96:  SUBLW  31
00B98:  BNZ   0B9E
....................         {
....................             accel = 10;
00B9A:  MOVLW  0A
00B9C:  MOVWF  22
....................         }
....................     }
....................     return accel;
00B9E:  CLRF   x73
00BA0:  MOVFF  22,72
00BA4:  RCALL  0A76
00BA6:  RETURN 0
.................... }
.................... 
.................... void centerline(delay)
.................... {     
....................     lcd_gotoxy(13, 1);
*
00E9A:  MOVLW  0D
00E9C:  MOVWF  x7F
00E9E:  MOVLW  01
00EA0:  MOVWF  x80
00EA2:  RCALL  07B8
....................     lcd_putc("<Center>");
00EA4:  MOVLW  10
00EA6:  MOVWF  FF6
00EA8:  MOVLW  01
00EAA:  MOVWF  FF7
00EAC:  RCALL  0840
....................             
....................     last_centercounter=0;
00EAE:  CLRF   43
00EB0:  CLRF   42
....................     lcd_gotoxy(1, 4);
00EB2:  MOVLW  01
00EB4:  MOVWF  x7F
00EB6:  MOVLW  04
00EB8:  MOVWF  x80
00EBA:  RCALL  07B8
....................     lcd_putc(swoff);
00EBC:  MOVLW  02
00EBE:  MOVWF  x7E
00EC0:  RCALL  07F8
....................     lcd_gotoxy(20, 4);
00EC2:  MOVLW  14
00EC4:  MOVWF  x7F
00EC6:  MOVLW  04
00EC8:  MOVWF  x80
00ECA:  RCALL  07B8
....................     lcd_putc(swoff);
00ECC:  MOVLW  02
00ECE:  MOVWF  x7E
00ED0:  RCALL  07F8
....................     lcd_gotoxy(2, 4);
00ED2:  MOVLW  02
00ED4:  MOVWF  x7F
00ED6:  MOVLW  04
00ED8:  MOVWF  x80
00EDA:  RCALL  07B8
....................     //lcd_putc("     Homing...    ");
....................     speed = 6;
00EDC:  MOVLW  06
00EDE:  MOVWF  21
....................     //centered = False;
....................     //centercounter = 0;
.................... 
....................     while (1)
....................     {
....................         enable_interrupts(INT_RDA);
00EE0:  BSF    F9D.5
.................... 
....................         if (check_left_proxy())
00EE2:  RCALL  0BA8
00EE4:  MOVF   01,F
00EE6:  BZ    0EFA
....................         {
....................             stop();
00EE8:  RCALL  0C00
....................             delay_ms(250);
00EEA:  MOVLW  FA
00EEC:  MOVWF  x7F
00EEE:  CALL   05CE
....................             output_toggle(PIN_D4);
00EF2:  BCF    F95.4
00EF4:  BTG    F8C.4
....................             correct = False;
00EF6:  CLRF   2E
.................... 
....................             break;
00EF8:  BRA    0F24
....................         }
.................... 
....................         if (input(button1) | input(button3))
00EFA:  BSF    F95.1
00EFC:  MOVLW  00
00EFE:  BTFSC  F83.1
00F00:  MOVLW  01
00F02:  MOVWF  x75
00F04:  BSF    F94.3
00F06:  MOVLW  00
00F08:  BTFSC  F82.3
00F0A:  MOVLW  01
00F0C:  IORWF  x75,W
00F0E:  BZ    0F20
....................         {
....................             stop();
00F10:  RCALL  0C00
....................             lcd_gotoxy(1, 4);
00F12:  MOVLW  01
00F14:  MOVWF  x7F
00F16:  MOVLW  04
00F18:  MOVWF  x80
00F1A:  RCALL  07B8
....................             centered = False;
00F1C:  CLRF   34
.................... 
....................             return;
00F1E:  BRA    10CC
....................         }
.................... 
....................         reverse();
00F20:  RCALL  0DFE
00F22:  BRA    0EE0
....................     }
.................... 
....................     while (1)
....................     {
....................         enable_interrupts(INT_RDA);
00F24:  BSF    F9D.5
.................... 
....................         center_flag = True;
00F26:  MOVLW  01
00F28:  MOVWF  39
.................... 
....................         if (check_right_proxy())
00F2A:  RCALL  0E08
00F2C:  MOVF   01,F
00F2E:  BZ    0F42
....................         {
....................             stop();
00F30:  RCALL  0C00
....................             delay_ms(250);
00F32:  MOVLW  FA
00F34:  MOVWF  x7F
00F36:  CALL   05CE
....................             correct = False;
00F3A:  CLRF   2E
....................             step = 0;
00F3C:  CLRF   3B
00F3E:  CLRF   3A
....................             break;
00F40:  BRA    0F6C
....................         }
.................... 
....................         if (input(button1) | input(button3))
00F42:  BSF    F95.1
00F44:  MOVLW  00
00F46:  BTFSC  F83.1
00F48:  MOVLW  01
00F4A:  MOVWF  x75
00F4C:  BSF    F94.3
00F4E:  MOVLW  00
00F50:  BTFSC  F82.3
00F52:  MOVLW  01
00F54:  IORWF  x75,W
00F56:  BZ    0F68
....................         {
....................             stop();
00F58:  RCALL  0C00
....................             lcd_gotoxy(1, 4);
00F5A:  MOVLW  01
00F5C:  MOVWF  x7F
00F5E:  MOVLW  04
00F60:  MOVWF  x80
00F62:  RCALL  07B8
....................             centered = False; 
00F64:  CLRF   34
....................             return;
00F66:  BRA    10CC
....................         }
.................... 
....................         normal();
00F68:  RCALL  0E6E
00F6A:  BRA    0F24
.................... 
....................         // printf("data: %s", centercounter);
....................     }
.................... 
....................     while (step < last_centercounter / 2)
00F6C:  BCF    FD8.0
00F6E:  RRCF   43,W
00F70:  MOVWF  03
00F72:  RRCF   42,W
00F74:  MOVWF  02
00F76:  MOVWF  01
00F78:  MOVF   3B,W
00F7A:  SUBWF  03,W
00F7C:  BNC   0FC2
00F7E:  BNZ   0F86
00F80:  MOVF   01,W
00F82:  SUBWF  3A,W
00F84:  BC    0FC2
....................     {
....................         enable_interrupts(INT_RDA);
00F86:  BSF    F9D.5
.................... 
....................         center_flag = False;
00F88:  CLRF   39
....................         CurrentTick = get_ticks();
00F8A:  CALL   0766
00F8E:  MOVFF  03,66
00F92:  MOVFF  02,65
00F96:  MOVFF  01,64
00F9A:  MOVFF  00,63
.................... 
....................         if (input(button1) | input(button3) | check_left_proxy())
00F9E:  BSF    F95.1
00FA0:  MOVLW  00
00FA2:  BTFSC  F83.1
00FA4:  MOVLW  01
00FA6:  MOVWF  x75
00FA8:  BSF    F94.3
00FAA:  MOVLW  00
00FAC:  BTFSC  F82.3
00FAE:  MOVLW  01
00FB0:  IORWF  x75,F
00FB2:  RCALL  0BA8
00FB4:  MOVF   x75,W
00FB6:  IORWF  01,W
00FB8:  BZ    0FBE
....................         {
....................             stop();
00FBA:  RCALL  0C00
....................             return;
00FBC:  BRA    10CC
....................         }
.................... 
....................         reverse();
00FBE:  RCALL  0DFE
00FC0:  BRA    0F6C
....................     }
.................... 
....................     stop();
00FC2:  RCALL  0C00
....................     lcd_putc("\f");
00FC4:  MOVLW  1A
00FC6:  MOVWF  FF6
00FC8:  MOVLW  01
00FCA:  MOVWF  FF7
00FCC:  RCALL  0840
.................... 
....................     lcd_gotoxy(1, 3);
00FCE:  MOVLW  01
00FD0:  MOVWF  x7F
00FD2:  MOVLW  03
00FD4:  MOVWF  x80
00FD6:  CALL   07B8
....................     centercounter = last_centercounter;
00FDA:  MOVFF  43,36
00FDE:  MOVFF  42,35
....................     centercounter=centercounter+3;
00FE2:  MOVLW  03
00FE4:  ADDWF  35,F
00FE6:  MOVLW  00
00FE8:  ADDWFC 36,F
....................     printf(lcd_putc, "count: %Lu", centercounter);
00FEA:  MOVLW  1C
00FEC:  MOVWF  FF6
00FEE:  MOVLW  01
00FF0:  MOVWF  FF7
00FF2:  MOVLW  07
00FF4:  MOVWF  x75
00FF6:  BRA    0E7A
00FF8:  MOVLW  10
00FFA:  MOVWF  FE9
00FFC:  MOVFF  36,76
01000:  MOVFF  35,75
01004:  RCALL  0860
....................     step = centercounter / 2;
01006:  BCF    FD8.0
01008:  RRCF   36,W
0100A:  MOVWF  3B
0100C:  RRCF   35,W
0100E:  MOVWF  3A
....................     centered = True;
01010:  MOVLW  01
01012:  MOVWF  34
....................     center_flag = False;
01014:  CLRF   39
....................     threshold = (centercounter / 20);
01016:  MOVFF  36,79
0101A:  MOVFF  35,78
0101E:  CLRF   x7B
01020:  MOVLW  14
01022:  MOVWF  x7A
01024:  RCALL  0C12
01026:  MOVFF  01,40
....................       
....................     comm_counter = threshold - 1;
0102A:  MOVLW  01
0102C:  SUBWF  40,W
0102E:  MOVWF  41
....................     
....................     printf("t%d", threshold);
01030:  MOVLW  74
01032:  BTFSS  F9E.4
01034:  BRA    1032
01036:  MOVWF  FAD
01038:  MOVFF  40,78
0103C:  MOVLW  18
0103E:  MOVWF  x79
01040:  RCALL  0C54
....................     delay_ms(35);
01042:  MOVLW  23
01044:  MOVWF  x7F
01046:  CALL   05CE
....................     int8 step_data = step / 10;
0104A:  MOVFF  3B,79
0104E:  MOVFF  3A,78
01052:  CLRF   x7B
01054:  MOVLW  0A
01056:  MOVWF  x7A
01058:  RCALL  0C12
0105A:  MOVFF  01,73
....................     printf("q%d", step_data);
0105E:  MOVLW  71
01060:  BTFSS  F9E.4
01062:  BRA    1060
01064:  MOVWF  FAD
01066:  MOVFF  73,78
0106A:  MOVLW  18
0106C:  MOVWF  x79
0106E:  RCALL  0C54
.................... 
....................     line1 = (step / threshold);
01070:  MOVFF  3B,79
01074:  MOVFF  3A,78
01078:  CLRF   x7B
0107A:  MOVFF  40,7A
0107E:  RCALL  0C12
01080:  MOVFF  01,3E
.................... 
....................     lcd_gotoxy(1, 4);
01084:  MOVLW  01
01086:  MOVWF  x7F
01088:  MOVLW  04
0108A:  MOVWF  x80
0108C:  CALL   07B8
....................     lcd_putc(swoff);
01090:  MOVLW  02
01092:  MOVWF  x7E
01094:  CALL   07F8
....................     lcd_gotoxy(20, 4);
01098:  MOVLW  14
0109A:  MOVWF  x7F
0109C:  MOVLW  04
0109E:  MOVWF  x80
010A0:  CALL   07B8
....................     lcd_putc(swoff);
010A4:  MOVLW  02
010A6:  MOVWF  x7E
010A8:  CALL   07F8
.................... 
....................     for (int i = 2; i <= 10; i++)
010AC:  MOVLW  02
010AE:  MOVWF  x74
010B0:  MOVF   x74,W
010B2:  SUBLW  0A
010B4:  BNC   10CC
....................     {
....................         lcd_gotoxy(i, 4);
010B6:  MOVFF  74,7F
010BA:  MOVLW  04
010BC:  MOVWF  x80
010BE:  CALL   07B8
....................         lcd_putc(three_dot);
010C2:  CLRF   x7E
010C4:  CALL   07F8
010C8:  INCF   x74,F
010CA:  BRA    10B0
....................     }
.................... 
....................     return;
010CC:  RETURN 0
.................... }
.................... 
.................... void gogo()
010CE:  MOVLW  01
010D0:  MOVWF  x72
.................... {
....................     char start = True;
.................... 
....................     output_toggle(PIN_D4);
010D2:  BCF    F95.4
010D4:  BTG    F8C.4
.................... 
....................     while (1)
....................     {     
....................         enable_interrupts(INT_RDA);
010D6:  BSF    F9D.5
....................         while (1)
....................         {
....................             enable_interrupts(INT_RDA);
010D8:  BSF    F9D.5
....................             while (start == True)
010DA:  DECFSZ x72,W
010DC:  BRA    1160
....................             {
....................                 enable_interrupts(INT_RDA);
010DE:  BSF    F9D.5
.................... 
....................                 c = abs(delay_s - (10 - accel));
010E0:  MOVLW  0A
010E2:  BSF    FD8.0
010E4:  SUBFWB 22,W
010E6:  SUBWF  20,W
010E8:  MOVWF  24
....................                 for (int i = 0; i < 10 - accel; i++)
010EA:  CLRF   x73
010EC:  MOVLW  0A
010EE:  BSF    FD8.0
010F0:  SUBFWB 22,W
010F2:  SUBWF  x73,W
010F4:  BC    115C
....................                 {    
.................... 
....................                 enable_interrupts(INT_RDA);
010F6:  BSF    F9D.5
....................                 
....................                     for (int j = 0; j < accel_value; j++)
010F8:  CLRF   x74
010FA:  MOVF   23,W
010FC:  SUBWF  x74,W
010FE:  BC    1154
....................                     {
.................... 
....................                 enable_interrupts(INT_RDA);
01100:  BSF    F9D.5
.................... 
....................                         if (input(button1) | input(button3) | input(button4) | str[0]!='g' )
01102:  BSF    F95.1
01104:  MOVLW  00
01106:  BTFSC  F83.1
01108:  MOVLW  01
0110A:  MOVWF  x77
0110C:  BSF    F94.3
0110E:  MOVLW  00
01110:  BTFSC  F82.3
01112:  MOVLW  01
01114:  IORWF  x77,F
01116:  BSF    F94.2
01118:  MOVLW  00
0111A:  BTFSC  F82.2
0111C:  MOVLW  01
0111E:  IORWF  x77,F
01120:  MOVF   29,W
01122:  SUBLW  67
01124:  BNZ   112A
01126:  MOVLW  00
01128:  BRA    112C
0112A:  MOVLW  01
0112C:  IORWF  x77,W
0112E:  BZ    1134
....................                         {
....................                             stop();
01130:  RCALL  0C00
....................                             return;
01132:  BRA    1290
....................                         }
.................... 
....................                         if (check_left_proxy())
01134:  RCALL  0BA8
01136:  MOVF   01,F
01138:  BZ    114A
....................                         {
....................                             start = True;
0113A:  MOVLW  01
0113C:  MOVWF  x72
....................                             stop();
0113E:  RCALL  0C00
....................                             delay_ms(100);
01140:  MOVLW  64
01142:  MOVWF  x7F
01144:  CALL   05CE
....................                             break;
01148:  BRA    1154
....................                         }
....................                         speed = c;
0114A:  MOVFF  24,21
....................                         reverse();
0114E:  RCALL  0DFE
01150:  INCF   x74,F
01152:  BRA    10FA
....................                     }
....................                     c = c + 1;
01154:  MOVLW  01
01156:  ADDWF  24,F
01158:  INCF   x73,F
0115A:  BRA    10EC
....................                 }
....................                 start = False;
0115C:  CLRF   x72
0115E:  BRA    10DA
....................             }
.................... 
....................             if (check_left_proxy())
01160:  RCALL  0BA8
01162:  MOVF   01,F
01164:  BZ    117C
....................             {
....................                 stop();
01166:  RCALL  0C00
....................                 output_toggle(PIN_D4);
01168:  BCF    F95.4
0116A:  BTG    F8C.4
....................                 delay_ms(100);
0116C:  MOVLW  64
0116E:  MOVWF  x7F
01170:  CALL   05CE
....................                 start = True;
01174:  MOVLW  01
01176:  MOVWF  x72
....................                 correct = False;
01178:  CLRF   2E
....................                 break;
0117A:  BRA    11B6
....................             }
.................... 
....................             if (input(button5) | input(button1)  | input(button3) | str[0]!='g' )
0117C:  BSF    F94.1
0117E:  MOVLW  00
01180:  BTFSC  F82.1
01182:  MOVLW  01
01184:  MOVWF  x77
01186:  BSF    F95.1
01188:  MOVLW  00
0118A:  BTFSC  F83.1
0118C:  MOVLW  01
0118E:  IORWF  x77,F
01190:  BSF    F94.3
01192:  MOVLW  00
01194:  BTFSC  F82.3
01196:  MOVLW  01
01198:  IORWF  x77,F
0119A:  MOVF   29,W
0119C:  SUBLW  67
0119E:  BNZ   11A4
011A0:  MOVLW  00
011A2:  BRA    11A6
011A4:  MOVLW  01
011A6:  IORWF  x77,W
011A8:  BZ    11AE
....................             {
....................                 stop();
011AA:  RCALL  0C00
....................                 return;
011AC:  BRA    1290
....................             }
....................             speed = c;
011AE:  MOVFF  24,21
....................             reverse();
011B2:  RCALL  0DFE
011B4:  BRA    10D8
....................         }
.................... 
....................         while (1)
....................         {         
....................             enable_interrupts(INT_RDA);
011B6:  BSF    F9D.5
....................             while (start == True)
011B8:  DECFSZ x72,W
011BA:  BRA    123C
....................             {     
.................... 
....................                 enable_interrupts(INT_RDA);
011BC:  BSF    F9D.5
.................... 
....................                 c = abs(delay_s - (10 - accel));
011BE:  MOVLW  0A
011C0:  BSF    FD8.0
011C2:  SUBFWB 22,W
011C4:  SUBWF  20,W
011C6:  MOVWF  24
....................                 for (int i = 0; i < 10 - accel; i++)
011C8:  CLRF   x75
011CA:  MOVLW  0A
011CC:  BSF    FD8.0
011CE:  SUBFWB 22,W
011D0:  SUBWF  x75,W
011D2:  BC    1238
....................                 {    
.................... 
....................                 enable_interrupts(INT_RDA);
011D4:  BSF    F9D.5
.................... 
....................                     for (int j = 0; j < accel_value; j++)
011D6:  CLRF   x76
011D8:  MOVF   23,W
011DA:  SUBWF  x76,W
011DC:  BC    1230
....................                     {      
.................... 
....................                 enable_interrupts(INT_RDA);
011DE:  BSF    F9D.5
.................... 
....................                         if (input(button1) | input(button3) | str[0]!='g' )
011E0:  BSF    F95.1
011E2:  MOVLW  00
011E4:  BTFSC  F83.1
011E6:  MOVLW  01
011E8:  MOVWF  x77
011EA:  BSF    F94.3
011EC:  MOVLW  00
011EE:  BTFSC  F82.3
011F0:  MOVLW  01
011F2:  IORWF  x77,F
011F4:  MOVF   29,W
011F6:  SUBLW  67
011F8:  BNZ   11FE
011FA:  MOVLW  00
011FC:  BRA    1200
011FE:  MOVLW  01
01200:  IORWF  x77,W
01202:  BZ    1208
....................                         {
....................                             stop();
01204:  RCALL  0C00
....................                             return;
01206:  BRA    1290
....................                         }
.................... 
....................                         if (check_right_proxy())
01208:  RCALL  0E08
0120A:  MOVF   01,F
0120C:  BZ    1226
....................                         {
....................                             start = True;
0120E:  MOVLW  01
01210:  MOVWF  x72
....................                             stop();
01212:  RCALL  0C00
....................                             delay_ms(500);
01214:  MOVLW  02
01216:  MOVWF  x77
01218:  MOVLW  FA
0121A:  MOVWF  x7F
0121C:  CALL   05CE
01220:  DECFSZ x77,F
01222:  BRA    1218
....................                             break;
01224:  BRA    1230
....................                         }
....................                         speed = c;
01226:  MOVFF  24,21
....................                         normal();
0122A:  RCALL  0E6E
0122C:  INCF   x76,F
0122E:  BRA    11D8
....................                     }
....................                     c = c + 1;
01230:  MOVLW  01
01232:  ADDWF  24,F
01234:  INCF   x75,F
01236:  BRA    11CA
....................                 }
....................                 start = False;
01238:  CLRF   x72
0123A:  BRA    11B8
....................             }
.................... 
....................             if (check_right_proxy())
0123C:  RCALL  0E08
0123E:  MOVF   01,F
01240:  BZ    1254
....................             {
....................                 stop();
01242:  RCALL  0C00
....................                 delay_ms(100);
01244:  MOVLW  64
01246:  MOVWF  x7F
01248:  CALL   05CE
....................                 start = True;
0124C:  MOVLW  01
0124E:  MOVWF  x72
....................                 correct = False;
01250:  CLRF   2E
....................                 break;
01252:  BRA    128E
....................             }
.................... 
....................             if (input(button5) | input(button1) | input(button3) | str[0]!='g' )
01254:  BSF    F94.1
01256:  MOVLW  00
01258:  BTFSC  F82.1
0125A:  MOVLW  01
0125C:  MOVWF  x77
0125E:  BSF    F95.1
01260:  MOVLW  00
01262:  BTFSC  F83.1
01264:  MOVLW  01
01266:  IORWF  x77,F
01268:  BSF    F94.3
0126A:  MOVLW  00
0126C:  BTFSC  F82.3
0126E:  MOVLW  01
01270:  IORWF  x77,F
01272:  MOVF   29,W
01274:  SUBLW  67
01276:  BNZ   127C
01278:  MOVLW  00
0127A:  BRA    127E
0127C:  MOVLW  01
0127E:  IORWF  x77,W
01280:  BZ    1286
....................             {
....................                 stop();
01282:  RCALL  0C00
....................                 return;
01284:  BRA    1290
....................             }
.................... 
....................             speed = c;
01286:  MOVFF  24,21
....................             normal();
0128A:  RCALL  0E6E
0128C:  BRA    11B6
....................         }
0128E:  BRA    10D6
....................     }
01290:  RETURN 0
.................... }
.................... 
.................... void seri_check(){
.................... 
.................... enable_interrupts(INT_RDA);
01292:  BSF    F9D.5
.................... 
.................... if(correct){
01294:  MOVF   2E,F
01296:  BTFSC  FD8.2
01298:  BRA    138A
....................       enable_interrupts(INT_RDA);
0129A:  BSF    F9D.5
....................       
....................       read_serial_mode();
0129C:  CALL   0A52
....................       read_serial_speed();
012A0:  RCALL  0AAC
....................       read_serial_acc();
012A2:  RCALL  0B2A
.................... 
....................       if (str[0] == 'c')
012A4:  MOVF   29,W
012A6:  SUBLW  63
012A8:  BNZ   12B0
....................       {
....................           centerline(6);
012AA:  MOVLW  06
012AC:  MOVWF  x72
012AE:  RCALL  0E9A
....................       }
.................... 
....................       if (str[0] == 'g')
012B0:  MOVF   29,W
012B2:  SUBLW  67
012B4:  BNZ   12B8
....................       {
....................           gogo();
012B6:  RCALL  10CE
....................       }
.................... 
....................       if (str[0] == 'd')// usb connected, send commands to pc
012B8:  MOVF   29,W
012BA:  SUBLW  64
012BC:  BNZ   138A
....................       { 
....................           printf("x");
012BE:  MOVLW  78
012C0:  BTFSS  F9E.4
012C2:  BRA    12C0
012C4:  MOVWF  FAD
....................           delay_ms(50);
012C6:  MOVLW  32
012C8:  MOVWF  x7F
012CA:  CALL   05CE
....................           printf("h0%d", delay_s);
012CE:  MOVLW  68
012D0:  BTFSS  F9E.4
012D2:  BRA    12D0
012D4:  MOVWF  FAD
012D6:  MOVLW  30
012D8:  BTFSS  F9E.4
012DA:  BRA    12D8
012DC:  MOVWF  FAD
012DE:  MOVFF  20,78
012E2:  MOVLW  18
012E4:  MOVWF  x79
012E6:  RCALL  0C54
....................           delay_ms(50);
012E8:  MOVLW  32
012EA:  MOVWF  x7F
012EC:  CALL   05CE
....................           printf("a0%d", accel);
012F0:  MOVLW  61
012F2:  BTFSS  F9E.4
012F4:  BRA    12F2
012F6:  MOVWF  FAD
012F8:  MOVLW  30
012FA:  BTFSS  F9E.4
012FC:  BRA    12FA
012FE:  MOVWF  FAD
01300:  MOVFF  22,78
01304:  MOVLW  18
01306:  MOVWF  x79
01308:  RCALL  0C54
....................           delay_ms(50);
0130A:  MOVLW  32
0130C:  MOVWF  x7F
0130E:  CALL   05CE
.................... 
....................           if (mode_manuel)
01312:  MOVF   26,F
01314:  BZ    1326
....................           {
....................               printf("m0");
01316:  MOVLW  6D
01318:  BTFSS  F9E.4
0131A:  BRA    1318
0131C:  MOVWF  FAD
0131E:  MOVLW  30
01320:  BTFSS  F9E.4
01322:  BRA    1320
01324:  MOVWF  FAD
....................           }
.................... 
....................           if (mode_auto)
01326:  MOVF   25,F
01328:  BZ    133A
....................           {
....................               printf("m1");
0132A:  MOVLW  6D
0132C:  BTFSS  F9E.4
0132E:  BRA    132C
01330:  MOVWF  FAD
01332:  MOVLW  31
01334:  BTFSS  F9E.4
01336:  BRA    1334
01338:  MOVWF  FAD
....................           }
.................... 
....................           delay_ms(50);
0133A:  MOVLW  32
0133C:  MOVWF  x7F
0133E:  CALL   05CE
.................... 
....................           if (centered)
01342:  MOVF   34,F
01344:  BZ    1358
....................           {
....................               printf("t%d", threshold);
01346:  MOVLW  74
01348:  BTFSS  F9E.4
0134A:  BRA    1348
0134C:  MOVWF  FAD
0134E:  MOVFF  40,78
01352:  MOVLW  18
01354:  MOVWF  x79
01356:  RCALL  0C54
....................           }
.................... 
....................           delay_ms(50);
01358:  MOVLW  32
0135A:  MOVWF  x7F
0135C:  CALL   05CE
....................           int8 step_data = step / 10;
01360:  MOVFF  3B,79
01364:  MOVFF  3A,78
01368:  CLRF   x7B
0136A:  MOVLW  0A
0136C:  MOVWF  x7A
0136E:  RCALL  0C12
01370:  MOVFF  01,71
....................           printf("q%d", step_data);
01374:  MOVLW  71
01376:  BTFSS  F9E.4
01378:  BRA    1376
0137A:  MOVWF  FAD
0137C:  MOVFF  71,78
01380:  MOVLW  18
01382:  MOVWF  x79
01384:  RCALL  0C54
....................           
....................           str[0]='0';
01386:  MOVLW  30
01388:  MOVWF  29
....................       }
.................... }
0138A:  GOTO   1C18 (RETURN)
.................... }
.................... 
.................... #INT_RDA fast
.................... void serial_comm()
.................... {
....................     disable_interrupts(int_rda);
*
00128:  BCF    F9D.5
....................     // lcd_putc ("data received: ") ;
....................     data = getc();
0012A:  BTFSS  F9E.5
0012C:  BRA    012A
0012E:  MOVFF  FAE,28
....................     //printf(data);
....................     // lcd_putc (data) ;
....................     str[counter] = data;
00132:  CLRF   03
00134:  MOVF   2D,W
00136:  ADDLW  29
00138:  MOVWF  FE9
0013A:  MOVLW  00
0013C:  ADDWFC 03,W
0013E:  MOVWF  FEA
00140:  MOVFF  28,FEF
....................     // lcd_putc (str[counter]) ;
....................     counter++;
00144:  INCF   2D,F
....................     // lcd_putc (str[counter]) ;
....................     if (data == '!')
00146:  MOVF   28,W
00148:  SUBLW  21
0014A:  BNZ   0156
....................     {
....................         /*
....................             lcd_putc ("Data: ");
....................             for (int i = 0; i < counter - 1; i++)
....................             {
....................                lcd_putc (str[i]);
....................             }
....................         */
....................         counter = 0;
0014C:  CLRF   2D
....................         correct = True;
0014E:  MOVLW  01
00150:  MOVWF  2E
....................         output_toggle (PIN_D4);
00152:  BCF    F95.4
00154:  BTG    F8C.4
....................         // printf("OK");
.................... 
....................         // lcd_putc ('\f');
....................     }
....................     
00156:  BCF    F9E.5
00158:  RETFIE 1
.................... }
.................... 
.................... ////////////////////////////////////////
.................... 
.................... const int8 lcd_custom_chars[] =
....................     {
.................... 
....................         // Char Number 0 -- THREE
....................         0x00,
....................         0x00,
....................         0x15,
....................         0x15,
....................         0x15,
....................         0x15,
....................         0x15,
....................         0x00,
.................... 
....................         // Char Number 1 -- SW on
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
....................         0x1F,
.................... 
....................         // 2  Sw off
.................... 
....................         0x1F,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x11,
....................         0x1F
.................... 
.................... };
.................... void lcd_load_custom_chars()
.................... {
....................     int8 i;
.................... 
....................     // Set address counter pointing to CGRAM address 0.
....................     lcd_send_byte(0, 0x40);
*
00734:  CLRF   x83
00736:  MOVLW  40
00738:  MOVWF  x84
0073A:  RCALL  06A0
.................... 
....................     // Load custom lcd character data into CGRAM.
....................     // It can only hold a maximum of 8 custom characters.
....................     for (i = 0; i < sizeof(lcd_custom_chars); i++)
0073C:  CLRF   x71
0073E:  MOVF   x71,W
00740:  SUBLW  17
00742:  BNC   075A
....................     {
....................         lcd_send_byte(1, lcd_custom_chars[i]);
00744:  CLRF   03
00746:  MOVF   x71,W
00748:  RCALL  00DE
0074A:  MOVWF  x72
0074C:  MOVLW  01
0074E:  MOVWF  x83
00750:  MOVFF  72,84
00754:  RCALL  06A0
00756:  INCF   x71,F
00758:  BRA    073E
....................     }
.................... 
....................     // Set address counter pointing back to the DDRAM.
....................     lcd_send_byte(0, 0x80);
0075A:  CLRF   x83
0075C:  MOVLW  80
0075E:  MOVWF  x84
00760:  RCALL  06A0
00762:  GOTO   16C4 (RETURN)
.................... }
.................... 
.................... #int_timer1
.................... void Timer1_isr(void)
.................... {
....................     // output_toggle(PIN_D4);
.................... 
....................     if (dir == 0)
*
001A2:  MOVF   48,F
001A4:  BNZ   0272
....................     {
....................         delay_func(speed);
001A6:  MOVFF  21,88
001AA:  RCALL  017A
....................         output_high(A1);
001AC:  BCF    F95.2
001AE:  BSF    F8C.2
....................         output_low(A2);
001B0:  BCF    F93.1
001B2:  BCF    F8A.1
....................         output_low(B1);
001B4:  BCF    F93.0
001B6:  BCF    F8A.0
....................         output_high(B2);
001B8:  BCF    F94.5
001BA:  BSF    F8B.5
....................         delay_func(speed);
001BC:  MOVFF  21,88
001C0:  RCALL  017A
.................... 
....................         output_low(A1);
001C2:  BCF    F95.2
001C4:  BCF    F8C.2
....................         output_low(A2);
001C6:  BCF    F93.1
001C8:  BCF    F8A.1
....................         output_low(B1);
001CA:  BCF    F93.0
001CC:  BCF    F8A.0
....................         output_high(B2);
001CE:  BCF    F94.5
001D0:  BSF    F8B.5
....................         delay_func(speed);
001D2:  MOVFF  21,88
001D6:  RCALL  017A
.................... 
....................         output_low(A1);
001D8:  BCF    F95.2
001DA:  BCF    F8C.2
....................         output_high(A2);
001DC:  BCF    F93.1
001DE:  BSF    F8A.1
....................         output_low(B1);
001E0:  BCF    F93.0
001E2:  BCF    F8A.0
....................         output_high(B2);
001E4:  BCF    F94.5
001E6:  BSF    F8B.5
....................         delay_func(speed);
001E8:  MOVFF  21,88
001EC:  RCALL  017A
.................... 
....................         output_low(A1);
001EE:  BCF    F95.2
001F0:  BCF    F8C.2
....................         output_high(A2);
001F2:  BCF    F93.1
001F4:  BSF    F8A.1
....................         output_low(B1);
001F6:  BCF    F93.0
001F8:  BCF    F8A.0
....................         output_low(B2);
001FA:  BCF    F94.5
001FC:  BCF    F8B.5
....................         delay_func(speed);
001FE:  MOVFF  21,88
00202:  RCALL  017A
.................... 
....................         output_low(A1);
00204:  BCF    F95.2
00206:  BCF    F8C.2
....................         output_high(A2);
00208:  BCF    F93.1
0020A:  BSF    F8A.1
....................         output_high(B1);
0020C:  BCF    F93.0
0020E:  BSF    F8A.0
....................         output_low(B2);
00210:  BCF    F94.5
00212:  BCF    F8B.5
....................         delay_func(speed);
00214:  MOVFF  21,88
00218:  RCALL  017A
.................... 
....................         output_low(A1);
0021A:  BCF    F95.2
0021C:  BCF    F8C.2
....................         output_low(A2);
0021E:  BCF    F93.1
00220:  BCF    F8A.1
....................         output_high(B1);
00222:  BCF    F93.0
00224:  BSF    F8A.0
....................         output_low(B2);
00226:  BCF    F94.5
00228:  BCF    F8B.5
....................         delay_func(speed);
0022A:  MOVFF  21,88
0022E:  RCALL  017A
.................... 
....................         output_high(A1);
00230:  BCF    F95.2
00232:  BSF    F8C.2
....................         output_low(A2);
00234:  BCF    F93.1
00236:  BCF    F8A.1
....................         output_high(B1);
00238:  BCF    F93.0
0023A:  BSF    F8A.0
....................         output_low(B2);
0023C:  BCF    F94.5
0023E:  BCF    F8B.5
....................         delay_func(speed);
00240:  MOVFF  21,88
00244:  RCALL  017A
.................... 
....................         output_high(A1);
00246:  BCF    F95.2
00248:  BSF    F8C.2
....................         output_low(A2);
0024A:  BCF    F93.1
0024C:  BCF    F8A.1
....................         output_low(B1);
0024E:  BCF    F93.0
00250:  BCF    F8A.0
....................         output_low(B2);
00252:  BCF    F94.5
00254:  BCF    F8B.5
.................... 
....................         step++;
00256:  INCF   3A,F
00258:  BTFSC  FD8.2
0025A:  INCF   3B,F
....................       
....................         if (step > centercounter)
0025C:  MOVF   36,W
0025E:  SUBWF  3B,W
00260:  BNC   0272
00262:  BNZ   026A
00264:  MOVF   3A,W
00266:  SUBWF  35,W
00268:  BC    0272
....................         {
....................             step = centercounter;
0026A:  MOVFF  36,3B
0026E:  MOVFF  35,3A
....................         }
....................         
....................     }
....................     if (dir == 1)
00272:  DECFSZ 48,W
00274:  BRA    0338
....................     {
....................         delay_func(speed);
00276:  MOVFF  21,88
0027A:  RCALL  017A
....................         output_high(A1);
0027C:  BCF    F95.2
0027E:  BSF    F8C.2
....................         output_low(A2);
00280:  BCF    F93.1
00282:  BCF    F8A.1
....................         output_low(B1);
00284:  BCF    F93.0
00286:  BCF    F8A.0
....................         output_low(B2);
00288:  BCF    F94.5
0028A:  BCF    F8B.5
....................         delay_func(speed);
0028C:  MOVFF  21,88
00290:  RCALL  017A
.................... 
....................         output_high(A1);
00292:  BCF    F95.2
00294:  BSF    F8C.2
....................         output_low(A2);
00296:  BCF    F93.1
00298:  BCF    F8A.1
....................         output_high(B1);
0029A:  BCF    F93.0
0029C:  BSF    F8A.0
....................         output_low(B2);
0029E:  BCF    F94.5
002A0:  BCF    F8B.5
....................         delay_func(speed);
002A2:  MOVFF  21,88
002A6:  RCALL  017A
.................... 
....................         output_low(A1);
002A8:  BCF    F95.2
002AA:  BCF    F8C.2
....................         output_low(A2);
002AC:  BCF    F93.1
002AE:  BCF    F8A.1
....................         output_high(B1);
002B0:  BCF    F93.0
002B2:  BSF    F8A.0
....................         output_low(B2);
002B4:  BCF    F94.5
002B6:  BCF    F8B.5
....................         delay_func(speed);
002B8:  MOVFF  21,88
002BC:  RCALL  017A
.................... 
....................         output_low(A1);
002BE:  BCF    F95.2
002C0:  BCF    F8C.2
....................         output_high(A2);
002C2:  BCF    F93.1
002C4:  BSF    F8A.1
....................         output_high(B1);
002C6:  BCF    F93.0
002C8:  BSF    F8A.0
....................         output_low(B2);
002CA:  BCF    F94.5
002CC:  BCF    F8B.5
....................         delay_func(speed);
002CE:  MOVFF  21,88
002D2:  RCALL  017A
.................... 
....................         output_low(A1);
002D4:  BCF    F95.2
002D6:  BCF    F8C.2
....................         output_high(A2);
002D8:  BCF    F93.1
002DA:  BSF    F8A.1
....................         output_low(B1);
002DC:  BCF    F93.0
002DE:  BCF    F8A.0
....................         output_low(B2);
002E0:  BCF    F94.5
002E2:  BCF    F8B.5
....................         delay_func(speed);
002E4:  MOVFF  21,88
002E8:  RCALL  017A
.................... 
....................         output_low(A1);
002EA:  BCF    F95.2
002EC:  BCF    F8C.2
....................         output_high(A2);
002EE:  BCF    F93.1
002F0:  BSF    F8A.1
....................         output_low(B1);
002F2:  BCF    F93.0
002F4:  BCF    F8A.0
....................         output_high(B2);
002F6:  BCF    F94.5
002F8:  BSF    F8B.5
....................         delay_func(speed);
002FA:  MOVFF  21,88
002FE:  RCALL  017A
.................... 
....................         output_low(A1);
00300:  BCF    F95.2
00302:  BCF    F8C.2
....................         output_low(A2);
00304:  BCF    F93.1
00306:  BCF    F8A.1
....................         output_low(B1);
00308:  BCF    F93.0
0030A:  BCF    F8A.0
....................         output_high(B2);
0030C:  BCF    F94.5
0030E:  BSF    F8B.5
....................         delay_func(speed);
00310:  MOVFF  21,88
00314:  RCALL  017A
.................... 
....................         output_high(A1);
00316:  BCF    F95.2
00318:  BSF    F8C.2
....................         output_low(A2);
0031A:  BCF    F93.1
0031C:  BCF    F8A.1
....................         output_low(B1);
0031E:  BCF    F93.0
00320:  BCF    F8A.0
....................         output_high(B2);
00322:  BCF    F94.5
00324:  BSF    F8B.5
.................... 
....................         step--;
00326:  MOVF   3A,W
00328:  BTFSC  FD8.2
0032A:  DECF   3B,F
0032C:  DECF   3A,F
.................... 
....................         if (center_flag)
0032E:  MOVF   39,F
00330:  BZ    0338
....................         {
....................             last_centercounter++;
00332:  INCF   42,F
00334:  BTFSC  FD8.2
00336:  INCF   43,F
....................         }
....................     }
.................... 
....................     set_timer1(65486);
00338:  SETF   FCF
0033A:  MOVLW  CE
0033C:  MOVWF  FCE
....................     //restart_wdt();
....................     clear_interrupt(INT_TIMER1);
0033E:  BCF    F9E.0
....................     // disable_interrupts(INT_TIMER1);
.................... }
.................... 
00340:  BCF    F9E.0
00342:  GOTO   007C
.................... #INT_HLVD
.................... void LOWVOLT_isr(void)
.................... {
....................     disable_interrupts(INT_TIMER1);
00346:  BCF    F9D.0
....................     disable_interrupts(INT_RDA);
00348:  BCF    F9D.5
.................... 
....................     write_eeprom(1, delay_s);  // speed
0034A:  MOVF   FF2,W
0034C:  MOVWF  00
0034E:  BCF    FF2.7
00350:  CLRF   FAA
00352:  MOVLW  01
00354:  MOVWF  FA9
00356:  MOVFF  20,FA8
0035A:  BCF    FA6.6
0035C:  BCF    FA6.7
0035E:  BSF    FA6.2
00360:  MOVLB  F
00362:  MOVLW  55
00364:  MOVWF  FA7
00366:  MOVLW  AA
00368:  MOVWF  FA7
0036A:  BSF    FA6.1
0036C:  BTFSC  FA6.1
0036E:  BRA    036C
00370:  BCF    FA6.2
00372:  MOVF   00,W
00374:  IORWF  FF2,F
....................     write_eeprom(2, accel);    // accel
00376:  MOVFF  FF2,00
0037A:  BCF    FF2.7
0037C:  CLRF   FAA
0037E:  MOVLW  02
00380:  MOVWF  FA9
00382:  MOVFF  22,FA8
00386:  BCF    FA6.6
00388:  BCF    FA6.7
0038A:  BSF    FA6.2
0038C:  MOVLW  55
0038E:  MOVWF  FA7
00390:  MOVLW  AA
00392:  MOVWF  FA7
00394:  BSF    FA6.1
00396:  BTFSC  FA6.1
00398:  BRA    0396
0039A:  BCF    FA6.2
0039C:  MOVF   00,W
0039E:  IORWF  FF2,F
....................     write_eeprom(3, centered); // centered?
003A0:  MOVFF  FF2,00
003A4:  BCF    FF2.7
003A6:  CLRF   FAA
003A8:  MOVLW  03
003AA:  MOVWF  FA9
003AC:  MOVFF  34,FA8
003B0:  BCF    FA6.6
003B2:  BCF    FA6.7
003B4:  BSF    FA6.2
003B6:  MOVLW  55
003B8:  MOVWF  FA7
003BA:  MOVLW  AA
003BC:  MOVWF  FA7
003BE:  BSF    FA6.1
003C0:  BTFSC  FA6.1
003C2:  BRA    03C0
003C4:  BCF    FA6.2
003C6:  MOVF   00,W
003C8:  IORWF  FF2,F
.................... 
....................     step1 = make8(step, 0);
003CA:  MOVFF  3A,3C
....................     step2 = make8(step, 1);
003CE:  MOVFF  3B,3D
....................     write_eeprom(4, step1); // pos1
003D2:  MOVFF  FF2,00
003D6:  BCF    FF2.7
003D8:  CLRF   FAA
003DA:  MOVLW  04
003DC:  MOVWF  FA9
003DE:  MOVFF  3C,FA8
003E2:  BCF    FA6.6
003E4:  BCF    FA6.7
003E6:  BSF    FA6.2
003E8:  MOVLW  55
003EA:  MOVWF  FA7
003EC:  MOVLW  AA
003EE:  MOVWF  FA7
003F0:  BSF    FA6.1
003F2:  BTFSC  FA6.1
003F4:  BRA    03F2
003F6:  BCF    FA6.2
003F8:  MOVF   00,W
003FA:  IORWF  FF2,F
....................     write_eeprom(5, step2); // pos2
003FC:  MOVFF  FF2,00
00400:  BCF    FF2.7
00402:  CLRF   FAA
00404:  MOVLW  05
00406:  MOVWF  FA9
00408:  MOVFF  3D,FA8
0040C:  BCF    FA6.6
0040E:  BCF    FA6.7
00410:  BSF    FA6.2
00412:  MOVLW  55
00414:  MOVWF  FA7
00416:  MOVLW  AA
00418:  MOVWF  FA7
0041A:  BSF    FA6.1
0041C:  BTFSC  FA6.1
0041E:  BRA    041C
00420:  BCF    FA6.2
00422:  MOVF   00,W
00424:  IORWF  FF2,F
.................... 
....................     write_eeprom(6, threshold); // threshold
00426:  MOVFF  FF2,00
0042A:  BCF    FF2.7
0042C:  CLRF   FAA
0042E:  MOVLW  06
00430:  MOVWF  FA9
00432:  MOVFF  40,FA8
00436:  BCF    FA6.6
00438:  BCF    FA6.7
0043A:  BSF    FA6.2
0043C:  MOVLW  55
0043E:  MOVWF  FA7
00440:  MOVLW  AA
00442:  MOVWF  FA7
00444:  BSF    FA6.1
00446:  BTFSC  FA6.1
00448:  BRA    0446
0044A:  BCF    FA6.2
0044C:  MOVF   00,W
0044E:  IORWF  FF2,F
.................... 
....................     cc1 = make8(centercounter, 0);
00450:  MOVFF  35,37
....................     cc2 = make8(centercounter, 1);
00454:  MOVFF  36,38
....................     write_eeprom(7, cc1); // cc1
00458:  MOVFF  FF2,00
0045C:  BCF    FF2.7
0045E:  CLRF   FAA
00460:  MOVLW  07
00462:  MOVWF  FA9
00464:  MOVFF  37,FA8
00468:  BCF    FA6.6
0046A:  BCF    FA6.7
0046C:  BSF    FA6.2
0046E:  MOVLW  55
00470:  MOVWF  FA7
00472:  MOVLW  AA
00474:  MOVWF  FA7
00476:  BSF    FA6.1
00478:  BTFSC  FA6.1
0047A:  BRA    0478
0047C:  BCF    FA6.2
0047E:  MOVF   00,W
00480:  IORWF  FF2,F
....................     write_eeprom(8, cc2); // cc2
00482:  MOVFF  FF2,00
00486:  BCF    FF2.7
00488:  CLRF   FAA
0048A:  MOVLW  08
0048C:  MOVWF  FA9
0048E:  MOVFF  38,FA8
00492:  BCF    FA6.6
00494:  BCF    FA6.7
00496:  BSF    FA6.2
00498:  MOVLW  55
0049A:  MOVWF  FA7
0049C:  MOVLW  AA
0049E:  MOVWF  FA7
004A0:  BSF    FA6.1
004A2:  BTFSC  FA6.1
004A4:  BRA    04A2
004A6:  BCF    FA6.2
004A8:  MOVF   00,W
004AA:  IORWF  FF2,F
.................... 
....................     write_eeprom(9, line1);
004AC:  MOVFF  FF2,00
004B0:  BCF    FF2.7
004B2:  CLRF   FAA
004B4:  MOVLW  09
004B6:  MOVWF  FA9
004B8:  MOVFF  3E,FA8
004BC:  BCF    FA6.6
004BE:  BCF    FA6.7
004C0:  BSF    FA6.2
004C2:  MOVLW  55
004C4:  MOVWF  FA7
004C6:  MOVLW  AA
004C8:  MOVWF  FA7
004CA:  BSF    FA6.1
004CC:  BTFSC  FA6.1
004CE:  BRA    04CC
004D0:  BCF    FA6.2
004D2:  MOVF   00,W
004D4:  IORWF  FF2,F
.................... 
....................     write_eeprom(10, control_right);
004D6:  MOVFF  FF2,00
004DA:  BCF    FF2.7
004DC:  CLRF   FAA
004DE:  MOVLW  0A
004E0:  MOVWF  FA9
004E2:  MOVFF  33,FA8
004E6:  BCF    FA6.6
004E8:  BCF    FA6.7
004EA:  BSF    FA6.2
004EC:  MOVLW  55
004EE:  MOVWF  FA7
004F0:  MOVLW  AA
004F2:  MOVWF  FA7
004F4:  BSF    FA6.1
004F6:  BTFSC  FA6.1
004F8:  BRA    04F6
004FA:  BCF    FA6.2
004FC:  MOVF   00,W
004FE:  IORWF  FF2,F
....................     write_eeprom(11, control_left);
00500:  MOVFF  FF2,00
00504:  BCF    FF2.7
00506:  CLRF   FAA
00508:  MOVLW  0B
0050A:  MOVWF  FA9
0050C:  MOVFF  32,FA8
00510:  BCF    FA6.6
00512:  BCF    FA6.7
00514:  BSF    FA6.2
00516:  MOVLW  55
00518:  MOVWF  FA7
0051A:  MOVLW  AA
0051C:  MOVWF  FA7
0051E:  BSF    FA6.1
00520:  BTFSC  FA6.1
00522:  BRA    0520
00524:  BCF    FA6.2
00526:  MOVF   00,W
00528:  IORWF  FF2,F
.................... 
....................     output_high(pin_b7);
0052A:  BCF    F93.7
0052C:  BSF    F8A.7
....................     output_low(pin_b7);
0052E:  BCF    F93.7
00530:  BCF    F8A.7
....................     output_high(pin_b7);
00532:  BCF    F93.7
00534:  BSF    F8A.7
....................     output_low(pin_b7);
00536:  BCF    F93.7
00538:  BCF    F8A.7
....................     output_high(pin_b7);
0053A:  BCF    F93.7
0053C:  BSF    F8A.7
....................     output_low(pin_b7);
0053E:  BCF    F93.7
00540:  BCF    F8A.7
....................     output_high(pin_b7);
00542:  BCF    F93.7
00544:  BSF    F8A.7
....................     output_low(pin_b7);
00546:  BCF    F93.7
00548:  BCF    F8A.7
.................... 
....................     disable_interrupts(INT_HLVD);
0054A:  BCF    FA0.2
0054C:  BCF    FA1.2
0054E:  MOVLB  0
00550:  GOTO   007C
.................... }
.................... 
.................... void main()
*
015AE:  CLRF   FF8
015B0:  BCF    F9F.0
015B2:  BSF    F9F.5
015B4:  BCF    FA2.2
015B6:  BSF    FD0.7
015B8:  BSF    07.7
015BA:  MOVLW  70
015BC:  MOVWF  FD3
015BE:  BSF    F9B.6
015C0:  BCF    F9B.7
015C2:  CLRF   1C
015C4:  CLRF   1B
015C6:  CLRF   1A
015C8:  CLRF   19
015CA:  BCF    FD5.7
015CC:  MOVLW  87
015CE:  MOVWF  FD5
015D0:  CLRF   FD7
015D2:  CLRF   FD6
015D4:  BCF    FF2.2
015D6:  BSF    FB8.3
015D8:  MOVLW  82
015DA:  MOVWF  FAF
015DC:  MOVLW  06
015DE:  MOVWF  FB0
015E0:  MOVLW  A6
015E2:  MOVWF  FAC
015E4:  MOVLW  90
015E6:  MOVWF  FAB
015E8:  MOVLW  05
015EA:  MOVWF  20
015EC:  CLRF   21
015EE:  MOVLW  06
015F0:  MOVWF  22
015F2:  MOVLW  1E
015F4:  MOVWF  23
015F6:  CLRF   24
015F8:  CLRF   25
015FA:  MOVLW  01
015FC:  MOVWF  26
015FE:  MOVWF  27
01600:  CLRF   2D
01602:  CLRF   2E
01604:  CLRF   2F
01606:  CLRF   30
01608:  CLRF   31
0160A:  MOVWF  32
0160C:  MOVWF  33
0160E:  MOVWF  34
01610:  SETF   36
01612:  SETF   35
01614:  CLRF   39
01616:  MOVWF  3B
01618:  MOVLW  5E
0161A:  MOVWF  3A
0161C:  CLRF   3E
0161E:  CLRF   3F
01620:  CLRF   40
01622:  MOVLW  01
01624:  SUBWF  40,W
01626:  MOVWF  41
01628:  SETF   43
0162A:  SETF   42
0162C:  MOVLW  01
0162E:  MOVWF  44
01630:  CLRF   45
01632:  MOVWF  46
01634:  CLRF   47
01636:  CLRF   48
01638:  CLRF   x68
0163A:  CLRF   x67
0163C:  MOVLB  F
0163E:  CLRF   x38
01640:  CLRF   x39
01642:  CLRF   x3A
01644:  CLRF   x3B
01646:  CLRF   x3C
01648:  CLRF   F77
0164A:  CLRF   F78
0164C:  CLRF   F79
0164E:  CLRF   1D
01650:  CLRF   1E
01652:  MOVLW  31
01654:  MOVWF  49
01656:  MOVLW  32
01658:  MOVWF  4A
0165A:  MOVLW  33
0165C:  MOVWF  4B
0165E:  MOVLW  34
01660:  MOVWF  4C
01662:  MOVLW  35
01664:  MOVWF  4D
01666:  MOVLW  36
01668:  MOVWF  4E
0166A:  MOVLW  37
0166C:  MOVWF  4F
0166E:  MOVLW  38
01670:  MOVWF  50
01672:  MOVLW  39
01674:  MOVWF  51
01676:  MOVLW  01
01678:  MOVWF  52
0167A:  MOVLW  02
0167C:  MOVWF  53
0167E:  MOVLW  03
01680:  MOVWF  54
01682:  MOVLW  04
01684:  MOVWF  55
01686:  MOVLW  05
01688:  MOVWF  56
0168A:  MOVLW  06
0168C:  MOVWF  57
0168E:  MOVLW  07
01690:  MOVWF  58
01692:  MOVLW  08
01694:  MOVWF  59
01696:  MOVLW  09
01698:  MOVWF  5A
.................... {
.................... 
....................     setup_CCP1(CCP_OFF);
0169A:  MOVLW  F0
0169C:  ANDWF  FBD,F
....................     clear_interrupt(INT_TIMER1);
0169E:  BCF    F9E.0
.................... 
....................     setup_low_volt_detect(LVD_TRIGGER_BELOW | LVD_36);
016A0:  MOVLW  1A
016A2:  MOVWF  F9C
....................     enable_interrupts(INT_HLVD);
016A4:  BSF    FA0.2
.................... 
....................     enable_interrupts(GLOBAL);
016A6:  MOVLW  C0
016A8:  IORWF  FF2,F
....................     enable_interrupts(INT_RDA);
016AA:  BSF    F9D.5
....................     disable_interrupts(INT_TIMER1);
016AC:  BCF    F9D.0
....................     
....................     //setup_wdt( WDT_ON | WDT_64MS    );
....................     
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); // Timer1 configuration: internal clock source + 8 prescaler
016AE:  MOVLW  37
016B0:  MOVWF  FCD
016B2:  CLRF   FCC
....................     set_timer1(65486);                        // 65488 --- 63350
016B4:  SETF   FCF
016B6:  MOVLW  CE
016B8:  MOVWF  FCE
....................     //restart_wdt();
....................     lcd_init();
016BA:  MOVLB  0
016BC:  GOTO   06E2
.................... 
....................     lcd_load_custom_chars();
016C0:  GOTO   0734
.................... 
....................     FinishTick = StartTick = CurrentTick = get_ticks(); // timers for centering
016C4:  CALL   0766
016C8:  MOVFF  03,66
016CC:  MOVFF  02,65
016D0:  MOVFF  01,64
016D4:  MOVFF  00,63
016D8:  MOVFF  66,5E
016DC:  MOVFF  65,5D
016E0:  MOVFF  64,5C
016E4:  MOVFF  63,5B
016E8:  MOVFF  5E,62
016EC:  MOVFF  5D,61
016F0:  MOVFF  5C,60
016F4:  MOVFF  5B,5F
.................... 
....................     if (read_eeprom(1) <= 0 | read_eeprom(1) > 10)
016F8:  MOVFF  FF2,71
016FC:  BCF    FF2.7
016FE:  CLRF   FAA
01700:  MOVLW  01
01702:  MOVWF  FA9
01704:  BCF    FA6.6
01706:  BCF    FA6.7
01708:  BSF    FA6.0
0170A:  MOVF   FA8,W
0170C:  BTFSC  x71.7
0170E:  BSF    FF2.7
01710:  XORLW  00
01712:  BZ    1718
01714:  MOVLW  00
01716:  BRA    171A
01718:  MOVLW  01
0171A:  MOVWF  x72
0171C:  MOVFF  FF2,73
01720:  BCF    FF2.7
01722:  CLRF   FAA
01724:  MOVLW  01
01726:  MOVWF  FA9
01728:  BCF    FA6.6
0172A:  BCF    FA6.7
0172C:  BSF    FA6.0
0172E:  MOVF   FA8,W
01730:  BTFSC  x73.7
01732:  BSF    FF2.7
01734:  SUBLW  0A
01736:  BNC   173C
01738:  MOVLW  00
0173A:  BRA    173E
0173C:  MOVLW  01
0173E:  IORWF  x72,W
01740:  XORLW  00
01742:  BTFSC  FD8.2
01744:  BRA    1926
....................     {
.................... 
....................         write_eeprom(1, 5); // speed
01746:  MOVF   FF2,W
01748:  MOVWF  00
0174A:  BCF    FF2.7
0174C:  CLRF   FAA
0174E:  MOVLW  01
01750:  MOVWF  FA9
01752:  MOVLW  05
01754:  MOVWF  FA8
01756:  BCF    FA6.6
01758:  BCF    FA6.7
0175A:  BSF    FA6.2
0175C:  MOVLB  F
0175E:  MOVLW  55
01760:  MOVWF  FA7
01762:  MOVLW  AA
01764:  MOVWF  FA7
01766:  BSF    FA6.1
01768:  BTFSC  FA6.1
0176A:  BRA    1768
0176C:  BCF    FA6.2
0176E:  MOVF   00,W
01770:  IORWF  FF2,F
....................         write_eeprom(2, 6); // accel
01772:  MOVFF  FF2,00
01776:  BCF    FF2.7
01778:  CLRF   FAA
0177A:  MOVLW  02
0177C:  MOVWF  FA9
0177E:  MOVLW  06
01780:  MOVWF  FA8
01782:  BCF    FA6.6
01784:  BCF    FA6.7
01786:  BSF    FA6.2
01788:  MOVLW  55
0178A:  MOVWF  FA7
0178C:  MOVLW  AA
0178E:  MOVWF  FA7
01790:  BSF    FA6.1
01792:  BTFSC  FA6.1
01794:  BRA    1792
01796:  BCF    FA6.2
01798:  MOVF   00,W
0179A:  IORWF  FF2,F
....................         write_eeprom(3, 0); // centered?
0179C:  MOVFF  FF2,00
017A0:  BCF    FF2.7
017A2:  CLRF   FAA
017A4:  MOVLW  03
017A6:  MOVWF  FA9
017A8:  CLRF   FA8
017AA:  BCF    FA6.6
017AC:  BCF    FA6.7
017AE:  BSF    FA6.2
017B0:  MOVLW  55
017B2:  MOVWF  FA7
017B4:  MOVLW  AA
017B6:  MOVWF  FA7
017B8:  BSF    FA6.1
017BA:  BTFSC  FA6.1
017BC:  BRA    17BA
017BE:  BCF    FA6.2
017C0:  MOVF   00,W
017C2:  IORWF  FF2,F
.................... 
....................         write_eeprom(4, 100); // pos1
017C4:  MOVFF  FF2,00
017C8:  BCF    FF2.7
017CA:  CLRF   FAA
017CC:  MOVLW  04
017CE:  MOVWF  FA9
017D0:  MOVLW  64
017D2:  MOVWF  FA8
017D4:  BCF    FA6.6
017D6:  BCF    FA6.7
017D8:  BSF    FA6.2
017DA:  MOVLW  55
017DC:  MOVWF  FA7
017DE:  MOVLW  AA
017E0:  MOVWF  FA7
017E2:  BSF    FA6.1
017E4:  BTFSC  FA6.1
017E6:  BRA    17E4
017E8:  BCF    FA6.2
017EA:  MOVF   00,W
017EC:  IORWF  FF2,F
....................         write_eeprom(5, 100); // pos2
017EE:  MOVFF  FF2,00
017F2:  BCF    FF2.7
017F4:  CLRF   FAA
017F6:  MOVLW  05
017F8:  MOVWF  FA9
017FA:  MOVLW  64
017FC:  MOVWF  FA8
017FE:  BCF    FA6.6
01800:  BCF    FA6.7
01802:  BSF    FA6.2
01804:  MOVLW  55
01806:  MOVWF  FA7
01808:  MOVLW  AA
0180A:  MOVWF  FA7
0180C:  BSF    FA6.1
0180E:  BTFSC  FA6.1
01810:  BRA    180E
01812:  BCF    FA6.2
01814:  MOVF   00,W
01816:  IORWF  FF2,F
.................... 
....................         write_eeprom(6, 0); // threshold
01818:  MOVFF  FF2,00
0181C:  BCF    FF2.7
0181E:  CLRF   FAA
01820:  MOVLW  06
01822:  MOVWF  FA9
01824:  CLRF   FA8
01826:  BCF    FA6.6
01828:  BCF    FA6.7
0182A:  BSF    FA6.2
0182C:  MOVLW  55
0182E:  MOVWF  FA7
01830:  MOVLW  AA
01832:  MOVWF  FA7
01834:  BSF    FA6.1
01836:  BTFSC  FA6.1
01838:  BRA    1836
0183A:  BCF    FA6.2
0183C:  MOVF   00,W
0183E:  IORWF  FF2,F
.................... 
....................         write_eeprom(7, 0); // cc1
01840:  MOVFF  FF2,00
01844:  BCF    FF2.7
01846:  CLRF   FAA
01848:  MOVLW  07
0184A:  MOVWF  FA9
0184C:  CLRF   FA8
0184E:  BCF    FA6.6
01850:  BCF    FA6.7
01852:  BSF    FA6.2
01854:  MOVLW  55
01856:  MOVWF  FA7
01858:  MOVLW  AA
0185A:  MOVWF  FA7
0185C:  BSF    FA6.1
0185E:  BTFSC  FA6.1
01860:  BRA    185E
01862:  BCF    FA6.2
01864:  MOVF   00,W
01866:  IORWF  FF2,F
....................         write_eeprom(8, 0); // cc2
01868:  MOVFF  FF2,00
0186C:  BCF    FF2.7
0186E:  CLRF   FAA
01870:  MOVLW  08
01872:  MOVWF  FA9
01874:  CLRF   FA8
01876:  BCF    FA6.6
01878:  BCF    FA6.7
0187A:  BSF    FA6.2
0187C:  MOVLW  55
0187E:  MOVWF  FA7
01880:  MOVLW  AA
01882:  MOVWF  FA7
01884:  BSF    FA6.1
01886:  BTFSC  FA6.1
01888:  BRA    1886
0188A:  BCF    FA6.2
0188C:  MOVF   00,W
0188E:  IORWF  FF2,F
.................... 
....................         write_eeprom(9, 0); // line1
01890:  MOVFF  FF2,00
01894:  BCF    FF2.7
01896:  CLRF   FAA
01898:  MOVLW  09
0189A:  MOVWF  FA9
0189C:  CLRF   FA8
0189E:  BCF    FA6.6
018A0:  BCF    FA6.7
018A2:  BSF    FA6.2
018A4:  MOVLW  55
018A6:  MOVWF  FA7
018A8:  MOVLW  AA
018AA:  MOVWF  FA7
018AC:  BSF    FA6.1
018AE:  BTFSC  FA6.1
018B0:  BRA    18AE
018B2:  BCF    FA6.2
018B4:  MOVF   00,W
018B6:  IORWF  FF2,F
.................... 
....................         write_eeprom(10, 1); // check_right
018B8:  MOVFF  FF2,00
018BC:  BCF    FF2.7
018BE:  CLRF   FAA
018C0:  MOVLW  0A
018C2:  MOVWF  FA9
018C4:  MOVLW  01
018C6:  MOVWF  FA8
018C8:  BCF    FA6.6
018CA:  BCF    FA6.7
018CC:  BSF    FA6.2
018CE:  MOVLW  55
018D0:  MOVWF  FA7
018D2:  MOVLW  AA
018D4:  MOVWF  FA7
018D6:  BSF    FA6.1
018D8:  BTFSC  FA6.1
018DA:  BRA    18D8
018DC:  BCF    FA6.2
018DE:  MOVF   00,W
018E0:  IORWF  FF2,F
....................         write_eeprom(11, 1); // check_left
018E2:  MOVFF  FF2,00
018E6:  BCF    FF2.7
018E8:  CLRF   FAA
018EA:  MOVLW  0B
018EC:  MOVWF  FA9
018EE:  MOVLW  01
018F0:  MOVWF  FA8
018F2:  BCF    FA6.6
018F4:  BCF    FA6.7
018F6:  BSF    FA6.2
018F8:  MOVLW  55
018FA:  MOVWF  FA7
018FC:  MOVLW  AA
018FE:  MOVWF  FA7
01900:  BSF    FA6.1
01902:  BTFSC  FA6.1
01904:  BRA    1902
01906:  BCF    FA6.2
01908:  MOVF   00,W
0190A:  IORWF  FF2,F
.................... 
....................         lcd_gotoxy(1, 3);
0190C:  MOVLW  01
0190E:  MOVLB  0
01910:  MOVWF  x7F
01912:  MOVLW  03
01914:  MOVWF  x80
01916:  CALL   07B8
....................         lcd_putc("Eeprom Fail");
0191A:  MOVLW  54
0191C:  MOVWF  FF6
0191E:  MOVLW  05
01920:  MOVWF  FF7
01922:  CALL   0840
....................     }
.................... 
....................     delay_s = read_eeprom(1);
01926:  MOVFF  FF2,71
0192A:  BCF    FF2.7
0192C:  CLRF   FAA
0192E:  MOVLW  01
01930:  MOVWF  FA9
01932:  BCF    FA6.6
01934:  BCF    FA6.7
01936:  BSF    FA6.0
01938:  MOVF   FA8,W
0193A:  BTFSC  x71.7
0193C:  BSF    FF2.7
0193E:  MOVWF  20
....................     accel = read_eeprom(2);
01940:  MOVFF  FF2,71
01944:  BCF    FF2.7
01946:  CLRF   FAA
01948:  MOVLW  02
0194A:  MOVWF  FA9
0194C:  BCF    FA6.6
0194E:  BCF    FA6.7
01950:  BSF    FA6.0
01952:  MOVF   FA8,W
01954:  BTFSC  x71.7
01956:  BSF    FF2.7
01958:  MOVWF  22
....................     centered = read_eeprom(3);
0195A:  MOVFF  FF2,71
0195E:  BCF    FF2.7
01960:  CLRF   FAA
01962:  MOVLW  03
01964:  MOVWF  FA9
01966:  BCF    FA6.6
01968:  BCF    FA6.7
0196A:  BSF    FA6.0
0196C:  MOVF   FA8,W
0196E:  BTFSC  x71.7
01970:  BSF    FF2.7
01972:  MOVWF  34
.................... 
....................     control_right = read_eeprom(10);
01974:  MOVFF  FF2,71
01978:  BCF    FF2.7
0197A:  CLRF   FAA
0197C:  MOVLW  0A
0197E:  MOVWF  FA9
01980:  BCF    FA6.6
01982:  BCF    FA6.7
01984:  BSF    FA6.0
01986:  MOVF   FA8,W
01988:  BTFSC  x71.7
0198A:  BSF    FF2.7
0198C:  MOVWF  33
....................     control_left = read_eeprom(11);
0198E:  MOVFF  FF2,71
01992:  BCF    FF2.7
01994:  CLRF   FAA
01996:  MOVLW  0B
01998:  MOVWF  FA9
0199A:  BCF    FA6.6
0199C:  BCF    FA6.7
0199E:  BSF    FA6.0
019A0:  MOVF   FA8,W
019A2:  BTFSC  x71.7
019A4:  BSF    FF2.7
019A6:  MOVWF  32
.................... 
....................     if (centered)
019A8:  MOVF   34,F
019AA:  BTFSC  FD8.2
019AC:  BRA    1B3A
....................     {
.................... 
....................         step1 = read_eeprom(4);
019AE:  MOVFF  FF2,71
019B2:  BCF    FF2.7
019B4:  CLRF   FAA
019B6:  MOVLW  04
019B8:  MOVWF  FA9
019BA:  BCF    FA6.6
019BC:  BCF    FA6.7
019BE:  BSF    FA6.0
019C0:  MOVF   FA8,W
019C2:  BTFSC  x71.7
019C4:  BSF    FF2.7
019C6:  MOVWF  3C
....................         step2 = read_eeprom(5);
019C8:  MOVFF  FF2,71
019CC:  BCF    FF2.7
019CE:  CLRF   FAA
019D0:  MOVLW  05
019D2:  MOVWF  FA9
019D4:  BCF    FA6.6
019D6:  BCF    FA6.7
019D8:  BSF    FA6.0
019DA:  MOVF   FA8,W
019DC:  BTFSC  x71.7
019DE:  BSF    FF2.7
019E0:  MOVWF  3D
.................... 
....................         step = make16(step2, step1);
019E2:  MOVFF  3D,3B
019E6:  MOVFF  3C,3A
....................         lcd_gotoxy(1, 3);
019EA:  MOVLW  01
019EC:  MOVWF  x7F
019EE:  MOVLW  03
019F0:  MOVWF  x80
019F2:  CALL   07B8
....................         printf(lcd_putc, "%lu", step);
019F6:  MOVLW  10
019F8:  MOVWF  FE9
019FA:  MOVFF  3B,76
019FE:  MOVFF  3A,75
01A02:  CALL   0860
.................... 
....................         threshold = read_eeprom(6);
01A06:  MOVFF  FF2,71
01A0A:  BCF    FF2.7
01A0C:  CLRF   FAA
01A0E:  MOVLW  06
01A10:  MOVWF  FA9
01A12:  BCF    FA6.6
01A14:  BCF    FA6.7
01A16:  BSF    FA6.0
01A18:  MOVF   FA8,W
01A1A:  BTFSC  x71.7
01A1C:  BSF    FF2.7
01A1E:  MOVWF  40
....................         printf(lcd_putc, " %d", threshold);
01A20:  MOVLW  20
01A22:  MOVWF  x7E
01A24:  CALL   07F8
01A28:  MOVFF  40,72
01A2C:  MOVLW  18
01A2E:  MOVWF  x73
01A30:  CALL   0942
.................... 
....................         cc1 = read_eeprom(7);
01A34:  MOVFF  FF2,71
01A38:  BCF    FF2.7
01A3A:  CLRF   FAA
01A3C:  MOVLW  07
01A3E:  MOVWF  FA9
01A40:  BCF    FA6.6
01A42:  BCF    FA6.7
01A44:  BSF    FA6.0
01A46:  MOVF   FA8,W
01A48:  BTFSC  x71.7
01A4A:  BSF    FF2.7
01A4C:  MOVWF  37
....................         cc2 = read_eeprom(8);
01A4E:  MOVFF  FF2,71
01A52:  BCF    FF2.7
01A54:  CLRF   FAA
01A56:  MOVLW  08
01A58:  MOVWF  FA9
01A5A:  BCF    FA6.6
01A5C:  BCF    FA6.7
01A5E:  BSF    FA6.0
01A60:  MOVF   FA8,W
01A62:  BTFSC  x71.7
01A64:  BSF    FF2.7
01A66:  MOVWF  38
....................         centercounter = make16(cc2, cc1);
01A68:  MOVFF  38,36
01A6C:  MOVFF  37,35
.................... 
....................         // ine1=step/threshold;
....................         // line1++;
.................... 
....................         line1 = read_eeprom(9);
01A70:  MOVFF  FF2,71
01A74:  BCF    FF2.7
01A76:  CLRF   FAA
01A78:  MOVLW  09
01A7A:  MOVWF  FA9
01A7C:  BCF    FA6.6
01A7E:  BCF    FA6.7
01A80:  BSF    FA6.0
01A82:  MOVF   FA8,W
01A84:  BTFSC  x71.7
01A86:  BSF    FF2.7
01A88:  MOVWF  3E
.................... 
....................         lcd_gotoxy(1, 4);
01A8A:  MOVLW  01
01A8C:  MOVWF  x7F
01A8E:  MOVLW  04
01A90:  MOVWF  x80
01A92:  CALL   07B8
....................         lcd_putc(swoff);
01A96:  MOVLW  02
01A98:  MOVWF  x7E
01A9A:  CALL   07F8
....................         lcd_gotoxy(20, 4);
01A9E:  MOVLW  14
01AA0:  MOVWF  x7F
01AA2:  MOVLW  04
01AA4:  MOVWF  x80
01AA6:  CALL   07B8
....................         lcd_putc(swoff);
01AAA:  MOVLW  02
01AAC:  MOVWF  x7E
01AAE:  CALL   07F8
.................... 
....................         if (step >= threshold)
01AB2:  MOVF   3B,F
01AB4:  BNZ   1ABC
01AB6:  MOVF   40,W
01AB8:  SUBWF  3A,W
01ABA:  BNC   1ADC
....................         {
....................             for (int i = 2; i <= line1; i++)
01ABC:  MOVLW  02
01ABE:  MOVWF  x69
01AC0:  MOVF   x69,W
01AC2:  SUBWF  3E,W
01AC4:  BNC   1ADC
....................             {
....................                 lcd_gotoxy(i, 4);
01AC6:  MOVFF  69,7F
01ACA:  MOVLW  04
01ACC:  MOVWF  x80
01ACE:  CALL   07B8
....................                 lcd_putc(three_dot);
01AD2:  CLRF   x7E
01AD4:  CALL   07F8
01AD8:  INCF   x69,F
01ADA:  BRA    1AC0
....................             }
....................         }
.................... 
....................         if (input(proxy_left))
01ADC:  BSF    F95.7
01ADE:  BTFSS  F83.7
01AE0:  BRA    1B0A
....................         {
.................... 
....................             lcd_gotoxy(1, 4);
01AE2:  MOVLW  01
01AE4:  MOVWF  x7F
01AE6:  MOVLW  04
01AE8:  MOVWF  x80
01AEA:  CALL   07B8
....................             lcd_putc(swoff);
01AEE:  MOVLW  02
01AF0:  MOVWF  x7E
01AF2:  CALL   07F8
.................... 
....................             lcd_gotoxy(20, 4);
01AF6:  MOVLW  14
01AF8:  MOVWF  x7F
01AFA:  MOVLW  04
01AFC:  MOVWF  x80
01AFE:  CALL   07B8
....................             lcd_putc(swon);
01B02:  MOVLW  01
01B04:  MOVWF  x7E
01B06:  CALL   07F8
....................         }
.................... 
....................         if (input(proxy_right))
01B0A:  BSF    F95.6
01B0C:  BTFSS  F83.6
01B0E:  BRA    1B38
....................         {
.................... 
....................             lcd_gotoxy(1, 4);
01B10:  MOVLW  01
01B12:  MOVWF  x7F
01B14:  MOVLW  04
01B16:  MOVWF  x80
01B18:  CALL   07B8
....................             lcd_putc(swon);
01B1C:  MOVLW  01
01B1E:  MOVWF  x7E
01B20:  CALL   07F8
.................... 
....................             lcd_gotoxy(20, 4);
01B24:  MOVLW  14
01B26:  MOVWF  x7F
01B28:  MOVLW  04
01B2A:  MOVWF  x80
01B2C:  CALL   07B8
....................             lcd_putc(swoff);
01B30:  MOVLW  02
01B32:  MOVWF  x7E
01B34:  CALL   07F8
....................         }
....................     }
01B38:  BRA    1B50
.................... 
....................     else
....................     {
....................         lcd_gotoxy(4, 4);
01B3A:  MOVLW  04
01B3C:  MOVWF  x7F
01B3E:  MOVWF  x80
01B40:  CALL   07B8
....................         lcd_putc("Centee Machine");
01B44:  MOVLW  60
01B46:  MOVWF  FF6
01B48:  MOVLW  05
01B4A:  MOVWF  FF7
01B4C:  CALL   0840
....................     }
....................     //////////////////////////////////////
.................... 
....................     while (TRUE)
....................     {    
....................         //restart_wdt();
....................         enable_interrupts(INT_RDA);
01B50:  BSF    F9D.5
....................         // output_toggle (PIN_D4);
....................          
....................         lcd_gotoxy(1, 1);
01B52:  MOVLW  01
01B54:  MOVWF  x7F
01B56:  MOVWF  x80
01B58:  CALL   07B8
....................         lcd_putc("Speed: %   ");
01B5C:  MOVLW  70
01B5E:  MOVWF  FF6
01B60:  MOVLW  05
01B62:  MOVWF  FF7
01B64:  CALL   0840
....................         lcd_gotoxy(9, 1);
01B68:  MOVLW  09
01B6A:  MOVWF  x7F
01B6C:  MOVLW  01
01B6E:  MOVWF  x80
01B70:  CALL   07B8
....................         printf(lcd_putc, "%u", delay_s * 10);
01B74:  MOVF   20,W
01B76:  MULLW  0A
01B78:  MOVFF  FF3,72
01B7C:  MOVLW  1B
01B7E:  MOVWF  x73
01B80:  CALL   09EC
.................... 
....................         lcd_gotoxy(13, 1);
01B84:  MOVLW  0D
01B86:  MOVWF  x7F
01B88:  MOVLW  01
01B8A:  MOVWF  x80
01B8C:  CALL   07B8
....................         if (mode_manuel)
01B90:  MOVF   26,F
01B92:  BZ    1BA0
....................         {
....................             lcd_putc("<Manuel>");
01B94:  MOVLW  7C
01B96:  MOVWF  FF6
01B98:  MOVLW  05
01B9A:  MOVWF  FF7
01B9C:  CALL   0840
....................         }
.................... 
....................         if (mode_auto)
01BA0:  MOVF   25,F
01BA2:  BZ    1BB0
....................         {
....................             lcd_putc("< Auto >");
01BA4:  MOVLW  86
01BA6:  MOVWF  FF6
01BA8:  MOVLW  05
01BAA:  MOVWF  FF7
01BAC:  CALL   0840
....................         }
.................... 
....................         lcd_gotoxy(1, 2);
01BB0:  MOVLW  01
01BB2:  MOVWF  x7F
01BB4:  MOVLW  02
01BB6:  MOVWF  x80
01BB8:  CALL   07B8
....................         lcd_putc("Accel: %   ");
01BBC:  MOVLW  90
01BBE:  MOVWF  FF6
01BC0:  MOVLW  05
01BC2:  MOVWF  FF7
01BC4:  CALL   0840
....................         lcd_gotoxy(9, 2);
01BC8:  MOVLW  09
01BCA:  MOVWF  x7F
01BCC:  MOVLW  02
01BCE:  MOVWF  x80
01BD0:  CALL   07B8
....................         printf(lcd_putc, "%u", accel * 10);
01BD4:  MOVF   22,W
01BD6:  MULLW  0A
01BD8:  MOVFF  FF3,72
01BDC:  MOVLW  1B
01BDE:  MOVWF  x73
01BE0:  CALL   09EC
....................    /*
....................         if (centered == False)
....................         {
....................             lcd_gotoxy(4, 4);
....................             lcd_putc("Center Machine");
....................         }
....................    */
....................         ///////////////////>>>>>> MODE CHANGE  <<<<<//////////////////////
.................... 
....................         if (input(button5))
01BE4:  BSF    F94.1
01BE6:  BTFSS  F82.1
01BE8:  BRA    2138
....................         {
.................... 
....................             int mode_cursor = 1;
....................             char mod_flag = False;
01BEA:  MOVLW  01
01BEC:  MOVWF  x6A
01BEE:  CLRF   x6B
....................             
....................             StartTick = get_ticks();
01BF0:  CALL   0766
01BF4:  MOVFF  03,5E
01BF8:  MOVFF  02,5D
01BFC:  MOVFF  01,5C
01C00:  MOVFF  00,5B
....................             delay_ms(500);
01C04:  MOVLW  02
01C06:  MOVWF  x71
01C08:  MOVLW  FA
01C0A:  MOVWF  x7F
01C0C:  CALL   05CE
01C10:  DECFSZ x71,F
01C12:  BRA    1C08
....................             while (1)
....................             {
....................                seri_check();
01C14:  GOTO   1292
....................                enable_interrupts(INT_RDA);
01C18:  BSF    F9D.5
....................                
....................                //restart_wdt();
....................                 if (mode_cursor == 1)
01C1A:  DECFSZ x6A,W
01C1C:  BRA    1E28
....................                 { // SET SPEED
.................... 
....................                     CurrentTick = get_ticks();
01C1E:  CALL   0766
01C22:  MOVFF  03,66
01C26:  MOVFF  02,65
01C2A:  MOVFF  01,64
01C2E:  MOVFF  00,63
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == True)
01C32:  MOVF   5B,W
01C34:  SUBWF  x63,W
01C36:  MOVWF  x71
01C38:  MOVF   5C,W
01C3A:  SUBWFB x64,W
01C3C:  MOVWF  x72
01C3E:  MOVF   5D,W
01C40:  SUBWFB x65,W
01C42:  MOVWF  x73
01C44:  MOVF   5E,W
01C46:  SUBWFB x66,W
01C48:  MOVWF  x74
01C4A:  MOVF   x74,F
01C4C:  BNZ   1C66
01C4E:  MOVF   x73,F
01C50:  BNZ   1C66
01C52:  MOVF   x72,W
01C54:  SUBLW  08
01C56:  BC    1C62
01C58:  XORLW  FF
01C5A:  BNZ   1C66
01C5C:  MOVF   x71,W
01C5E:  SUBLW  C4
01C60:  BNC   1C66
01C62:  MOVLW  00
01C64:  BRA    1C68
01C66:  MOVLW  01
01C68:  MOVWF  x71
01C6A:  DECFSZ x6B,W
01C6C:  BRA    1C70
01C6E:  BRA    1C74
01C70:  MOVLW  00
01C72:  BRA    1C76
01C74:  MOVLW  01
01C76:  ANDWF  x71,W
01C78:  BZ    1CB4
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01C7A:  MOVLW  08
01C7C:  MOVWF  x7F
01C7E:  MOVFF  6A,80
01C82:  CALL   07B8
....................                         lcd_putc("%");
01C86:  MOVLW  9C
01C88:  MOVWF  FF6
01C8A:  MOVLW  05
01C8C:  MOVWF  FF7
01C8E:  CALL   0840
....................                         printf(lcd_putc, "%d", delay_s * 10);
01C92:  MOVF   20,W
01C94:  MULLW  0A
01C96:  MOVFF  FF3,72
01C9A:  MOVLW  18
01C9C:  MOVWF  x73
01C9E:  CALL   0942
.................... 
....................                         mod_flag = False;
01CA2:  CLRF   x6B
....................                         StartTick = CurrentTick;
01CA4:  MOVFF  66,5E
01CA8:  MOVFF  65,5D
01CAC:  MOVFF  64,5C
01CB0:  MOVFF  63,5B
....................                     }
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == False)
01CB4:  MOVF   5B,W
01CB6:  SUBWF  x63,W
01CB8:  MOVWF  x71
01CBA:  MOVF   5C,W
01CBC:  SUBWFB x64,W
01CBE:  MOVWF  x72
01CC0:  MOVF   5D,W
01CC2:  SUBWFB x65,W
01CC4:  MOVWF  x73
01CC6:  MOVF   5E,W
01CC8:  SUBWFB x66,W
01CCA:  MOVWF  x74
01CCC:  MOVF   x74,F
01CCE:  BNZ   1CE8
01CD0:  MOVF   x73,F
01CD2:  BNZ   1CE8
01CD4:  MOVF   x72,W
01CD6:  SUBLW  08
01CD8:  BC    1CE4
01CDA:  XORLW  FF
01CDC:  BNZ   1CE8
01CDE:  MOVF   x71,W
01CE0:  SUBLW  C4
01CE2:  BNC   1CE8
01CE4:  MOVLW  00
01CE6:  BRA    1CEA
01CE8:  MOVLW  01
01CEA:  MOVWF  x71
01CEC:  MOVF   x6B,F
01CEE:  BZ    1CF4
01CF0:  MOVLW  00
01CF2:  BRA    1CF6
01CF4:  MOVLW  01
01CF6:  ANDWF  x71,W
01CF8:  BZ    1D26
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01CFA:  MOVLW  08
01CFC:  MOVWF  x7F
01CFE:  MOVFF  6A,80
01D02:  CALL   07B8
....................                         lcd_putc("    ");
01D06:  MOVLW  9E
01D08:  MOVWF  FF6
01D0A:  MOVLW  05
01D0C:  MOVWF  FF7
01D0E:  CALL   0840
.................... 
....................                         mod_flag = True;
01D12:  MOVLW  01
01D14:  MOVWF  x6B
....................                         StartTick = CurrentTick;
01D16:  MOVFF  66,5E
01D1A:  MOVFF  65,5D
01D1E:  MOVFF  64,5C
01D22:  MOVFF  63,5B
....................                     }
.................... 
....................                     if (input(button1))
01D26:  BSF    F95.1
01D28:  BTFSS  F83.1
01D2A:  BRA    1D9C
....................                     {
....................                         delay_s=delay_s-1;
01D2C:  MOVLW  01
01D2E:  SUBWF  20,F
.................... 
....................                         if (delay_s <= 0)
01D30:  MOVF   20,F
01D32:  BNZ   1D38
....................                         {
....................                             delay_s = 1;
01D34:  MOVLW  01
01D36:  MOVWF  20
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01D38:  MOVLW  08
01D3A:  MOVWF  x7F
01D3C:  MOVFF  6A,80
01D40:  CALL   07B8
....................                         lcd_putc("%");
01D44:  MOVLW  A4
01D46:  MOVWF  FF6
01D48:  MOVLW  05
01D4A:  MOVWF  FF7
01D4C:  CALL   0840
....................                         printf(lcd_putc, "%d ", delay_s * 10);
01D50:  MOVF   20,W
01D52:  MULLW  0A
01D54:  MOVFF  FF3,72
01D58:  MOVLW  18
01D5A:  MOVWF  x73
01D5C:  CALL   0942
01D60:  MOVLW  20
01D62:  MOVWF  x7E
01D64:  CALL   07F8
.................... 
....................                         printf("h0%d ", delay_s);
01D68:  MOVLW  68
01D6A:  BTFSS  F9E.4
01D6C:  BRA    1D6A
01D6E:  MOVWF  FAD
01D70:  MOVLW  30
01D72:  BTFSS  F9E.4
01D74:  BRA    1D72
01D76:  MOVWF  FAD
01D78:  MOVFF  20,78
01D7C:  MOVLW  18
01D7E:  MOVWF  x79
01D80:  CALL   0C54
01D84:  MOVLW  20
01D86:  BTFSS  F9E.4
01D88:  BRA    1D86
01D8A:  MOVWF  FAD
....................                         delay_ms(500);
01D8C:  MOVLW  02
01D8E:  MOVWF  x71
01D90:  MOVLW  FA
01D92:  MOVWF  x7F
01D94:  CALL   05CE
01D98:  DECFSZ x71,F
01D9A:  BRA    1D90
....................                     }
.................... 
....................                     if (input(button3))
01D9C:  BSF    F94.3
01D9E:  BTFSS  F82.3
01DA0:  BRA    1E28
....................                     {
....................                         delay_s=delay_s+1;
01DA2:  MOVLW  01
01DA4:  ADDWF  20,F
.................... 
....................                         if (delay_s >= 10)
01DA6:  MOVF   20,W
01DA8:  SUBLW  09
01DAA:  BC    1DB0
....................                         {
....................                             delay_s = 10;
01DAC:  MOVLW  0A
01DAE:  MOVWF  20
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01DB0:  MOVLW  08
01DB2:  MOVWF  x7F
01DB4:  MOVFF  6A,80
01DB8:  CALL   07B8
....................                         lcd_putc("%");
01DBC:  MOVLW  A6
01DBE:  MOVWF  FF6
01DC0:  MOVLW  05
01DC2:  MOVWF  FF7
01DC4:  CALL   0840
....................                         printf(lcd_putc, "%d ", delay_s * 10);
01DC8:  MOVF   20,W
01DCA:  MULLW  0A
01DCC:  MOVFF  FF3,72
01DD0:  MOVLW  18
01DD2:  MOVWF  x73
01DD4:  CALL   0942
01DD8:  MOVLW  20
01DDA:  MOVWF  x7E
01DDC:  CALL   07F8
.................... 
....................                         if (delay_s < 10)
01DE0:  MOVF   20,W
01DE2:  SUBLW  09
01DE4:  BNC   1E0C
....................                         {
....................                             printf("h0%d ", delay_s);
01DE6:  MOVLW  68
01DE8:  BTFSS  F9E.4
01DEA:  BRA    1DE8
01DEC:  MOVWF  FAD
01DEE:  MOVLW  30
01DF0:  BTFSS  F9E.4
01DF2:  BRA    1DF0
01DF4:  MOVWF  FAD
01DF6:  MOVFF  20,78
01DFA:  MOVLW  18
01DFC:  MOVWF  x79
01DFE:  CALL   0C54
01E02:  MOVLW  20
01E04:  BTFSS  F9E.4
01E06:  BRA    1E04
01E08:  MOVWF  FAD
....................                         }
01E0A:  BRA    1E18
....................                         else
....................                         {
....................                             printf("h10");
01E0C:  MOVLW  A8
01E0E:  MOVWF  FF6
01E10:  MOVLW  05
01E12:  MOVWF  FF7
01E14:  CALL   138E
....................                         }
.................... 
....................                         delay_ms(500);
01E18:  MOVLW  02
01E1A:  MOVWF  x71
01E1C:  MOVLW  FA
01E1E:  MOVWF  x7F
01E20:  CALL   05CE
01E24:  DECFSZ x71,F
01E26:  BRA    1E1C
....................                     }
....................                 }
.................... 
....................                 ////////////////////////
.................... 
....................                 if (mode_cursor == 2){ // SET ACCEL
01E28:  MOVF   x6A,W
01E2A:  SUBLW  02
01E2C:  BTFSS  FD8.2
01E2E:  BRA    203A
.................... 
....................                     CurrentTick = get_ticks();
01E30:  CALL   0766
01E34:  MOVFF  03,66
01E38:  MOVFF  02,65
01E3C:  MOVFF  01,64
01E40:  MOVFF  00,63
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == True)
01E44:  MOVF   5B,W
01E46:  SUBWF  x63,W
01E48:  MOVWF  x71
01E4A:  MOVF   5C,W
01E4C:  SUBWFB x64,W
01E4E:  MOVWF  x72
01E50:  MOVF   5D,W
01E52:  SUBWFB x65,W
01E54:  MOVWF  x73
01E56:  MOVF   5E,W
01E58:  SUBWFB x66,W
01E5A:  MOVWF  x74
01E5C:  MOVF   x74,F
01E5E:  BNZ   1E78
01E60:  MOVF   x73,F
01E62:  BNZ   1E78
01E64:  MOVF   x72,W
01E66:  SUBLW  08
01E68:  BC    1E74
01E6A:  XORLW  FF
01E6C:  BNZ   1E78
01E6E:  MOVF   x71,W
01E70:  SUBLW  C4
01E72:  BNC   1E78
01E74:  MOVLW  00
01E76:  BRA    1E7A
01E78:  MOVLW  01
01E7A:  MOVWF  x71
01E7C:  DECFSZ x6B,W
01E7E:  BRA    1E82
01E80:  BRA    1E86
01E82:  MOVLW  00
01E84:  BRA    1E88
01E86:  MOVLW  01
01E88:  ANDWF  x71,W
01E8A:  BZ    1EC6
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01E8C:  MOVLW  08
01E8E:  MOVWF  x7F
01E90:  MOVFF  6A,80
01E94:  CALL   07B8
....................                         lcd_putc("%");
01E98:  MOVLW  AC
01E9A:  MOVWF  FF6
01E9C:  MOVLW  05
01E9E:  MOVWF  FF7
01EA0:  CALL   0840
....................                         printf(lcd_putc, "%d", accel * 10);
01EA4:  MOVF   22,W
01EA6:  MULLW  0A
01EA8:  MOVFF  FF3,72
01EAC:  MOVLW  18
01EAE:  MOVWF  x73
01EB0:  CALL   0942
.................... 
....................                         mod_flag = False;
01EB4:  CLRF   x6B
....................                         StartTick = CurrentTick;
01EB6:  MOVFF  66,5E
01EBA:  MOVFF  65,5D
01EBE:  MOVFF  64,5C
01EC2:  MOVFF  63,5B
....................                     }
.................... 
....................                     if (CurrentTick - StartTick > 2500 & mod_flag == False)
01EC6:  MOVF   5B,W
01EC8:  SUBWF  x63,W
01ECA:  MOVWF  x71
01ECC:  MOVF   5C,W
01ECE:  SUBWFB x64,W
01ED0:  MOVWF  x72
01ED2:  MOVF   5D,W
01ED4:  SUBWFB x65,W
01ED6:  MOVWF  x73
01ED8:  MOVF   5E,W
01EDA:  SUBWFB x66,W
01EDC:  MOVWF  x74
01EDE:  MOVF   x74,F
01EE0:  BNZ   1EFA
01EE2:  MOVF   x73,F
01EE4:  BNZ   1EFA
01EE6:  MOVF   x72,W
01EE8:  SUBLW  08
01EEA:  BC    1EF6
01EEC:  XORLW  FF
01EEE:  BNZ   1EFA
01EF0:  MOVF   x71,W
01EF2:  SUBLW  C4
01EF4:  BNC   1EFA
01EF6:  MOVLW  00
01EF8:  BRA    1EFC
01EFA:  MOVLW  01
01EFC:  MOVWF  x71
01EFE:  MOVF   x6B,F
01F00:  BZ    1F06
01F02:  MOVLW  00
01F04:  BRA    1F08
01F06:  MOVLW  01
01F08:  ANDWF  x71,W
01F0A:  BZ    1F38
....................                     {
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01F0C:  MOVLW  08
01F0E:  MOVWF  x7F
01F10:  MOVFF  6A,80
01F14:  CALL   07B8
....................                         lcd_putc("    ");
01F18:  MOVLW  AE
01F1A:  MOVWF  FF6
01F1C:  MOVLW  05
01F1E:  MOVWF  FF7
01F20:  CALL   0840
.................... 
....................                         mod_flag = True;
01F24:  MOVLW  01
01F26:  MOVWF  x6B
....................                         StartTick = CurrentTick;
01F28:  MOVFF  66,5E
01F2C:  MOVFF  65,5D
01F30:  MOVFF  64,5C
01F34:  MOVFF  63,5B
....................                     }
.................... 
....................                     if (input(button1))
01F38:  BSF    F95.1
01F3A:  BTFSS  F83.1
01F3C:  BRA    1FAE
....................                     {
....................                         accel=accel-1;
01F3E:  MOVLW  01
01F40:  SUBWF  22,F
.................... 
....................                         if (accel <= 0)
01F42:  MOVF   22,F
01F44:  BNZ   1F4A
....................                         {
....................                             accel = 1;
01F46:  MOVLW  01
01F48:  MOVWF  22
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01F4A:  MOVLW  08
01F4C:  MOVWF  x7F
01F4E:  MOVFF  6A,80
01F52:  CALL   07B8
....................                         lcd_putc("%");
01F56:  MOVLW  B4
01F58:  MOVWF  FF6
01F5A:  MOVLW  05
01F5C:  MOVWF  FF7
01F5E:  CALL   0840
....................                         printf(lcd_putc, "%d ", accel * 10);
01F62:  MOVF   22,W
01F64:  MULLW  0A
01F66:  MOVFF  FF3,72
01F6A:  MOVLW  18
01F6C:  MOVWF  x73
01F6E:  CALL   0942
01F72:  MOVLW  20
01F74:  MOVWF  x7E
01F76:  CALL   07F8
.................... 
....................                         printf("a0%d ", accel);
01F7A:  MOVLW  61
01F7C:  BTFSS  F9E.4
01F7E:  BRA    1F7C
01F80:  MOVWF  FAD
01F82:  MOVLW  30
01F84:  BTFSS  F9E.4
01F86:  BRA    1F84
01F88:  MOVWF  FAD
01F8A:  MOVFF  22,78
01F8E:  MOVLW  18
01F90:  MOVWF  x79
01F92:  CALL   0C54
01F96:  MOVLW  20
01F98:  BTFSS  F9E.4
01F9A:  BRA    1F98
01F9C:  MOVWF  FAD
.................... 
....................                         delay_ms(500);
01F9E:  MOVLW  02
01FA0:  MOVWF  x71
01FA2:  MOVLW  FA
01FA4:  MOVWF  x7F
01FA6:  CALL   05CE
01FAA:  DECFSZ x71,F
01FAC:  BRA    1FA2
....................                     }
.................... 
....................                     if (input(button3))
01FAE:  BSF    F94.3
01FB0:  BTFSS  F82.3
01FB2:  BRA    203A
....................                     {
....................                         accel=accel+1;
01FB4:  MOVLW  01
01FB6:  ADDWF  22,F
.................... 
....................                         if (accel >= 11)
01FB8:  MOVF   22,W
01FBA:  SUBLW  0A
01FBC:  BC    1FC2
....................                         {
....................                             accel = 10;
01FBE:  MOVLW  0A
01FC0:  MOVWF  22
....................                         }
.................... 
....................                         lcd_gotoxy(8, mode_cursor);
01FC2:  MOVLW  08
01FC4:  MOVWF  x7F
01FC6:  MOVFF  6A,80
01FCA:  CALL   07B8
....................                         lcd_putc("%");
01FCE:  MOVLW  B6
01FD0:  MOVWF  FF6
01FD2:  MOVLW  05
01FD4:  MOVWF  FF7
01FD6:  CALL   0840
....................                         printf(lcd_putc, "%d ", accel * 10);
01FDA:  MOVF   22,W
01FDC:  MULLW  0A
01FDE:  MOVFF  FF3,72
01FE2:  MOVLW  18
01FE4:  MOVWF  x73
01FE6:  CALL   0942
01FEA:  MOVLW  20
01FEC:  MOVWF  x7E
01FEE:  CALL   07F8
.................... 
....................                         if (accel < 10)
01FF2:  MOVF   22,W
01FF4:  SUBLW  09
01FF6:  BNC   201E
....................                         {
....................                             printf("a0%d ", accel);
01FF8:  MOVLW  61
01FFA:  BTFSS  F9E.4
01FFC:  BRA    1FFA
01FFE:  MOVWF  FAD
02000:  MOVLW  30
02002:  BTFSS  F9E.4
02004:  BRA    2002
02006:  MOVWF  FAD
02008:  MOVFF  22,78
0200C:  MOVLW  18
0200E:  MOVWF  x79
02010:  CALL   0C54
02014:  MOVLW  20
02016:  BTFSS  F9E.4
02018:  BRA    2016
0201A:  MOVWF  FAD
....................                         }
0201C:  BRA    202A
....................                         else
....................                         {
....................                             printf("a10");
0201E:  MOVLW  B8
02020:  MOVWF  FF6
02022:  MOVLW  05
02024:  MOVWF  FF7
02026:  CALL   138E
....................                         }
.................... 
....................                         delay_ms(500);
0202A:  MOVLW  02
0202C:  MOVWF  x71
0202E:  MOVLW  FA
02030:  MOVWF  x7F
02032:  CALL   05CE
02036:  DECFSZ x71,F
02038:  BRA    202E
....................                     }
....................                 }
.................... 
....................                 ////////////////////////
.................... 
....................                 if (input(button4) == 1)
0203A:  BSF    F94.2
0203C:  BTFSS  F82.2
0203E:  BRA    20AA
....................                 {
.................... 
....................                     lcd_gotoxy(8, 1);
02040:  MOVLW  08
02042:  MOVWF  x7F
02044:  MOVLW  01
02046:  MOVWF  x80
02048:  CALL   07B8
....................                     lcd_putc("%");
0204C:  MOVLW  BC
0204E:  MOVWF  FF6
02050:  MOVLW  05
02052:  MOVWF  FF7
02054:  CALL   0840
....................                     printf(lcd_putc, "%d", delay_s * 10);
02058:  MOVF   20,W
0205A:  MULLW  0A
0205C:  MOVFF  FF3,72
02060:  MOVLW  18
02062:  MOVWF  x73
02064:  CALL   0942
.................... 
....................                     lcd_gotoxy(8, 2);
02068:  MOVLW  08
0206A:  MOVWF  x7F
0206C:  MOVLW  02
0206E:  MOVWF  x80
02070:  CALL   07B8
....................                     lcd_putc("%");
02074:  MOVLW  BE
02076:  MOVWF  FF6
02078:  MOVLW  05
0207A:  MOVWF  FF7
0207C:  CALL   0840
....................                     printf(lcd_putc, "%d", accel * 10);
02080:  MOVF   22,W
02082:  MULLW  0A
02084:  MOVFF  FF3,72
02088:  MOVLW  18
0208A:  MOVWF  x73
0208C:  CALL   0942
.................... 
....................                     mode_cursor--;
02090:  DECF   x6A,F
.................... 
....................                     if (mode_cursor <= 0)
02092:  MOVF   x6A,F
02094:  BNZ   209A
....................                     {
....................                         mode_cursor = 2;
02096:  MOVLW  02
02098:  MOVWF  x6A
....................                     }
....................                     delay_ms(500);
0209A:  MOVLW  02
0209C:  MOVWF  x71
0209E:  MOVLW  FA
020A0:  MOVWF  x7F
020A2:  CALL   05CE
020A6:  DECFSZ x71,F
020A8:  BRA    209E
....................                 }
.................... 
....................                 if (input(button2) == 1)
020AA:  BSF    F95.0
020AC:  BTFSS  F83.0
020AE:  BRA    211C
....................                 {
.................... 
....................                     lcd_gotoxy(8, 1);
020B0:  MOVLW  08
020B2:  MOVWF  x7F
020B4:  MOVLW  01
020B6:  MOVWF  x80
020B8:  CALL   07B8
....................                     lcd_putc("%");
020BC:  MOVLW  C0
020BE:  MOVWF  FF6
020C0:  MOVLW  05
020C2:  MOVWF  FF7
020C4:  CALL   0840
....................                     printf(lcd_putc, "%d", delay_s * 10);
020C8:  MOVF   20,W
020CA:  MULLW  0A
020CC:  MOVFF  FF3,72
020D0:  MOVLW  18
020D2:  MOVWF  x73
020D4:  CALL   0942
.................... 
....................                     lcd_gotoxy(8, 2);
020D8:  MOVLW  08
020DA:  MOVWF  x7F
020DC:  MOVLW  02
020DE:  MOVWF  x80
020E0:  CALL   07B8
....................                     lcd_putc("%");
020E4:  MOVLW  C2
020E6:  MOVWF  FF6
020E8:  MOVLW  05
020EA:  MOVWF  FF7
020EC:  CALL   0840
....................                     printf(lcd_putc, "%d", accel * 10);
020F0:  MOVF   22,W
020F2:  MULLW  0A
020F4:  MOVFF  FF3,72
020F8:  MOVLW  18
020FA:  MOVWF  x73
020FC:  CALL   0942
.................... 
....................                     mode_cursor++;
02100:  INCF   x6A,F
.................... 
....................                     if (mode_cursor >= 3)
02102:  MOVF   x6A,W
02104:  SUBLW  02
02106:  BC    210C
....................                     {
....................                         mode_cursor = 1;
02108:  MOVLW  01
0210A:  MOVWF  x6A
....................                     }
....................                     delay_ms(500);
0210C:  MOVLW  02
0210E:  MOVWF  x71
02110:  MOVLW  FA
02112:  MOVWF  x7F
02114:  CALL   05CE
02118:  DECFSZ x71,F
0211A:  BRA    2110
....................                 }
.................... 
....................                 if (input(button5) == 1)
0211C:  BSF    F94.1
0211E:  BTFSS  F82.1
02120:  BRA    2134
....................                 {
....................                     delay_ms(500);
02122:  MOVLW  02
02124:  MOVWF  x71
02126:  MOVLW  FA
02128:  MOVWF  x7F
0212A:  CALL   05CE
0212E:  DECFSZ x71,F
02130:  BRA    2126
....................                     break;
02132:  BRA    2136
....................                 }
02134:  BRA    1C14
....................             }
....................             
....................             correct=False;
02136:  CLRF   2E
....................         }
.................... 
....................         //////////////>>>>>>>>> SERIAL COMM <<<<<<<<///////////
.................... 
....................         if (correct) { // full data received
02138:  MOVF   2E,F
0213A:  BTFSC  FD8.2
0213C:  BRA    223E
....................             //restart_wdt();
....................             read_serial_mode();
0213E:  CALL   0A52
....................             read_serial_speed();
02142:  CALL   0AAC
....................             read_serial_acc();
02146:  CALL   0B2A
.................... 
....................             if (str[0] == 'c')
0214A:  MOVF   29,W
0214C:  SUBLW  63
0214E:  BNZ   2158
....................             {
....................                 centerline(6);
02150:  MOVLW  06
02152:  MOVWF  x72
02154:  CALL   0E9A
....................             }
.................... 
....................             if (str[0] == 'g')
02158:  MOVF   29,W
0215A:  SUBLW  67
0215C:  BNZ   2162
....................             {
....................                 gogo();
0215E:  CALL   10CE
....................             }
.................... 
....................             if (str[0] == 'd')// usb connected, send commands to pc
02162:  MOVF   29,W
02164:  SUBLW  64
02166:  BNZ   223E
....................             { 
....................                 printf("x");
02168:  MOVLW  78
0216A:  BTFSS  F9E.4
0216C:  BRA    216A
0216E:  MOVWF  FAD
....................                 delay_ms(50);
02170:  MOVLW  32
02172:  MOVWF  x7F
02174:  CALL   05CE
....................                 printf("h0%d", delay_s);
02178:  MOVLW  68
0217A:  BTFSS  F9E.4
0217C:  BRA    217A
0217E:  MOVWF  FAD
02180:  MOVLW  30
02182:  BTFSS  F9E.4
02184:  BRA    2182
02186:  MOVWF  FAD
02188:  MOVFF  20,78
0218C:  MOVLW  18
0218E:  MOVWF  x79
02190:  CALL   0C54
....................                 delay_ms(50);
02194:  MOVLW  32
02196:  MOVWF  x7F
02198:  CALL   05CE
....................                 printf("a0%d", accel);
0219C:  MOVLW  61
0219E:  BTFSS  F9E.4
021A0:  BRA    219E
021A2:  MOVWF  FAD
021A4:  MOVLW  30
021A6:  BTFSS  F9E.4
021A8:  BRA    21A6
021AA:  MOVWF  FAD
021AC:  MOVFF  22,78
021B0:  MOVLW  18
021B2:  MOVWF  x79
021B4:  CALL   0C54
....................                 delay_ms(50);
021B8:  MOVLW  32
021BA:  MOVWF  x7F
021BC:  CALL   05CE
.................... 
....................                 if (mode_manuel)
021C0:  MOVF   26,F
021C2:  BZ    21D4
....................                 {
....................                     printf("m0");
021C4:  MOVLW  6D
021C6:  BTFSS  F9E.4
021C8:  BRA    21C6
021CA:  MOVWF  FAD
021CC:  MOVLW  30
021CE:  BTFSS  F9E.4
021D0:  BRA    21CE
021D2:  MOVWF  FAD
....................                 }
.................... 
....................                 if (mode_auto)
021D4:  MOVF   25,F
021D6:  BZ    21E8
....................                 {
....................                     printf("m1");
021D8:  MOVLW  6D
021DA:  BTFSS  F9E.4
021DC:  BRA    21DA
021DE:  MOVWF  FAD
021E0:  MOVLW  31
021E2:  BTFSS  F9E.4
021E4:  BRA    21E2
021E6:  MOVWF  FAD
....................                 }
.................... 
....................                 delay_ms(50);
021E8:  MOVLW  32
021EA:  MOVWF  x7F
021EC:  CALL   05CE
.................... 
....................                 if (centered)
021F0:  MOVF   34,F
021F2:  BZ    2208
....................                 {
....................                     printf("t%d", threshold);
021F4:  MOVLW  74
021F6:  BTFSS  F9E.4
021F8:  BRA    21F6
021FA:  MOVWF  FAD
021FC:  MOVFF  40,78
02200:  MOVLW  18
02202:  MOVWF  x79
02204:  CALL   0C54
....................                 }
.................... 
....................                 delay_ms(50);
02208:  MOVLW  32
0220A:  MOVWF  x7F
0220C:  CALL   05CE
....................                 int8 step_data = step / 10;
02210:  MOVFF  3B,79
02214:  MOVFF  3A,78
02218:  CLRF   x7B
0221A:  MOVLW  0A
0221C:  MOVWF  x7A
0221E:  CALL   0C12
02222:  MOVFF  01,6C
....................                 printf("q%d", step_data);
02226:  MOVLW  71
02228:  BTFSS  F9E.4
0222A:  BRA    2228
0222C:  MOVWF  FAD
0222E:  MOVFF  6C,78
02232:  MOVLW  18
02234:  MOVWF  x79
02236:  CALL   0C54
....................                 
....................                 str[0]='0';
0223A:  MOVLW  30
0223C:  MOVWF  29
....................             }
.................... 
....................         // correct=False;
....................         
....................         }
.................... 
....................         ///////////>>>>>>> SELECT MANUEL or AUTO <<<<<<<<<///////
....................         while (input(button0)) // select auto
0223E:  BSF    F95.5
02240:  BTFSS  F83.5
02242:  BRA    22EC
....................         {
.................... 
....................             delay_ms(500);
02244:  MOVLW  02
02246:  MOVWF  x71
02248:  MOVLW  FA
0224A:  MOVWF  x7F
0224C:  CALL   05CE
02250:  DECFSZ x71,F
02252:  BRA    2248
.................... 
....................             if (flag)
02254:  MOVF   27,F
02256:  BZ    22D0
....................             {
....................                 flag = False;
02258:  CLRF   27
....................                 mode_AUTO = True;
0225A:  MOVLW  01
0225C:  MOVWF  25
....................                 mode_manuel = False;
0225E:  CLRF   26
.................... 
....................                 lcd_gotoxy(13, 1);
02260:  MOVLW  0D
02262:  MOVWF  x7F
02264:  MOVLW  01
02266:  MOVWF  x80
02268:  CALL   07B8
....................                 lcd_putc("< Auto >");
0226C:  MOVLW  C4
0226E:  MOVWF  FF6
02270:  MOVLW  05
02272:  MOVWF  FF7
02274:  CALL   0840
....................                 printf("m1");
02278:  MOVLW  6D
0227A:  BTFSS  F9E.4
0227C:  BRA    227A
0227E:  MOVWF  FAD
02280:  MOVLW  31
02282:  BTFSS  F9E.4
02284:  BRA    2282
02286:  MOVWF  FAD
.................... 
....................                 start = True;
02288:  MOVLW  01
0228A:  MOVWF  44
.................... 
....................                 while (TRUE)
....................                 {
.................... 
....................                     acc_start_normal_auto();
0228C:  CALL   13B0
.................... 
....................                     if (return_value == False)
02290:  MOVF   46,F
02292:  BNZ   229A
....................                     {
....................                         return_value = True;
02294:  MOVLW  01
02296:  MOVWF  46
....................                         break;
02298:  BRA    22CE
....................                     }
.................... 
....................                     normal();
0229A:  CALL   0E6E
.................... 
....................                     if (input(button2) | input(button3) | input(button4) | check_right_proxy())
0229E:  BSF    F95.0
022A0:  MOVLW  00
022A2:  BTFSC  F83.0
022A4:  MOVLW  01
022A6:  MOVWF  x71
022A8:  BSF    F94.3
022AA:  MOVLW  00
022AC:  BTFSC  F82.3
022AE:  MOVLW  01
022B0:  IORWF  x71,F
022B2:  BSF    F94.2
022B4:  MOVLW  00
022B6:  BTFSC  F82.2
022B8:  MOVLW  01
022BA:  IORWF  x71,F
022BC:  CALL   0E08
022C0:  MOVF   x71,W
022C2:  IORWF  01,W
022C4:  BZ    22CC
....................                     {
....................                         stop();
022C6:  CALL   0C00
....................                         break;
022CA:  BRA    22CE
....................                     }
022CC:  BRA    228C
....................                 }
....................             }
022CE:  BRA    22EA
.................... 
....................             else
....................             {
....................                 flag = TRUE;
022D0:  MOVLW  01
022D2:  MOVWF  27
....................                 mode_AUTO = FALSE;
022D4:  CLRF   25
....................                 mode_manuel = TRUE;
022D6:  MOVWF  26
....................                 printf("m0");
022D8:  MOVLW  6D
022DA:  BTFSS  F9E.4
022DC:  BRA    22DA
022DE:  MOVWF  FAD
022E0:  MOVLW  30
022E2:  BTFSS  F9E.4
022E4:  BRA    22E2
022E6:  MOVWF  FAD
....................                 break;
022E8:  BRA    22EC
....................             }
022EA:  BRA    223E
....................         }
.................... 
....................         ////////////////>>>>>> MANUEL <<<<< ////////////////////
....................         start = True;
022EC:  MOVLW  01
022EE:  MOVWF  44
....................         q = False;
022F0:  CLRF   45
.................... 
....................         while (input(button1) & mode_manuel | ( str[0] == 'l' & str[1] == '0' )) //left
022F2:  BSF    F95.1
022F4:  MOVLW  00
022F6:  BTFSC  F83.1
022F8:  MOVLW  01
022FA:  ANDWF  26,W
022FC:  MOVWF  x71
022FE:  MOVF   29,W
02300:  SUBLW  6C
02302:  BZ    2308
02304:  MOVLW  00
02306:  BRA    230A
02308:  MOVLW  01
0230A:  MOVWF  x72
0230C:  MOVF   2A,W
0230E:  SUBLW  30
02310:  BZ    2316
02312:  MOVLW  00
02314:  BRA    2318
02316:  MOVLW  01
02318:  ANDWF  x72,W
0231A:  IORWF  x71,W
0231C:  BZ    2358
....................         {   
....................              enable_interrupts(INT_RDA);
0231E:  BSF    F9D.5
....................              
....................                //restart_wdt();
....................             if (check_right_proxy() | input(button3))
02320:  CALL   0E08
02324:  MOVFF  01,71
02328:  BSF    F94.3
0232A:  MOVLW  00
0232C:  BTFSC  F82.3
0232E:  MOVLW  01
02330:  IORWF  01,W
02332:  BZ    233C
....................             {
....................                 stop();
02334:  CALL   0C00
....................                 // correct = False;
....................                 disable_interrupts(INT_TIMER1);
02338:  BCF    F9D.0
....................                 break;
0233A:  BRA    2358
....................             }
....................             
....................             acc_start_normal_man();
0233C:  GOTO   143C
.................... 
....................             if (!(return_value))
02340:  MOVF   46,F
02342:  BNZ   234A
....................             {
....................                 return_value = True;
02344:  MOVLW  01
02346:  MOVWF  46
....................                 break;
02348:  BRA    2358
....................             }
.................... 
....................             speed = delay_s;
0234A:  MOVFF  20,21
....................             normal();
0234E:  CALL   0E6E
....................             quit1 = True;
02352:  MOVLW  01
02354:  MOVWF  2F
02356:  BRA    22F2
....................         }
.................... 
....................         while (input(button3) & mode_manuel |  (str[0] == 'r' & str[1] == '0' )) //right
02358:  BSF    F94.3
0235A:  MOVLW  00
0235C:  BTFSC  F82.3
0235E:  MOVLW  01
02360:  ANDWF  26,W
02362:  MOVWF  x71
02364:  MOVF   29,W
02366:  SUBLW  72
02368:  BZ    236E
0236A:  MOVLW  00
0236C:  BRA    2370
0236E:  MOVLW  01
02370:  MOVWF  x72
02372:  MOVF   2A,W
02374:  SUBLW  30
02376:  BZ    237C
02378:  MOVLW  00
0237A:  BRA    237E
0237C:  MOVLW  01
0237E:  ANDWF  x72,W
02380:  IORWF  x71,W
02382:  BZ    23BE
....................         {   
....................             //restart_wdt();
....................              enable_interrupts(INT_RDA);
02384:  BSF    F9D.5
....................              
....................              
....................             if (check_left_proxy() | input(button1) )
02386:  CALL   0BA8
0238A:  MOVFF  01,71
0238E:  BSF    F95.1
02390:  MOVLW  00
02392:  BTFSC  F83.1
02394:  MOVLW  01
02396:  IORWF  01,W
02398:  BZ    23A2
....................             {
....................                 stop();
0239A:  CALL   0C00
....................                 // correct = False;
....................                 disable_interrupts(INT_TIMER1);
0239E:  BCF    F9D.0
....................                 break;
023A0:  BRA    23BE
....................             }
....................             
....................              
....................             acc_start_reverse_man();
023A2:  GOTO   14AC
.................... 
....................             if (!(return_value ))
023A6:  MOVF   46,F
023A8:  BNZ   23B0
....................             {
....................                 return_value = True;
023AA:  MOVLW  01
023AC:  MOVWF  46
....................                 break;
023AE:  BRA    23BE
....................             }
.................... 
....................             speed = delay_s;
023B0:  MOVFF  20,21
....................             reverse();
023B4:  CALL   0DFE
....................             quit2 = True;
023B8:  MOVLW  01
023BA:  MOVWF  30
023BC:  BRA    2358
....................         }
.................... 
....................         while (quit2)
023BE:  MOVF   30,F
023C0:  BZ    2412
....................         {
....................         //restart_wdt();
....................             for (int i = 0; i < 10 - accel; i++)
023C2:  CLRF   x6D
023C4:  MOVLW  0A
023C6:  BSF    FD8.0
023C8:  SUBFWB 22,W
023CA:  SUBWF  x6D,W
023CC:  BC    240A
....................             {  
....................                 enable_interrupts(INT_RDA);
023CE:  BSF    F9D.5
....................                 for (int j = 0; j < accel_value; j++)
023D0:  CLRF   x6E
023D2:  MOVF   23,W
023D4:  SUBWF  x6E,W
023D6:  BC    2402
....................                 {
....................                     enable_interrupts(INT_RDA);
023D8:  BSF    F9D.5
....................                     if (input(button1) | check_left_proxy())
023DA:  BSF    F95.1
023DC:  MOVLW  00
023DE:  BTFSC  F83.1
023E0:  MOVLW  01
023E2:  MOVWF  x71
023E4:  CALL   0BA8
023E8:  MOVF   x71,W
023EA:  IORWF  01,W
023EC:  BZ    23F6
....................                     {
....................                         stop();
023EE:  CALL   0C00
....................                         disable_interrupts(INT_TIMER1);
023F2:  BCF    F9D.0
....................                         break;
023F4:  BRA    2402
....................                     }
.................... 
....................                     speed = c;
023F6:  MOVFF  24,21
....................                     reverse();
023FA:  CALL   0DFE
023FE:  INCF   x6E,F
02400:  BRA    23D2
....................                 }
....................                 c = c - 1;
02402:  MOVLW  01
02404:  SUBWF  24,F
02406:  INCF   x6D,F
02408:  BRA    23C4
....................             }
....................             quit2 = False;
0240A:  CLRF   30
....................             stop();
0240C:  CALL   0C00
02410:  BRA    23BE
....................         }
.................... 
....................         while (quit1)
02412:  MOVF   2F,F
02414:  BZ    2466
....................         {
....................         //restart_wdt();
....................             for (int i = 0; i < 10 - accel; i++)
02416:  CLRF   x6F
02418:  MOVLW  0A
0241A:  BSF    FD8.0
0241C:  SUBFWB 22,W
0241E:  SUBWF  x6F,W
02420:  BC    245E
....................             {   
....................                  enable_interrupts(INT_RDA);
02422:  BSF    F9D.5
....................                 for (int j = 0; j < accel_value; j++)
02424:  CLRF   x70
02426:  MOVF   23,W
02428:  SUBWF  x70,W
0242A:  BC    2456
....................                 {
....................                     enable_interrupts(INT_RDA);
0242C:  BSF    F9D.5
.................... 
....................                     if (input(button3) | check_right_proxy())
0242E:  BSF    F94.3
02430:  MOVLW  00
02432:  BTFSC  F82.3
02434:  MOVLW  01
02436:  MOVWF  x71
02438:  CALL   0E08
0243C:  MOVF   x71,W
0243E:  IORWF  01,W
02440:  BZ    244A
....................                     {
....................                         stop();
02442:  CALL   0C00
....................                         disable_interrupts(INT_TIMER1);
02446:  BCF    F9D.0
....................                         break;
02448:  BRA    2456
....................                     }
.................... 
....................                     speed = c;
0244A:  MOVFF  24,21
....................                     normal();
0244E:  CALL   0E6E
02452:  INCF   x70,F
02454:  BRA    2426
....................                 }
....................                 c = c - 1;
02456:  MOVLW  01
02458:  SUBWF  24,F
0245A:  INCF   x6F,F
0245C:  BRA    2418
....................             }
....................             quit1 = False;
0245E:  CLRF   2F
....................             stop();
02460:  CALL   0C00
02464:  BRA    2412
....................         }
.................... 
....................         stop();
02466:  CALL   0C00
.................... 
....................         ////////////////////>>>>>> AUTO <<<<</////////////////////
.................... 
....................         if (input(button1) & mode_auto | (str[0] == 'l' & str[1] == '1'))
0246A:  BSF    F95.1
0246C:  MOVLW  00
0246E:  BTFSC  F83.1
02470:  MOVLW  01
02472:  ANDWF  25,W
02474:  MOVWF  x71
02476:  MOVF   29,W
02478:  SUBLW  6C
0247A:  BZ    2480
0247C:  MOVLW  00
0247E:  BRA    2482
02480:  MOVLW  01
02482:  MOVWF  x72
02484:  MOVF   2A,W
02486:  SUBLW  31
02488:  BZ    248E
0248A:  MOVLW  00
0248C:  BRA    2490
0248E:  MOVLW  01
02490:  ANDWF  x72,W
02492:  IORWF  x71,W
02494:  BZ    250E
....................         {
....................          
....................             delay_ms(250);
02496:  MOVLW  FA
02498:  MOVWF  x7F
0249A:  CALL   05CE
....................             start = True;
0249E:  MOVLW  01
024A0:  MOVWF  44
....................             str[0] = 'l'; str[1] = '1';
024A2:  MOVLW  6C
024A4:  MOVWF  29
024A6:  MOVLW  31
024A8:  MOVWF  2A
....................             
....................             while (TRUE)
....................             {
....................                enable_interrupts(INT_RDA);
024AA:  BSF    F9D.5
....................                 acc_start_normal_auto();
024AC:  CALL   13B0
.................... 
....................                 if (return_value == False)
024B0:  MOVF   46,F
024B2:  BNZ   24BA
....................                 {
....................                     return_value = True;
024B4:  MOVLW  01
024B6:  MOVWF  46
....................                     break;
024B8:  BRA    250E
....................                 }
.................... 
....................                 normal();
024BA:  CALL   0E6E
.................... 
....................                 if (input(button2) | input(button3) | input(button4) | check_right_proxy() | str[0] != 'l' | str[1] != '1' )
024BE:  BSF    F95.0
024C0:  MOVLW  00
024C2:  BTFSC  F83.0
024C4:  MOVLW  01
024C6:  MOVWF  x71
024C8:  BSF    F94.3
024CA:  MOVLW  00
024CC:  BTFSC  F82.3
024CE:  MOVLW  01
024D0:  IORWF  x71,F
024D2:  BSF    F94.2
024D4:  MOVLW  00
024D6:  BTFSC  F82.2
024D8:  MOVLW  01
024DA:  IORWF  x71,F
024DC:  CALL   0E08
024E0:  MOVF   01,W
024E2:  IORWF  x71,F
024E4:  MOVF   29,W
024E6:  SUBLW  6C
024E8:  BNZ   24EE
024EA:  MOVLW  00
024EC:  BRA    24F0
024EE:  MOVLW  01
024F0:  IORWF  x71,F
024F2:  MOVF   2A,W
024F4:  SUBLW  31
024F6:  BNZ   24FC
024F8:  MOVLW  00
024FA:  BRA    24FE
024FC:  MOVLW  01
024FE:  IORWF  x71,W
02500:  BZ    250C
....................                 {
....................                     stop();
02502:  CALL   0C00
....................                     str[0]="0";
02506:  MOVLW  30
02508:  MOVWF  29
....................                     break;
0250A:  BRA    250E
....................                 }
0250C:  BRA    24AA
....................             }
....................         }
.................... 
....................         if (input(button3)& mode_auto | (str[0] == 'r' & str[1] == '1'))
0250E:  BSF    F94.3
02510:  MOVLW  00
02512:  BTFSC  F82.3
02514:  MOVLW  01
02516:  ANDWF  25,W
02518:  MOVWF  x71
0251A:  MOVF   29,W
0251C:  SUBLW  72
0251E:  BZ    2524
02520:  MOVLW  00
02522:  BRA    2526
02524:  MOVLW  01
02526:  MOVWF  x72
02528:  MOVF   2A,W
0252A:  SUBLW  31
0252C:  BZ    2532
0252E:  MOVLW  00
02530:  BRA    2534
02532:  MOVLW  01
02534:  ANDWF  x72,W
02536:  IORWF  x71,W
02538:  BZ    25B2
....................         {   
....................             delay_ms(250);
0253A:  MOVLW  FA
0253C:  MOVWF  x7F
0253E:  CALL   05CE
....................             start = True;
02542:  MOVLW  01
02544:  MOVWF  44
....................             str[0] = 'r'; str[1] = '1';
02546:  MOVLW  72
02548:  MOVWF  29
0254A:  MOVLW  31
0254C:  MOVWF  2A
.................... 
....................             while (TRUE)
....................             {
....................                enable_interrupts(INT_RDA);
0254E:  BSF    F9D.5
....................                 acc_start_reverse_auto();
02550:  GOTO   151E
.................... 
....................                 if (return_value == False)
02554:  MOVF   46,F
02556:  BNZ   255E
....................                 {
....................                     return_value = True;
02558:  MOVLW  01
0255A:  MOVWF  46
....................                     break;
0255C:  BRA    25B2
....................                 }
.................... 
....................                 reverse();
0255E:  CALL   0DFE
.................... 
....................                 if (input(button2) | input(button1) | input(button4) | check_left_proxy() | str[0] != 'r' | str[1] != '1')
02562:  BSF    F95.0
02564:  MOVLW  00
02566:  BTFSC  F83.0
02568:  MOVLW  01
0256A:  MOVWF  x71
0256C:  BSF    F95.1
0256E:  MOVLW  00
02570:  BTFSC  F83.1
02572:  MOVLW  01
02574:  IORWF  x71,F
02576:  BSF    F94.2
02578:  MOVLW  00
0257A:  BTFSC  F82.2
0257C:  MOVLW  01
0257E:  IORWF  x71,F
02580:  CALL   0BA8
02584:  MOVF   01,W
02586:  IORWF  x71,F
02588:  MOVF   29,W
0258A:  SUBLW  72
0258C:  BNZ   2592
0258E:  MOVLW  00
02590:  BRA    2594
02592:  MOVLW  01
02594:  IORWF  x71,F
02596:  MOVF   2A,W
02598:  SUBLW  31
0259A:  BNZ   25A0
0259C:  MOVLW  00
0259E:  BRA    25A2
025A0:  MOVLW  01
025A2:  IORWF  x71,W
025A4:  BZ    25B0
....................                 {
....................                     stop();
025A6:  CALL   0C00
....................                     str[0]="0";
025AA:  MOVLW  30
025AC:  MOVWF  29
....................                     break;
025AE:  BRA    25B2
....................                 }
025B0:  BRA    254E
....................             }
....................         }
.................... 
....................         ////////////////////>>>>>> CENTER <<<<<//////////////////////
....................         if (input(button2))
025B2:  BSF    F95.0
025B4:  BTFSS  F83.0
025B6:  BRA    25D0
....................         {
....................             delay_ms(500);
025B8:  MOVLW  02
025BA:  MOVWF  x71
025BC:  MOVLW  FA
025BE:  MOVWF  x7F
025C0:  CALL   05CE
025C4:  DECFSZ x71,F
025C6:  BRA    25BC
....................             centerline(6);
025C8:  MOVLW  06
025CA:  MOVWF  x72
025CC:  CALL   0E9A
....................         }
.................... 
....................         ////////////////////>>>>>> GOGO <<<<<//////////////////////
.................... 
....................         if (input(button4))
025D0:  BSF    F94.2
025D2:  BTFSS  F82.2
025D4:  BRA    25EE
....................         {
....................             delay_ms(500);
025D6:  MOVLW  02
025D8:  MOVWF  x71
025DA:  MOVLW  FA
025DC:  MOVWF  x7F
025DE:  CALL   05CE
025E2:  DECFSZ x71,F
025E4:  BRA    25DA
....................             str[0]='g';
025E6:  MOVLW  67
025E8:  MOVWF  29
....................             gogo();
025EA:  CALL   10CE
....................         }
025EE:  GOTO   1B50
....................     }
.................... }
.................... 
025F2:  SLEEP 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
