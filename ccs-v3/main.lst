CCS PCH C Compiler, Version 5.093, 4770               07-Eyl-22 17:14

               Filename:   C:\Users\furka\Desktop\Unity\lcd_stepper_control\main.lst

               ROM used:   9104 bytes (14%)
                           Largest free fragment is 56428
               RAM used:   118 (3%) at main() level
                           142 (4%) worst case
               Stack used: 10 locations (8 in main + 2 for interrupts)
               Stack size: 31

00000:  GOTO   1404
*
00008:  GOTO   0132
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  00,0E
00058:  MOVFF  01,0F
0005C:  MOVFF  02,10
00060:  MOVFF  03,11
00064:  BTFSS  F9D.0
00066:  GOTO   0070
0006A:  BTFSC  F9E.0
0006C:  GOTO   01A8
00070:  BTFSS  FA0.2
00072:  GOTO   007C
00076:  BTFSC  FA1.2
00078:  GOTO   034C
0007C:  MOVFF  0E,00
00080:  MOVFF  0F,01
00084:  MOVFF  10,02
00088:  MOVFF  11,03
0008C:  MOVFF  0C,FE9
00090:  MOVFF  07,FEA
00094:  BSF    07.7
00096:  MOVFF  08,FE1
0009A:  MOVFF  09,FE2
0009E:  MOVFF  0A,FD9
000A2:  MOVFF  0B,FDA
000A6:  MOVFF  12,FF3
000AA:  MOVFF  13,FF4
000AE:  MOVFF  14,FFA
000B2:  MOVFF  15,FF5
000B6:  MOVFF  16,FF6
000BA:  MOVFF  17,FF7
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46K22.h>
.................... //////////// Standard Header file for the PIC18F46K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46K22
000CA:  CLRF   FF7
000CC:  ADDLW  DA
000CE:  MOVWF  FF6
000D0:  MOVLW  00
000D2:  ADDWFC FF7,F
000D4:  TBLRD*+
000D6:  MOVF   FF5,W
000D8:  RETURN 0
000DA:  DATA 28,0C
000DC:  DATA 01,06
000DE:  CLRF   FF7
000E0:  ADDLW  EE
000E2:  MOVWF  FF6
000E4:  MOVLW  00
000E6:  ADDWFC FF7,F
000E8:  TBLRD*+
000EA:  MOVF   FF5,W
000EC:  RETURN 0
000EE:  DATA 00,00
000F0:  DATA 15,15
000F2:  DATA 15,15
000F4:  DATA 15,00
000F6:  DATA 1F,1F
000F8:  DATA 1F,1F
000FA:  DATA 1F,1F
000FC:  DATA 1F,1F
000FE:  DATA 1F,11
00100:  DATA 11,11
00102:  DATA 11,11
00104:  DATA 11,1F
00106:  DATA 20,00
00108:  DATA 20,00
0010A:  DATA 20,00
0010C:  DATA 20,20
0010E:  DATA 00,00
00110:  DATA 20,20
00112:  DATA 20,20
00114:  DATA 20,48
00116:  DATA 6F,6D
00118:  DATA 69,6E
0011A:  DATA 67,2E
0011C:  DATA 2E,2E
0011E:  DATA 20,20
00120:  DATA 20,20
00122:  DATA 00,00
00124:  DATA 0C,00
00126:  DATA 63,6F
00128:  DATA 75,6E
0012A:  DATA 74,3A
0012C:  DATA 20,25
0012E:  DATA 4C,75
00130:  DATA 00,00
*
0055A:  DATA 45,65
0055C:  DATA 70,72
0055E:  DATA 6F,6D
00560:  DATA 20,46
00562:  DATA 61,69
00564:  DATA 6C,00
00566:  DATA 43,65
00568:  DATA 6E,74
0056A:  DATA 65,65
0056C:  DATA 20,4D
0056E:  DATA 61,63
00570:  DATA 68,69
00572:  DATA 6E,65
00574:  DATA 00,00
00576:  DATA 53,70
00578:  DATA 65,65
0057A:  DATA 64,3A
0057C:  DATA 20,25
0057E:  DATA 20,20
00580:  DATA 20,00
00582:  DATA 3C,4D
00584:  DATA 61,6E
00586:  DATA 75,65
00588:  DATA 6C,3E
0058A:  DATA 00,00
0058C:  DATA 3C,20
0058E:  DATA 41,75
00590:  DATA 74,6F
00592:  DATA 20,3E
00594:  DATA 00,00
00596:  DATA 41,63
00598:  DATA 63,65
0059A:  DATA 6C,3A
0059C:  DATA 20,25
0059E:  DATA 20,20
005A0:  DATA 20,00
005A2:  DATA 43,65
005A4:  DATA 6E,74
005A6:  DATA 65,72
005A8:  DATA 20,4D
005AA:  DATA 61,63
005AC:  DATA 68,69
005AE:  DATA 6E,65
005B0:  DATA 00,00
005B2:  DATA 25,00
005B4:  DATA 20,20
005B6:  DATA 20,20
005B8:  DATA 00,00
005BA:  DATA 25,00
005BC:  DATA 25,00
005BE:  DATA 68,31
005C0:  DATA 30,00
005C2:  DATA 25,00
005C4:  DATA 20,20
005C6:  DATA 20,20
005C8:  DATA 00,00
005CA:  DATA 25,00
005CC:  DATA 25,00
005CE:  DATA 61,31
005D0:  DATA 30,00
005D2:  DATA 25,00
005D4:  DATA 25,00
005D6:  DATA 25,00
005D8:  DATA 25,00
005DA:  DATA 3C,20
005DC:  DATA 41,75
005DE:  DATA 74,6F
005E0:  DATA 20,3E
005E2:  DATA 00,00
*
00856:  TBLRD*+
00858:  MOVF   FF5,F
0085A:  BZ    0874
0085C:  MOVFF  FF6,78
00860:  MOVFF  FF7,79
00864:  MOVFF  FF5,7E
00868:  RCALL  080E
0086A:  MOVFF  78,FF6
0086E:  MOVFF  79,FF7
00872:  BRA    0856
00874:  RETURN 0
00876:  MOVFF  FEA,7D
0087A:  MOVFF  FE9,7C
0087E:  SWAPF  x76,W
00880:  IORLW  F0
00882:  MOVWF  x78
00884:  ADDWF  x78,F
00886:  ADDLW  E2
00888:  MOVWF  x79
0088A:  ADDLW  32
0088C:  MOVWF  x7B
0088E:  MOVF   x76,W
00890:  ANDLW  0F
00892:  ADDWF  x79,F
00894:  ADDWF  x79,F
00896:  ADDWF  x7B,F
00898:  ADDLW  E9
0089A:  MOVWF  x7A
0089C:  ADDWF  x7A,F
0089E:  ADDWF  x7A,F
008A0:  SWAPF  x75,W
008A2:  ANDLW  0F
008A4:  ADDWF  x7A,F
008A6:  ADDWF  x7B,F
008A8:  RLCF   x7A,F
008AA:  RLCF   x7B,F
008AC:  COMF   x7B,F
008AE:  RLCF   x7B,F
008B0:  MOVF   x75,W
008B2:  ANDLW  0F
008B4:  ADDWF  x7B,F
008B6:  RLCF   x78,F
008B8:  MOVLW  07
008BA:  MOVWF  x77
008BC:  MOVLW  0A
008BE:  DECF   x7A,F
008C0:  ADDWF  x7B,F
008C2:  BNC   08BE
008C4:  DECF   x79,F
008C6:  ADDWF  x7A,F
008C8:  BNC   08C4
008CA:  DECF   x78,F
008CC:  ADDWF  x79,F
008CE:  BNC   08CA
008D0:  DECF   x77,F
008D2:  ADDWF  x78,F
008D4:  BNC   08D0
008D6:  CLRF   FEA
008D8:  MOVLW  77
008DA:  MOVWF  FE9
008DC:  MOVLW  07
008DE:  ANDWF  x7C,W
008E0:  BCF    x7C.6
008E2:  ADDWF  FE9,F
008E4:  MOVLW  00
008E6:  ADDWFC FEA,F
008E8:  MOVF   FE9,W
008EA:  SUBLW  7B
008EC:  BNZ   08F4
008EE:  MOVF   FEA,F
008F0:  BNZ   08F4
008F2:  BSF    x7C.6
008F4:  MOVF   FEF,W
008F6:  MOVWF  00
008F8:  BNZ   090A
008FA:  BTFSC  x7C.6
008FC:  BRA    090A
008FE:  BTFSC  x7C.4
00900:  BRA    0928
00902:  BTFSC  x7C.3
00904:  BRA    090A
00906:  MOVLW  20
00908:  BRA    0910
0090A:  BSF    x7C.3
0090C:  BCF    x7C.4
0090E:  MOVLW  30
00910:  ADDWF  00,F
00912:  MOVFF  FEA,76
00916:  MOVFF  FE9,75
0091A:  MOVFF  00,7E
0091E:  RCALL  080E
00920:  MOVFF  76,FEA
00924:  MOVFF  75,FE9
00928:  MOVF   FEE,W
0092A:  BTFSS  x7C.6
0092C:  BRA    08E8
0092E:  RETURN 0
00930:  MOVF   x7F,W
00932:  CLRF   01
00934:  SUBWF  x7E,W
00936:  BC    093E
00938:  MOVFF  7E,00
0093C:  BRA    0956
0093E:  CLRF   00
00940:  MOVLW  08
00942:  MOVWF  x80
00944:  RLCF   x7E,F
00946:  RLCF   00,F
00948:  MOVF   x7F,W
0094A:  SUBWF  00,W
0094C:  BTFSC  FD8.0
0094E:  MOVWF  00
00950:  RLCF   01,F
00952:  DECFSZ x80,F
00954:  BRA    0944
00956:  RETURN 0
00958:  MOVLW  20
0095A:  BTFSS  x74.4
0095C:  MOVLW  30
0095E:  MOVWF  x75
00960:  MOVFF  73,00
00964:  BTFSS  x73.7
00966:  BRA    0978
00968:  COMF   00,F
0096A:  INCF   00,F
0096C:  MOVFF  00,73
00970:  MOVLW  2D
00972:  MOVWF  x75
00974:  BSF    x74.7
00976:  BSF    x74.0
00978:  MOVF   01,W
0097A:  MOVFF  73,7E
0097E:  MOVLW  64
00980:  MOVWF  x7F
00982:  RCALL  0930
00984:  MOVFF  00,73
00988:  MOVLW  30
0098A:  ADDWF  01,W
0098C:  MOVWF  x76
0098E:  MOVFF  73,7E
00992:  MOVLW  0A
00994:  MOVWF  x7F
00996:  RCALL  0930
00998:  MOVLW  30
0099A:  ADDWF  00,W
0099C:  MOVWF  x78
0099E:  MOVLW  30
009A0:  ADDWF  01,W
009A2:  MOVWF  x77
009A4:  MOVFF  75,00
009A8:  MOVLW  30
009AA:  SUBWF  x76,W
009AC:  BZ    09B6
009AE:  BSF    x74.1
009B0:  BTFSC  x74.7
009B2:  BSF    x74.2
009B4:  BRA    09DA
009B6:  MOVFF  75,76
009BA:  MOVLW  20
009BC:  MOVWF  x75
009BE:  MOVLW  30
009C0:  SUBWF  x77,W
009C2:  BZ    09CC
009C4:  BSF    x74.0
009C6:  BTFSC  x74.7
009C8:  BSF    x74.1
009CA:  BRA    09DA
009CC:  BTFSS  FD8.2
009CE:  BSF    x74.0
009D0:  BNZ   09DA
009D2:  MOVFF  76,77
009D6:  MOVLW  20
009D8:  MOVWF  x76
009DA:  BTFSC  x74.2
009DC:  BRA    09E8
009DE:  BTFSC  x74.1
009E0:  BRA    09EE
009E2:  BTFSC  x74.0
009E4:  BRA    09F4
009E6:  BRA    09FA
009E8:  MOVFF  75,7E
009EC:  RCALL  080E
009EE:  MOVFF  76,7E
009F2:  RCALL  080E
009F4:  MOVFF  77,7E
009F8:  RCALL  080E
009FA:  MOVFF  78,7E
009FE:  RCALL  080E
00A00:  RETURN 0
00A02:  MOVF   01,W
00A04:  MOVFF  73,7E
00A08:  MOVLW  64
00A0A:  MOVWF  x7F
00A0C:  RCALL  0930
00A0E:  MOVFF  00,73
00A12:  MOVF   01,W
00A14:  MOVLW  30
00A16:  BNZ   0A26
00A18:  BTFSS  x74.1
00A1A:  BRA    0A34
00A1C:  BTFSC  x74.3
00A1E:  BRA    0A34
00A20:  BTFSC  x74.4
00A22:  MOVLW  20
00A24:  BRA    0A2C
00A26:  BCF    x74.3
00A28:  BCF    x74.4
00A2A:  BSF    x74.0
00A2C:  ADDWF  01,F
00A2E:  MOVFF  01,7E
00A32:  RCALL  080E
00A34:  MOVFF  73,7E
00A38:  MOVLW  0A
00A3A:  MOVWF  x7F
00A3C:  RCALL  0930
00A3E:  MOVFF  00,73
00A42:  MOVF   01,W
00A44:  MOVLW  30
00A46:  BNZ   0A54
00A48:  BTFSC  x74.3
00A4A:  BRA    0A5C
00A4C:  BTFSS  x74.0
00A4E:  BRA    0A5C
00A50:  BTFSC  x74.4
00A52:  MOVLW  20
00A54:  ADDWF  01,F
00A56:  MOVFF  01,7E
00A5A:  RCALL  080E
00A5C:  MOVLW  30
00A5E:  ADDWF  x73,F
00A60:  MOVFF  73,7E
00A64:  RCALL  080E
00A66:  RETURN 0
00A68:  MOVLW  20
00A6A:  BTFSS  x79.4
00A6C:  MOVLW  30
00A6E:  MOVWF  x7A
00A70:  MOVFF  78,00
00A74:  BTFSS  x78.7
00A76:  BRA    0A88
00A78:  COMF   00,F
00A7A:  INCF   00,F
00A7C:  MOVFF  00,78
00A80:  MOVLW  2D
00A82:  MOVWF  x7A
00A84:  BSF    x79.7
00A86:  BSF    x79.0
00A88:  MOVF   01,W
00A8A:  MOVFF  78,7E
00A8E:  MOVLW  64
00A90:  MOVWF  x7F
00A92:  RCALL  0930
00A94:  MOVFF  00,78
00A98:  MOVLW  30
00A9A:  ADDWF  01,W
00A9C:  MOVWF  x7B
00A9E:  MOVFF  78,7E
00AA2:  MOVLW  0A
00AA4:  MOVWF  x7F
00AA6:  RCALL  0930
00AA8:  MOVLW  30
00AAA:  ADDWF  00,W
00AAC:  MOVWF  x7D
00AAE:  MOVLW  30
00AB0:  ADDWF  01,W
00AB2:  MOVWF  x7C
00AB4:  MOVFF  7A,00
00AB8:  MOVLW  30
00ABA:  SUBWF  x7B,W
00ABC:  BZ    0AC6
00ABE:  BSF    x79.1
00AC0:  BTFSC  x79.7
00AC2:  BSF    x79.2
00AC4:  BRA    0AEA
00AC6:  MOVFF  7A,7B
00ACA:  MOVLW  20
00ACC:  MOVWF  x7A
00ACE:  MOVLW  30
00AD0:  SUBWF  x7C,W
00AD2:  BZ    0ADC
00AD4:  BSF    x79.0
00AD6:  BTFSC  x79.7
00AD8:  BSF    x79.1
00ADA:  BRA    0AEA
00ADC:  BTFSS  FD8.2
00ADE:  BSF    x79.0
00AE0:  BNZ   0AEA
00AE2:  MOVFF  7B,7C
00AE6:  MOVLW  20
00AE8:  MOVWF  x7B
00AEA:  BTFSC  x79.2
00AEC:  BRA    0AF8
00AEE:  BTFSC  x79.1
00AF0:  BRA    0B00
00AF2:  BTFSC  x79.0
00AF4:  BRA    0B08
00AF6:  BRA    0B10
00AF8:  MOVF   x7A,W
00AFA:  BTFSS  F9E.4
00AFC:  BRA    0AFA
00AFE:  MOVWF  FAD
00B00:  MOVF   x7B,W
00B02:  BTFSS  F9E.4
00B04:  BRA    0B02
00B06:  MOVWF  FAD
00B08:  MOVF   x7C,W
00B0A:  BTFSS  F9E.4
00B0C:  BRA    0B0A
00B0E:  MOVWF  FAD
00B10:  MOVF   x7D,W
00B12:  BTFSS  F9E.4
00B14:  BRA    0B12
00B16:  MOVWF  FAD
00B18:  RETURN 0
00B1A:  TBLRD*+
00B1C:  MOVF   FF5,F
00B1E:  BZ    0B3A
00B20:  MOVFF  FF6,72
00B24:  MOVFF  FF7,73
00B28:  MOVF   FF5,W
00B2A:  BTFSS  F9E.4
00B2C:  BRA    0B2A
00B2E:  MOVWF  FAD
00B30:  MOVFF  72,FF6
00B34:  MOVFF  73,FF7
00B38:  BRA    0B1A
00B3A:  RETURN 0
*
00B62:  MOVLW  8E
00B64:  MOVWF  00
00B66:  MOVFF  73,01
00B6A:  MOVFF  72,02
00B6E:  CLRF   03
00B70:  MOVF   01,F
00B72:  BNZ   0B86
00B74:  MOVFF  02,01
00B78:  CLRF   02
00B7A:  MOVLW  08
00B7C:  SUBWF  00,F
00B7E:  MOVF   01,F
00B80:  BNZ   0B86
00B82:  CLRF   00
00B84:  BRA    0B96
00B86:  BCF    FD8.0
00B88:  BTFSC  01.7
00B8A:  BRA    0B94
00B8C:  RLCF   02,F
00B8E:  RLCF   01,F
00B90:  DECF   00,F
00B92:  BRA    0B86
00B94:  BCF    01.7
00B96:  RETURN 0
*
00CF8:  CLRF   01
00CFA:  CLRF   02
00CFC:  CLRF   00
00CFE:  CLRF   03
00D00:  MOVF   x7B,W
00D02:  BNZ   0D08
00D04:  MOVF   x7A,W
00D06:  BZ    0D38
00D08:  MOVLW  10
00D0A:  MOVWF  x7C
00D0C:  BCF    FD8.0
00D0E:  RLCF   x78,F
00D10:  RLCF   x79,F
00D12:  RLCF   00,F
00D14:  RLCF   03,F
00D16:  MOVF   x7B,W
00D18:  SUBWF  03,W
00D1A:  BNZ   0D20
00D1C:  MOVF   x7A,W
00D1E:  SUBWF  00,W
00D20:  BNC   0D30
00D22:  MOVF   x7A,W
00D24:  SUBWF  00,F
00D26:  BTFSS  FD8.0
00D28:  DECF   03,F
00D2A:  MOVF   x7B,W
00D2C:  SUBWF  03,F
00D2E:  BSF    FD8.0
00D30:  RLCF   01,F
00D32:  RLCF   02,F
00D34:  DECFSZ x7C,F
00D36:  BRA    0D0C
00D38:  RETURN 0
*
00EA8:  TBLRD*+
00EAA:  MOVFF  FF6,76
00EAE:  MOVFF  FF7,77
00EB2:  MOVFF  FF5,7E
00EB6:  RCALL  080E
00EB8:  MOVFF  76,FF6
00EBC:  MOVFF  77,FF7
00EC0:  DECFSZ x75,F
00EC2:  BRA    0EA8
00EC4:  GOTO   1000 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #fuses NOWDT      //No Watch Dog Timer
.................... 
.................... #use delay(internal=64MHz)
*
00160:  MOVLW  01
00162:  SUBWF  x8B,F
00164:  BNC   017C
00166:  CLRF   FEA
00168:  MOVLW  8B
0016A:  MOVWF  FE9
0016C:  MOVF   FEF,W
0016E:  BZ    017C
00170:  MOVLW  04
00172:  MOVWF  00
00174:  DECFSZ 00,F
00176:  BRA    0174
00178:  DECFSZ FEF,F
0017A:  BRA    0170
0017C:  GOTO   018A (RETURN)
*
005E4:  CLRF   FEA
005E6:  MOVLW  7F
005E8:  MOVWF  FE9
005EA:  MOVF   FEF,W
005EC:  BZ    060A
005EE:  MOVLW  14
005F0:  MOVWF  01
005F2:  CLRF   00
005F4:  DECFSZ 00,F
005F6:  BRA    05F4
005F8:  DECFSZ 01,F
005FA:  BRA    05F2
005FC:  MOVLW  BF
005FE:  MOVWF  00
00600:  DECFSZ 00,F
00602:  BRA    0600
00604:  BRA    0606
00606:  DECFSZ FEF,F
00608:  BRA    05EE
0060A:  RETURN 0
.................... #device HIGH_INTS = TRUE 
.................... #use timer(timer=0,tick=100us,bits=32,NOISR)
*
0077C:  MOVF   FD6,W
0077E:  MOVFF  FD7,03
00782:  BTFSS  FF2.2
00784:  BRA    079E
00786:  MOVLW  01
00788:  ADDWF  19,F
0078A:  BTFSC  FD8.0
0078C:  INCF   1A,F
0078E:  BTFSC  FD8.2
00790:  INCF   1B,F
00792:  BTFSC  FD8.2
00794:  INCF   1C,F
00796:  BCF    FF2.2
00798:  MOVF   FD6,W
0079A:  MOVFF  FD7,03
0079E:  MOVWF  00
007A0:  MOVFF  03,01
007A4:  MOVFF  19,02
007A8:  MOVFF  1A,03
007AC:  MOVF   1B,W
007AE:  RRCF   FE8,F
007B0:  RRCF   03,F
007B2:  RRCF   02,F
007B4:  RRCF   01,F
007B6:  RRCF   00,F
007B8:  RRCF   FE8,F
007BA:  RRCF   03,F
007BC:  RRCF   02,F
007BE:  RRCF   01,F
007C0:  RRCF   00,F
007C2:  RRCF   FE8,F
007C4:  RRCF   03,F
007C6:  RRCF   02,F
007C8:  RRCF   01,F
007CA:  RRCF   00,F
007CC:  RETURN 0
.................... #define TICK_TYPE unsigned int32
.................... 
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <flex_lcd420.c>
.................... // Flex_LCD420.c
.................... 
.................... // These pins are for my Microchip PicDem2-Plus board,
.................... // which I used to test this driver.
.................... // An external 20x4 LCD is connected to these pins.
.................... // Change these pins to match your own board's connections.
.................... 
.................... #define LCD_DB4   PIN_A4
.................... #define LCD_DB5   PIN_A5
.................... #define LCD_DB6   PIN_E0
.................... #define LCD_DB7   PIN_E1
.................... 
.................... #define LCD_RS    PIN_A1
.................... #define LCD_RW    PIN_A2
.................... #define LCD_E     PIN_A3
.................... 
.................... /*
.................... // To prove that the driver can be used with random
.................... // pins, I also tested it with these pins:
.................... #define LCD_DB4   PIN_D4
.................... #define LCD_DB5   PIN_B1
.................... #define LCD_DB6   PIN_C5
.................... #define LCD_DB7   PIN_B5
.................... 
.................... #define LCD_RS    PIN_E2
.................... #define LCD_RW    PIN_B2
.................... #define LCD_E     PIN_D6
.................... */
.................... 
.................... // If you want only a 6-pin interface to your LCD, then
.................... // connect the R/W pin on the LCD to ground, and comment
.................... // out the following line.  Doing so will save one PIC
.................... // pin, but at the cost of losing the ability to read from
.................... // the LCD.  It also makes the write time a little longer
.................... // because a static delay must be used, instead of polling
.................... // the LCD's busy bit.  Normally a 6-pin interface is only
.................... // used if you are running out of PIC pins, and you need
.................... // to use as few as possible for the LCD.
.................... #define USE_RW_PIN   1     
.................... 
.................... 
.................... // These are the line addresses for most 4x20 LCDs.
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x40
.................... #define LCD_LINE_3_ADDRESS 0x14
.................... #define LCD_LINE_4_ADDRESS 0x54
.................... 
.................... // These are the line addresses for LCD's which use
.................... // the Hitachi HD66712U controller chip.
.................... /*
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x20
.................... #define LCD_LINE_3_ADDRESS 0x40
.................... #define LCD_LINE_4_ADDRESS 0x60
.................... */
.................... 
.................... 
.................... //========================================
.................... 
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)
.................... 
.................... int8 lcd_line;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots
....................  0xc,                     // Display on
....................  1,                       // Clear display
....................  6                        // Increment cursor
....................  };
....................                              
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
.................... // Note:  !! converts an integer expression
.................... // to a boolean (1 or 0).
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
0060C:  BTFSC  x86.0
0060E:  BRA    0614
00610:  BCF    F89.4
00612:  BRA    0616
00614:  BSF    F89.4
00616:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
00618:  BTFSC  x86.1
0061A:  BRA    0620
0061C:  BCF    F89.5
0061E:  BRA    0622
00620:  BSF    F89.5
00622:  BCF    F92.5
....................  output_bit(LCD_DB6, !!(nibble & 4));   
00624:  BTFSC  x86.2
00626:  BRA    062C
00628:  BCF    F8D.0
0062A:  BRA    062E
0062C:  BSF    F8D.0
0062E:  BCF    F96.0
....................  output_bit(LCD_DB7, !!(nibble & 8));   
00630:  BTFSC  x86.3
00632:  BRA    0638
00634:  BCF    F8D.1
00636:  BRA    063A
00638:  BSF    F8D.1
0063A:  BCF    F96.1
.................... 
....................  delay_cycles(1);
0063C:  NOP   
....................  output_high(LCD_E);
0063E:  BCF    F92.3
00640:  BSF    F89.3
....................  delay_us(2);
00642:  MOVLW  0A
00644:  MOVWF  00
00646:  DECFSZ 00,F
00648:  BRA    0646
0064A:  NOP   
....................  output_low(LCD_E);
0064C:  BCF    F92.3
0064E:  BCF    F89.3
00650:  RETURN 0
.................... }
.................... 
.................... //-----------------------------------
.................... // This sub-routine is only called by lcd_read_byte().
.................... // It's not a stand-alone routine.  For example, the
.................... // R/W signal is set high by lcd_read_byte() before
.................... // this routine is called.     
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... // Create bit variables so that we can easily set
.................... // individual bits in the retval variable.
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
00652:  CLRF   x87
....................    
.................... output_high(LCD_E);
00654:  BCF    F92.3
00656:  BSF    F89.3
.................... delay_us(1);
00658:  MOVLW  05
0065A:  MOVWF  00
0065C:  DECFSZ 00,F
0065E:  BRA    065C
.................... 
.................... retval_0 = input(LCD_DB4);
00660:  BSF    F92.4
00662:  BCF    x87.0
00664:  BTFSC  F80.4
00666:  BSF    x87.0
.................... retval_1 = input(LCD_DB5);
00668:  BSF    F92.5
0066A:  BCF    x87.1
0066C:  BTFSC  F80.5
0066E:  BSF    x87.1
.................... retval_2 = input(LCD_DB6);
00670:  BSF    F96.0
00672:  BCF    x87.2
00674:  BTFSC  F84.0
00676:  BSF    x87.2
.................... retval_3 = input(LCD_DB7);
00678:  BSF    F96.1
0067A:  BCF    x87.3
0067C:  BTFSC  F84.1
0067E:  BSF    x87.3
....................  
.................... output_low(LCD_E);
00680:  BCF    F92.3
00682:  BCF    F89.3
.................... delay_us(1);
00684:  MOVLW  05
00686:  MOVWF  00
00688:  DECFSZ 00,F
0068A:  BRA    0688
....................    
.................... return(retval);   
0068C:  MOVFF  87,01
00690:  RETURN 0
.................... }   
.................... #endif
.................... 
.................... //---------------------------------------
.................... // Read a byte from the LCD and return it.
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
00692:  BCF    F92.2
00694:  BSF    F89.2
.................... delay_cycles(1);
00696:  NOP   
.................... 
.................... high = lcd_read_nibble();
00698:  RCALL  0652
0069A:  MOVFF  01,86
.................... 
.................... low = lcd_read_nibble();
0069E:  RCALL  0652
006A0:  MOVFF  01,85
.................... 
.................... return( (high<<4) | low);
006A4:  SWAPF  x86,W
006A6:  MOVWF  00
006A8:  MOVLW  F0
006AA:  ANDWF  00,F
006AC:  MOVF   00,W
006AE:  IORWF  x85,W
006B0:  MOVWF  01
006B2:  GOTO   06BC (RETURN)
.................... }
.................... #endif
.................... 
.................... //----------------------------------------
.................... // Send a byte to the LCD.
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
006B6:  BCF    F92.1
006B8:  BCF    F89.1
.................... 
.................... #ifdef USE_RW_PIN
.................... while(bit_test(lcd_read_byte(),7)) ;
006BA:  BRA    0692
006BC:  MOVFF  01,85
006C0:  BTFSC  01.7
006C2:  BRA    06BA
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
006C4:  MOVF   x83,F
006C6:  BZ    06CE
....................    output_high(LCD_RS);
006C8:  BCF    F92.1
006CA:  BSF    F89.1
006CC:  BRA    06D2
.................... else
....................    output_low(LCD_RS);
006CE:  BCF    F92.1
006D0:  BCF    F89.1
....................      
....................  delay_cycles(1);
006D2:  NOP   
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
006D4:  BCF    F92.2
006D6:  BCF    F89.2
.................... delay_cycles(1);
006D8:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
006DA:  BCF    F92.3
006DC:  BCF    F89.3
.................... 
.................... lcd_send_nibble(n >> 4);
006DE:  SWAPF  x84,W
006E0:  MOVWF  x85
006E2:  MOVLW  0F
006E4:  ANDWF  x85,F
006E6:  MOVFF  85,86
006EA:  RCALL  060C
.................... lcd_send_nibble(n & 0xf);
006EC:  MOVF   x84,W
006EE:  ANDLW  0F
006F0:  MOVWF  x85
006F2:  MOVWF  x86
006F4:  RCALL  060C
006F6:  RETURN 0
.................... }
.................... //----------------------------
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... lcd_line = 1;
006F8:  MOVLW  01
006FA:  MOVWF  1F
.................... 
.................... output_low(LCD_RS);
006FC:  BCF    F92.1
006FE:  BCF    F89.1
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
00700:  BCF    F92.2
00702:  BCF    F89.2
.................... #endif
.................... 
.................... output_low(LCD_E);
00704:  BCF    F92.3
00706:  BCF    F89.3
.................... 
.................... // Some LCDs require 15 ms minimum delay after
.................... // power-up.  Others require 30 ms.  I'm going
.................... // to set it to 35 ms, so it should work with
.................... // all of them.
.................... delay_ms(35);         
00708:  MOVLW  23
0070A:  MOVWF  x7F
0070C:  RCALL  05E4
.................... 
.................... for(i=0 ;i < 3; i++)
0070E:  CLRF   x72
00710:  MOVF   x72,W
00712:  SUBLW  02
00714:  BNC   0726
....................    {
....................     lcd_send_nibble(0x03);
00716:  MOVLW  03
00718:  MOVWF  x86
0071A:  RCALL  060C
....................     delay_ms(5);
0071C:  MOVLW  05
0071E:  MOVWF  x7F
00720:  RCALL  05E4
00722:  INCF   x72,F
00724:  BRA    0710
....................    }
.................... 
.................... lcd_send_nibble(0x02);
00726:  MOVLW  02
00728:  MOVWF  x86
0072A:  RCALL  060C
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
0072C:  CLRF   x72
0072E:  MOVF   x72,W
00730:  SUBLW  03
00732:  BNC   0746
....................    {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
00734:  CLRF   03
00736:  MOVF   x72,W
00738:  RCALL  00CA
0073A:  MOVWF  x73
0073C:  CLRF   x83
0073E:  MOVWF  x84
00740:  RCALL  06B6
....................    
....................     // If the R/W signal is not used, then
....................     // the busy bit can't be polled.  One of
....................     // the init commands takes longer than
....................     // the hard-coded delay of 50 us, so in
....................     // that case, lets just do a 5 ms delay
....................     // after all four of them.
....................     #ifndef USE_RW_PIN
00742:  INCF   x72,F
00744:  BRA    072E
....................     delay_ms(5);
....................     #endif
....................    }
00746:  GOTO   1510 (RETURN)
.................... 
.................... }
.................... 
.................... //----------------------------
.................... 
.................... void lcd_gotoxy(int8 x, int8 y)
.................... {
.................... int8 address;
.................... 
.................... 
.................... switch(y)
*
007CE:  MOVF   x80,W
007D0:  XORLW  01
007D2:  BZ    07E2
007D4:  XORLW  03
007D6:  BZ    07E6
007D8:  XORLW  01
007DA:  BZ    07EC
007DC:  XORLW  07
007DE:  BZ    07F2
007E0:  BRA    07F8
....................   {
....................    case 1:
....................      address = LCD_LINE_1_ADDRESS;
007E2:  CLRF   x81
....................      break;
007E4:  BRA    07FA
.................... 
....................    case 2:
....................      address = LCD_LINE_2_ADDRESS;
007E6:  MOVLW  40
007E8:  MOVWF  x81
....................      break;
007EA:  BRA    07FA
.................... 
....................    case 3:
....................      address = LCD_LINE_3_ADDRESS;
007EC:  MOVLW  14
007EE:  MOVWF  x81
....................      break;
007F0:  BRA    07FA
.................... 
....................    case 4:
....................      address = LCD_LINE_4_ADDRESS;
007F2:  MOVLW  54
007F4:  MOVWF  x81
....................      break;
007F6:  BRA    07FA
.................... 
....................    default:
....................      address = LCD_LINE_1_ADDRESS;
007F8:  CLRF   x81
....................      break;
....................      
....................   }
.................... 
.................... address += x-1;
007FA:  MOVLW  01
007FC:  SUBWF  x7F,W
007FE:  ADDWF  x81,F
.................... lcd_send_byte(0, 0x80 | address);
00800:  MOVF   x81,W
00802:  IORLW  80
00804:  MOVWF  x82
00806:  CLRF   x83
00808:  MOVWF  x84
0080A:  RCALL  06B6
0080C:  RETURN 0
.................... }
.................... 
.................... //-----------------------------
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
0080E:  MOVF   x7E,W
00810:  XORLW  0C
00812:  BZ    081E
00814:  XORLW  06
00816:  BZ    0832
00818:  XORLW  02
0081A:  BZ    0840
0081C:  BRA    084A
....................    {
....................     case '\f':
....................       lcd_send_byte(0,1);
0081E:  CLRF   x83
00820:  MOVLW  01
00822:  MOVWF  x84
00824:  RCALL  06B6
....................       lcd_line = 1;
00826:  MOVLW  01
00828:  MOVWF  1F
....................       delay_ms(2);
0082A:  MOVLW  02
0082C:  MOVWF  x7F
0082E:  RCALL  05E4
....................       break;
00830:  BRA    0854
....................    
....................     case '\n':
....................        lcd_gotoxy(1, ++lcd_line);
00832:  INCF   1F,F
00834:  MOVLW  01
00836:  MOVWF  x7F
00838:  MOVFF  1F,80
0083C:  RCALL  07CE
....................        break;
0083E:  BRA    0854
....................    
....................     case '\b':
....................        lcd_send_byte(0,0x10);
00840:  CLRF   x83
00842:  MOVLW  10
00844:  MOVWF  x84
00846:  RCALL  06B6
....................        break;
00848:  BRA    0854
....................    
....................     default:
....................        lcd_send_byte(1,c);
0084A:  MOVLW  01
0084C:  MOVWF  x83
0084E:  MOVFF  7E,84
00852:  RCALL  06B6
....................        break;
....................    }
00854:  RETURN 0
.................... }
.................... 
.................... //------------------------------
.................... #ifdef USE_RW_PIN
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(LCD_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... 
.................... #include <internal_eeprom.c>
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////                          internal_eeprom.c                             ////
.................... ////                                                                        ////
.................... ////       Utilities to write various data types to internal eeprom         ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                        ////
.................... ////   void write_int1_eeprom(address, int8 bitPosition, int1 data)         ////
.................... ////     Call to write one bit of data                                      ////
.................... ////                                                                        ////
.................... ////   int1 read_int1_eeprom(address, int8 bitPosition)                     ////
.................... ////     Call to read one bit of data                                       ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_int16_eeprom(address, int16 data)                         ////
.................... ////     Call to write a 16 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   void write_int16_eeprom(address, int16 data)                         ////
.................... ////     Call to read a 16 bit integer                                      ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_int32_eeprom(address, int32 data)                         ////
.................... ////     Call to write a 32 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int16 read_int32_eeprom(address)                                     ////
.................... ////     Call to read a 32 bit integer                                      ////
.................... ////                                                                        ////
.................... ////                                                                        ////
.................... ////   void write_float_eeprom(address, float data)                         ////
.................... ////     Call to write a 32 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float read_float_eeprom(address)                                     ////
.................... ////     Call to read a 32 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////  PCD only:                                                             ////
.................... ////   void write_int48_eeprom(address, int48 data)                         ////
.................... ////     Call to write a 48 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int48 read_int48_eeprom(address)                                     ////
.................... ////     Call to read a 48 bit integer                                      ////
.................... ////                                                                        ////
.................... ////   void write_int64_eeprom(address, int64 data)                         ////
.................... ////     Call to write a 64 bit integer                                     ////
.................... ////                                                                        ////
.................... ////   int64 read_int64_eeprom(address)                                     ////
.................... ////     Call to read a 64 bit integer                                      ////
.................... ////                                                                        ////
.................... ////   void write_float48_eeprom(address, float48 data)                     ////
.................... ////     Call to write a 48 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float48 read_float48_eeprom(address)                                 ////
.................... ////     Call to read a 48 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////   void write_float64_eeprom(address, float64 data)                     ////
.................... ////     Call to write a 64 bit floating point number                       ////
.................... ////                                                                        ////
.................... ////   float64 read_float64_eeprom(address)                                 ////
.................... ////     Call to read a 64 bit floating point number                        ////
.................... ////                                                                        ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2012 Custom Computer Services               ////
.................... //// This source code may only be used by licensed users of the CCS C       ////
.................... //// compiler.  This source code may only be distributed to other licensed  ////
.................... //// users of the CCS C compiler.  No other use, reproduction or            ////
.................... //// distribution is permitted without written permission. Derivative       ////
.................... //// programs created using this software in object code form are not       ////
.................... //// restricted in any way.                                                 ////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef INTERNAL_EEPROM_UTILITIES
.................... #define INTERNAL_EEPROM_UTILITIES
.................... 
.................... // Used to adjust the address range
.................... #ifndef INT_EEPROM_ADDRESS
....................    #if getenv("DATA_EEPROM") > 255
....................       #define INT_EEPROM_ADDRESS  unsigned int16
....................    #else
....................       #define INT_EEPROM_ADDRESS  unsigned int8
....................    #endif
.................... #endif
.................... 
.................... #ifndef INT_EEPROM_DATA_SIZE
....................    #ifdef (__PCD__)
....................       #define INT_EEPROM_DATA_SIZE unsigned int16
....................    #else
....................       #define INT_EEPROM_DATA_SIZE unsigned int8
....................    #endif
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... //// Internal EEPROM Functions
.................... ////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Write one bit to internal eeprom
.................... // Inputs:     1) An eeprom address
.................... //             2) The bit position (LSB == 0)
.................... //             3) The bit to write
.................... // Outputs:    None
.................... void write_int1_eeprom(INT_EEPROM_ADDRESS address, unsigned int8 bitPosition, int1 data)
.................... {
....................    INT_EEPROM_DATA_SIZE stored_data;
.................... 
....................    stored_data = read_eeprom(address);
.................... 
....................    if(data)
....................    {
....................       bit_set(stored_data, bitPosition);
....................    }
....................    else
....................    {
....................       bit_clear(stored_data, bitPosition);
....................    }
.................... 
....................    write_eeprom(address, stored_data);
.................... }
.................... 
.................... 
.................... // Purpose:    Read one bit from internal eeprom
.................... // Inputs:     1) An eeprom address
.................... //             2) The bit position (LSB == 0)
.................... // Outputs:    The bit read from internal eeprom
.................... int1 read_int1_eeprom(INT_EEPROM_ADDRESS address, unsigned int8 bitPosition)
.................... {
....................    return bit_test(read_eeprom(address), bitPosition);
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 16 bit number to internal eeprom
.................... // Inputs:     1) An eeprom address. Two eeprom locations will be used.
.................... //             2) The 16 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int16_eeprom(INT_EEPROM_ADDRESS address, unsigned int16 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address,data);
....................    #else
....................    int8 i;
.................... 
....................    for(i = 0; i < 2; ++i)
....................    {
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    }
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 16 bit number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 16 bit number read from internal eeprom
.................... unsigned int16 read_int16_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    #ifdef __PCD__
....................    return(read_eeprom(address));
....................    #else
....................    int8  i;
....................    int16 data;
.................... 
....................    for(i = 0; i < 2; ++i)
....................    {
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
....................    }
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 32 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used.
.................... //             2) The 32 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int32_eeprom(INT_EEPROM_ADDRESS address, unsigned int32 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address, &data, 4);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 32 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 32 bit integer read from internal eeprom
.................... unsigned int32 read_int32_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    #ifdef __PCD__
....................    return(read_eeprom(address, 4));
....................    #else
....................    int8  i;
....................    int32 data;
....................    
....................    for(i = 0; i < 4; i++)
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 32 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float_eeprom(INT_EEPROM_ADDRESS address, float32 data)
.................... {
....................    #ifdef __PCD__
....................    write_eeprom(address, &data, 4);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      write_eeprom(address + i, *((int8 *)(&data) + i));
....................    #endif
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 32 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float32 read_float_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float32 data;
.................... 
....................    #ifdef __PCD__
....................    read_eeprom(address, &data, 4);
....................    
....................    return(data);
....................    #else
....................    int8 i;
....................    
....................    for(i = 0; i < 4; i++)
....................      *((int8 *)(&data) + i) = read_eeprom(address + i);
.................... 
....................    return(data);
....................    #endif
.................... }
.................... 
.................... #ifdef __PCD__
.................... // Purpose:    Write a 48 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Six eeprom locations will be used.
.................... //             2) The 48 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int48_eeprom(INT_EEPROM_ADDRESS address, unsigned int48 data)
.................... {
....................    write_eeprom(address, &data, 6);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 48 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 48 bit integer read from internal eeprom
.................... unsigned int48 read_int48_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    return(read_eeprom(address, 6));
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 64 bit integer to internal eeprom
.................... // Inputs:     1) An eeprom address. Eight eeprom locations will be used.
.................... //             2) The 64 bit number to write to internal eeprom
.................... // Outputs:    None
.................... void write_int64_eeprom(INT_EEPROM_ADDRESS address, unsigned int64 data)
.................... {
....................    write_eeprom(address, &data, 8);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 64 bit integer from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The 64 bit integer read from internal eeprom
.................... unsigned int64 read_int64_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    return(read_eeprom(address, 8));
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 48 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Six eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float48_eeprom(INT_EEPROM_ADDRESS address, float48 data)
.................... {
....................    write_eeprom(address, &data, 6);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 48 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float48 read_float48_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float48 data;
.................... 
....................    read_eeprom(address, &data, 6);
....................    
....................    return(data);
.................... }
.................... 
.................... 
.................... // Purpose:    Write a 64 bit floating point number to internal eeprom
.................... // Inputs:     1) An eeprom address. Eight eeprom locations will be used.
.................... //             2) The floating point number to write to internal eeprom
.................... // Outputs:    None
.................... void write_float64_eeprom(INT_EEPROM_ADDRESS address, float64 data)
.................... {
....................    write_eeprom(address, &data, 8);
.................... }
.................... 
.................... 
.................... // Purpose:    Read a 64 bit floating point number from internal eeprom
.................... // Inputs:     An eeprom address
.................... // Outputs:    The floating point number read from the internal eeprom
.................... float64 read_float64_eeprom(INT_EEPROM_ADDRESS address)
.................... {
....................    float64 data;
.................... 
....................    read_eeprom(address, &data, 8);
....................    
....................    return(data);
.................... }
.................... 
.................... #endif   //__PCD__
....................    
.................... 
.................... #endif   //INTERNAL_EEPROM_UTILITIES
.................... 
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1)
.................... 
.................... #define A1 PIN_D2
.................... #define A2 PIN_B1
.................... #define B1 PIN_B0
.................... #define B2 PIN_C5
.................... 
.................... #define button0  PIN_D5 // select adc or pot
.................... #define button1  PIN_D1 //right
.................... #define button2  PIN_D0 //left
.................... #define button3  PIN_C3 //mid
.................... #define button4  PIN_C2 //mode
.................... #define button5  PIN_C1 //mode
.................... 
.................... #define proxy_right PIN_D6
.................... #define proxy_left PIN_D7
.................... 
.................... #define three_dot 0
.................... #define swon 1
.................... #define swoff 2
.................... 
.................... 
.................... int8 delay_s=5;
.................... int speed=0;
.................... int8 accel=6;
.................... int accel_value=30;
.................... int c=0;
.................... 
.................... char mode_auto=False;
.................... char mode_manuel=True;
.................... char flag=TRUE;
.................... 
.................... char data;
.................... char str[8];
.................... int counter=0;
.................... char correct= False;
.................... char quit1=False;
.................... char quit2=False;
.................... 
.................... char proxy=False;
.................... int control_left=1;
.................... int control_right=1;
.................... 
.................... char centered=False;
.................... unsigned int16 centercounter=65535;
.................... int8 cc1,cc2;
.................... char center_flag=False;
.................... 
.................... unsigned int16 step=350;
.................... int8 step1,step2;
.................... int line1=0;
.................... int linecheck=0;
.................... int8 threshold=0;
.................... int comm_counter=threshold-1;
.................... 
.................... char start=True;
.................... char q=False;
.................... char return_value=True;
.................... 
.................... int dir=0;
.................... char array1[]={'1','2','3','4','5','6','7','8','9'};
.................... int8 array2[]={1,2,3,4,5,6,7,8,9};
.................... TICK_TYPE StartTick,FinishTick,CurrentTick;
.................... 
.................... void delay_func(loop){
.................... 
.................... //delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(200);delay_cycles(250);delay_cycles(200);delay_cycles(200);
.................... delay_us(330);
*
00180:  MOVLW  02
00182:  MOVWF  x8A
00184:  MOVLW  A5
00186:  MOVWF  x8B
00188:  BRA    0160
0018A:  DECFSZ x8A,F
0018C:  BRA    0184
.................... for(int i=0;i<10-loop;i++){
0018E:  CLRF   x89
00190:  MOVLW  0A
00192:  BSF    FD8.0
00194:  SUBFWB x88,W
00196:  SUBWF  x89,W
00198:  BC    01A6
....................    //delay_cycles(200);
....................    delay_us(40);
0019A:  MOVLW  D5
0019C:  MOVWF  00
0019E:  DECFSZ 00,F
001A0:  BRA    019E
001A2:  INCF   x89,F
001A4:  BRA    0190
.................... }
001A6:  RETURN 0
.................... }
.................... 
.................... void stop(){
....................    output_low (A1);
*
00CE6:  BCF    F95.2
00CE8:  BCF    F8C.2
....................    output_low (A2);
00CEA:  BCF    F93.1
00CEC:  BCF    F8A.1
....................    output_low (B1);
00CEE:  BCF    F93.0
00CF0:  BCF    F8A.0
....................    output_low (B2);
00CF2:  BCF    F94.5
00CF4:  BCF    F8B.5
00CF6:  RETURN 0
....................    
.................... }
.................... 
.................... char check_right_proxy(){
.................... 
....................    if (input(proxy_right)){
*
00E3E:  BSF    F95.6
00E40:  BTFSS  F83.6
00E42:  BRA    0E7E
....................         proxy=True;
00E44:  MOVLW  01
00E46:  MOVWF  35
....................          
....................           if(!(control_right)){
00E48:  MOVF   37,F
00E4A:  BNZ   0E7C
....................             lcd_gotoxy(1,4);
00E4C:  MOVLW  01
00E4E:  MOVWF  x7F
00E50:  MOVLW  04
00E52:  MOVWF  x80
00E54:  RCALL  07CE
....................             lcd_putc(swon); 
00E56:  MOVLW  01
00E58:  MOVWF  x7E
00E5A:  RCALL  080E
....................             printf("y");
00E5C:  MOVLW  79
00E5E:  BTFSS  F9E.4
00E60:  BRA    0E5E
00E62:  MOVWF  FAD
....................             
....................             lcd_gotoxy(2,4);
00E64:  MOVLW  02
00E66:  MOVWF  x7F
00E68:  MOVLW  04
00E6A:  MOVWF  x80
00E6C:  RCALL  07CE
....................             lcd_putc(" ");
00E6E:  MOVLW  06
00E70:  MOVWF  FF6
00E72:  MOVLW  01
00E74:  MOVWF  FF7
00E76:  RCALL  0856
....................             
....................             control_right=True;
00E78:  MOVLW  01
00E7A:  MOVWF  37
....................         }
....................         
....................       }
00E7C:  BRA    0E96
....................       
....................    else {
....................    
....................       proxy=False;
00E7E:  CLRF   35
....................       
....................       if(control_left){
00E80:  MOVF   36,F
00E82:  BZ    0E96
....................          lcd_gotoxy(20,4);
00E84:  MOVLW  14
00E86:  MOVWF  x7F
00E88:  MOVLW  04
00E8A:  MOVWF  x80
00E8C:  RCALL  07CE
....................          lcd_putc(swoff);
00E8E:  MOVLW  02
00E90:  MOVWF  x7E
00E92:  RCALL  080E
....................          control_left=False;
00E94:  CLRF   36
....................       }
....................    }
....................    return proxy;
00E96:  MOVFF  35,01
00E9A:  RETURN 0
.................... }
.................... 
.................... char check_left_proxy(){
.................... 
....................    if (input(proxy_left)) {
*
00C98:  BSF    F95.7
00C9A:  BTFSS  F83.7
00C9C:  BRA    0CC8
....................         proxy=True;
00C9E:  MOVLW  01
00CA0:  MOVWF  35
....................         step=centercounter;
00CA2:  MOVFF  3A,3F
00CA6:  MOVFF  39,3E
....................          
....................         //if(!(control_left)){
....................             lcd_gotoxy(20,4);
00CAA:  MOVLW  14
00CAC:  MOVWF  x7F
00CAE:  MOVLW  04
00CB0:  MOVWF  x80
00CB2:  RCALL  07CE
....................             lcd_putc(swon); 
00CB4:  MOVLW  01
00CB6:  MOVWF  x7E
00CB8:  RCALL  080E
....................             printf("x");
00CBA:  MOVLW  78
00CBC:  BTFSS  F9E.4
00CBE:  BRA    0CBC
00CC0:  MOVWF  FAD
....................             control_left=True;
00CC2:  MOVLW  01
00CC4:  MOVWF  36
....................         //}
....................         
....................       }
00CC6:  BRA    0CE0
....................        
....................    else {
....................    
....................       proxy=False;
00CC8:  CLRF   35
....................       
....................       if(control_right){
00CCA:  MOVF   37,F
00CCC:  BZ    0CE0
....................          lcd_gotoxy(1,4);
00CCE:  MOVLW  01
00CD0:  MOVWF  x7F
00CD2:  MOVLW  04
00CD4:  MOVWF  x80
00CD6:  RCALL  07CE
....................          lcd_putc(swoff);
00CD8:  MOVLW  02
00CDA:  MOVWF  x7E
00CDC:  RCALL  080E
....................          control_right=False;
00CDE:  CLRF   37
....................       }
....................      
....................    }
....................    
....................    return proxy;
00CE0:  MOVFF  35,01
00CE4:  RETURN 0
.................... }
.................... 
.................... void distance_measure(){
.................... comm_counter++;
*
00D3A:  INCF   45,F
.................... 
.................... if(step<threshold){
00D3C:  MOVF   3F,F
00D3E:  BNZ   0D4E
00D40:  MOVF   44,W
00D42:  SUBWF  3E,W
00D44:  BC    0D4E
....................    step=threshold-1;
00D46:  MOVLW  01
00D48:  SUBWF  44,W
00D4A:  MOVWF  3E
00D4C:  CLRF   3F
.................... }
.................... /*
....................    if(!centered){
....................       delay_us(20);
....................    }
.................... */ if(comm_counter==20){ //threshold/2
00D4E:  MOVF   45,W
00D50:  SUBLW  14
00D52:  BNZ   0D7A
....................       int8 step_data=step/10;
00D54:  MOVFF  3F,79
00D58:  MOVFF  3E,78
00D5C:  CLRF   x7B
00D5E:  MOVLW  0A
00D60:  MOVWF  x7A
00D62:  RCALL  0CF8
00D64:  MOVFF  01,77
....................      printf("q%d",step_data);
00D68:  MOVLW  71
00D6A:  BTFSS  F9E.4
00D6C:  BRA    0D6A
00D6E:  MOVWF  FAD
00D70:  MOVFF  77,78
00D74:  MOVLW  18
00D76:  MOVWF  x79
00D78:  RCALL  0A68
....................    }
....................    
....................    if(centered & comm_counter==threshold | step<=threshold){
00D7A:  MOVF   44,W
00D7C:  SUBWF  45,W
00D7E:  BZ    0D84
00D80:  MOVLW  00
00D82:  BRA    0D86
00D84:  MOVLW  01
00D86:  ANDWF  38,W
00D88:  MOVWF  x78
00D8A:  MOVF   3F,F
00D8C:  BNZ   0D94
00D8E:  MOVF   3E,W
00D90:  SUBWF  44,W
00D92:  BC    0D98
00D94:  MOVLW  00
00D96:  BRA    0D9A
00D98:  MOVLW  01
00D9A:  IORWF  x78,W
00D9C:  BZ    0E32
....................      comm_counter=0;
00D9E:  CLRF   45
....................      line1=(step/threshold);
00DA0:  MOVFF  3F,79
00DA4:  MOVFF  3E,78
00DA8:  CLRF   x7B
00DAA:  MOVFF  44,7A
00DAE:  RCALL  0CF8
00DB0:  MOVFF  01,42
....................      
....................      if(line1>18){
00DB4:  MOVF   42,W
00DB6:  SUBLW  12
00DB8:  BC    0DBE
....................         line1=19;
00DBA:  MOVLW  13
00DBC:  MOVWF  42
....................      }
....................     
....................      if(line1<2) {
00DBE:  MOVF   42,W
00DC0:  SUBLW  01
00DC2:  BNC   0DC8
....................         line1=2;
00DC4:  MOVLW  02
00DC6:  MOVWF  42
....................      }
....................      
....................   /* 
....................      if(step<threshold){
....................         step=1;
....................         lcd_gotoxy(2,4);
....................         lcd_putc(" "); 
....................         
....................         line1=2;
....................         linecheck=line1;
....................       
....................         return;
....................      }
....................  */   
....................      if (line1<linecheck){
00DC8:  MOVF   43,W
00DCA:  SUBWF  42,W
00DCC:  BC    0E20
....................       
....................         if(line1==18){
00DCE:  MOVF   42,W
00DD0:  SUBLW  12
00DD2:  BNZ   0DEE
....................            lcd_gotoxy(19,4);
00DD4:  MOVLW  13
00DD6:  MOVWF  x7F
00DD8:  MOVLW  04
00DDA:  MOVWF  x80
00DDC:  RCALL  07CE
....................            lcd_putc(" "); 
00DDE:  MOVLW  08
00DE0:  MOVWF  FF6
00DE2:  MOVLW  01
00DE4:  MOVWF  FF7
00DE6:  RCALL  0856
....................            linecheck=line1;   
00DE8:  MOVFF  42,43
....................            return;
00DEC:  BRA    0E32
....................         }
....................         
....................         if(line1==1){
00DEE:  DECFSZ 42,W
00DF0:  BRA    0E0C
....................            lcd_gotoxy(2,4);
00DF2:  MOVLW  02
00DF4:  MOVWF  x7F
00DF6:  MOVLW  04
00DF8:  MOVWF  x80
00DFA:  RCALL  07CE
....................            lcd_putc(" "); 
00DFC:  MOVLW  0A
00DFE:  MOVWF  FF6
00E00:  MOVLW  01
00E02:  MOVWF  FF7
00E04:  RCALL  0856
....................            linecheck=line1;
00E06:  MOVFF  42,43
....................            return;
00E0A:  BRA    0E32
....................         }
....................         
....................         lcd_gotoxy(line1,4);
00E0C:  MOVFF  42,7F
00E10:  MOVLW  04
00E12:  MOVWF  x80
00E14:  RCALL  07CE
....................         lcd_putc("  "); 
00E16:  MOVLW  0C
00E18:  MOVWF  FF6
00E1A:  MOVLW  01
00E1C:  MOVWF  FF7
00E1E:  RCALL  0856
.................... 
....................      }
....................    
....................      lcd_gotoxy(line1,4);
00E20:  MOVFF  42,7F
00E24:  MOVLW  04
00E26:  MOVWF  x80
00E28:  RCALL  07CE
....................      lcd_putc(three_dot);  
00E2A:  CLRF   x7E
00E2C:  RCALL  080E
....................      
....................      linecheck=line1;
00E2E:  MOVFF  42,43
....................     
....................      }
00E32:  RETURN 0
....................      
.................... 
.................... }
.................... 
.................... void normal(){
.................... dir=1;
*
00E9C:  MOVLW  01
00E9E:  MOVWF  49
.................... enable_interrupts(INT_TIMER1);
00EA0:  BSF    F9D.0
.................... distance_measure();
00EA2:  RCALL  0D3A
.................... disable_interrupts(INT_TIMER1);
00EA4:  BCF    F9D.0
00EA6:  RETURN 0
.................... 
.................... 
.................... 
.................... /*
....................       output_high (A1) ;
....................       output_low (A2) ;
....................       output_low (B1) ;
....................       output_low (B2) ;
....................       delay_func (loop) ;
....................       
....................       output_high (A1) ;
....................       output_low (A2) ;
....................       output_high (B1) ;
....................       output_low (B2) ;
....................       delay_func (loop) ;
....................       
....................       output_low (A1) ;
....................       output_low (A2) ;
....................       output_high (B1) ;
....................       output_low (B2) ;
....................       delay_func (loop) ;
....................       
....................       output_low (A1) ;
....................       output_high (A2) ;
....................       output_high (B1) ;
....................       output_low (B2) ;
....................       delay_func (loop) ;
....................       
....................       output_low (A1) ;
....................       output_high (A2) ;
....................       output_low (B1) ;
....................       output_low (B2) ;
....................       delay_func (loop) ;
....................       
....................       output_low (A1) ;
....................       output_high (A2) ;
....................       output_low (B1) ;
....................       output_high (B2) ;
....................       delay_func (loop) ;
....................       
....................       output_low (A1) ;
....................       output_low (A2) ;
....................       output_low (B1) ;
....................       output_high (B2) ;
....................       delay_func (loop) ;
....................       
....................       output_high (A1) ;
....................       output_low (A2) ;
....................       output_low (B1) ;
....................       output_high (B2) ;
....................       delay_func (loop) ;
....................       
....................       if(center_flag==True){
....................       centercounter=centercounter+1;
....................       }
....................       
....................       step--;
....................   
....................   */    
.................... }
.................... 
.................... void reverse(){
.................... dir=0;
*
00E34:  CLRF   49
.................... enable_interrupts(INT_TIMER1);
00E36:  BSF    F9D.0
.................... distance_measure();
00E38:  RCALL  0D3A
.................... disable_interrupts(INT_TIMER1);
00E3A:  BCF    F9D.0
00E3C:  RETURN 0
.................... 
.................... 
.................... /*
....................    output_high (A1);
....................    output_low (A2);
....................    output_low (B1);
....................    output_high (B2);
....................    delay_func (loop) ;
....................    
....................    output_low (A1);
....................    output_low (A2);
....................    output_low (B1);
....................    output_high (B2);
....................    delay_func (loop) ;
....................    
....................    output_low (A1);
....................    output_high (A2);
....................    output_low (B1);
....................    output_high (B2);
....................    delay_func (loop) ;
....................    
....................    output_low (A1);
....................    output_high (A2);
....................    output_low (B1);
....................    output_low (B2);
....................    delay_func (loop) ;
....................    
....................    output_low (A1);
....................    output_high (A2);
....................    output_high (B1);
....................    output_low (B2);
....................    delay_func (loop) ;
....................    
....................    output_low (A1);
....................    output_low (A2);
....................    output_high (B1);
....................    output_low (B2);
....................    delay_func (loop) ;
....................    
....................    output_high (A1);
....................    output_low (A2);
....................    output_high (B1);
....................    output_low (B2);
....................    delay_func (loop) ;
....................    
....................    output_high (A1);
....................    output_low (A2);
....................    output_low (B1);
....................    output_low (B2);
....................    delay_func (loop) ;
....................    
....................    step++;
.................... */
.................... 
.................... }
.................... 
.................... char acc_start_normal_man(){
....................  output_high(pin_d4);  
*
012B6:  BCF    F95.4
012B8:  BSF    F8C.4
....................  while (start){
012BA:  MOVF   46,F
012BC:  BZ    1320
....................    c=abs(delay_s-(10-accel));
012BE:  MOVLW  0A
012C0:  BSF    FD8.0
012C2:  SUBFWB 22,W
012C4:  SUBWF  20,W
012C6:  MOVWF  24
....................    for(int i=0;i<10-accel;i++){      
012C8:  CLRF   x72
012CA:  MOVLW  0A
012CC:  BSF    FD8.0
012CE:  SUBFWB 22,W
012D0:  SUBWF  x72,W
012D2:  BC    1314
....................       for(int j=0;j<accel_value;j++)
012D4:  CLRF   x73
012D6:  MOVF   23,W
012D8:  SUBWF  x73,W
012DA:  BC    130C
....................       {
....................          if(!(input (button1)) | input(button3) | check_right_proxy()){
012DC:  BSF    F95.1
012DE:  MOVLW  00
012E0:  BTFSS  F83.1
012E2:  MOVLW  01
012E4:  MOVWF  x74
012E6:  BSF    F94.3
012E8:  MOVLW  00
012EA:  BTFSC  F82.3
012EC:  MOVLW  01
012EE:  IORWF  x74,F
012F0:  RCALL  0E3E
012F2:  MOVF   x74,W
012F4:  IORWF  01,W
012F6:  BZ    1302
....................             stop();
012F8:  RCALL  0CE6
....................             return return_value=False;
012FA:  CLRF   48
012FC:  MOVFF  48,01
01300:  BRA    1324
....................             }
....................             
....................          speed=c;
01302:  MOVFF  24,21
....................          normal();
01306:  RCALL  0E9C
01308:  INCF   x73,F
0130A:  BRA    12D6
....................          
....................  
....................          }
....................       c=c+1;  
0130C:  MOVLW  01
0130E:  ADDWF  24,F
01310:  INCF   x72,F
01312:  BRA    12CA
....................       }
....................       start=False;
01314:  CLRF   46
....................       return return_value=True;
01316:  MOVLW  01
01318:  MOVWF  48
0131A:  MOVWF  01
0131C:  BRA    1324
0131E:  BRA    12BA
....................    }  
....................   output_low(pin_d4);         
01320:  BCF    F95.4
01322:  BCF    F8C.4
01324:  GOTO   217E (RETURN)
.................... }
.................... 
.................... char acc_start_reverse_man(){
.................... output_high(pin_d4); 
01328:  BCF    F95.4
0132A:  BSF    F8C.4
....................  while (start==True){
0132C:  DECFSZ 46,W
0132E:  BRA    1392
....................    c=abs(delay_s-(10-accel));
01330:  MOVLW  0A
01332:  BSF    FD8.0
01334:  SUBFWB 22,W
01336:  SUBWF  20,W
01338:  MOVWF  24
....................    for(int i=0;i<10-accel;i++){   
0133A:  CLRF   x72
0133C:  MOVLW  0A
0133E:  BSF    FD8.0
01340:  SUBFWB 22,W
01342:  SUBWF  x72,W
01344:  BC    1386
....................       for(int j=0;j<accel_value;j++){
01346:  CLRF   x73
01348:  MOVF   23,W
0134A:  SUBWF  x73,W
0134C:  BC    137E
....................       
....................          if(!(input (button3)) | input (button1)  | check_left_proxy()){
0134E:  BSF    F94.3
01350:  MOVLW  00
01352:  BTFSS  F82.3
01354:  MOVLW  01
01356:  MOVWF  x74
01358:  BSF    F95.1
0135A:  MOVLW  00
0135C:  BTFSC  F83.1
0135E:  MOVLW  01
01360:  IORWF  x74,F
01362:  RCALL  0C98
01364:  MOVF   x74,W
01366:  IORWF  01,W
01368:  BZ    1374
....................             stop();
0136A:  RCALL  0CE6
....................             return return_value=False;
0136C:  CLRF   48
0136E:  MOVFF  48,01
01372:  BRA    1396
....................             }
....................          speed=c;
01374:  MOVFF  24,21
....................          reverse();
01378:  RCALL  0E34
0137A:  INCF   x73,F
0137C:  BRA    1348
....................          
.................... 
....................          }
....................    c=c+1;  
0137E:  MOVLW  01
01380:  ADDWF  24,F
01382:  INCF   x72,F
01384:  BRA    133C
....................    }
....................    start=False;
01386:  CLRF   46
....................    return return_value=True;
01388:  MOVLW  01
0138A:  MOVWF  48
0138C:  MOVWF  01
0138E:  BRA    1396
01390:  BRA    132C
....................    }
....................  output_low(pin_d4); 
01392:  BCF    F95.4
01394:  BCF    F8C.4
01396:  GOTO   21C4 (RETURN)
.................... }
.................... 
.................... char acc_start_normal_auto(){
....................  while (start==True){
*
0124E:  DECFSZ 46,W
01250:  BRA    12B4
....................             c=abs(delay_s-(10-accel));
01252:  MOVLW  0A
01254:  BSF    FD8.0
01256:  SUBFWB 22,W
01258:  SUBWF  20,W
0125A:  MOVWF  24
....................             for(int i=0;i<10-accel;i++){                
0125C:  CLRF   x72
0125E:  MOVLW  0A
01260:  BSF    FD8.0
01262:  SUBFWB 22,W
01264:  SUBWF  x72,W
01266:  BC    12A8
....................                for(int j=0;j<accel_value;j++){
01268:  CLRF   x73
0126A:  MOVF   23,W
0126C:  SUBWF  x73,W
0126E:  BC    12A0
....................                
....................                   if(input (button1) | input (button3) | check_right_proxy()){
01270:  BSF    F95.1
01272:  MOVLW  00
01274:  BTFSC  F83.1
01276:  MOVLW  01
01278:  MOVWF  x74
0127A:  BSF    F94.3
0127C:  MOVLW  00
0127E:  BTFSC  F82.3
01280:  MOVLW  01
01282:  IORWF  x74,F
01284:  RCALL  0E3E
01286:  MOVF   x74,W
01288:  IORWF  01,W
0128A:  BZ    1296
....................                      stop();
0128C:  RCALL  0CE6
....................                      return return_value=False;
0128E:  CLRF   48
01290:  MOVFF  48,01
01294:  BRA    12B4
....................                      }  
....................                   speed=c;
01296:  MOVFF  24,21
....................                   normal();
0129A:  RCALL  0E9C
0129C:  INCF   x73,F
0129E:  BRA    126A
....................                   }
....................                c=c+1;  
012A0:  MOVLW  01
012A2:  ADDWF  24,F
012A4:  INCF   x72,F
012A6:  BRA    125E
....................                }
....................                start=False;
012A8:  CLRF   46
....................                return return_value=True;
012AA:  MOVLW  01
012AC:  MOVWF  48
012AE:  MOVWF  01
012B0:  BRA    12B4
012B2:  BRA    124E
....................             }
012B4:  RETURN 0
.................... }
.................... 
.................... char acc_start_reverse_auto(){
.................... 
.................... while (start==True){
*
0139A:  DECFSZ 46,W
0139C:  BRA    1400
....................             c=abs(delay_s-(10-accel));
0139E:  MOVLW  0A
013A0:  BSF    FD8.0
013A2:  SUBFWB 22,W
013A4:  SUBWF  20,W
013A6:  MOVWF  24
....................             for(int i=0;i<10-accel;i++){       
013A8:  CLRF   x72
013AA:  MOVLW  0A
013AC:  BSF    FD8.0
013AE:  SUBFWB 22,W
013B0:  SUBWF  x72,W
013B2:  BC    13F4
....................                for(int j=0;j<accel_value;j++){
013B4:  CLRF   x73
013B6:  MOVF   23,W
013B8:  SUBWF  x73,W
013BA:  BC    13EC
....................                
....................                   if(input (button1) == 1 | input (button3) == 1 | check_left_proxy()){
013BC:  BSF    F95.1
013BE:  MOVLW  00
013C0:  BTFSC  F83.1
013C2:  MOVLW  01
013C4:  MOVWF  x75
013C6:  BSF    F94.3
013C8:  MOVLW  00
013CA:  BTFSC  F82.3
013CC:  MOVLW  01
013CE:  IORWF  x75,F
013D0:  RCALL  0C98
013D2:  MOVF   x75,W
013D4:  IORWF  01,W
013D6:  BZ    13E2
....................                      stop();
013D8:  RCALL  0CE6
....................                      return return_value=False;
013DA:  CLRF   48
013DC:  MOVFF  48,01
013E0:  BRA    1400
....................                      }   
....................                   speed=c;  
013E2:  MOVFF  24,21
....................                   reverse();
013E6:  RCALL  0E34
013E8:  INCF   x73,F
013EA:  BRA    13B6
....................                   }
....................                c=c+1;  
013EC:  MOVLW  01
013EE:  ADDWF  24,F
013F0:  INCF   x72,F
013F2:  BRA    13AA
....................                }
....................                start=False;
013F4:  CLRF   46
....................                return return_value=True;
013F6:  MOVLW  01
013F8:  MOVWF  48
013FA:  MOVWF  01
013FC:  BRA    1400
013FE:  BRA    139A
....................             }
01400:  GOTO   2318 (RETURN)
.................... }
.................... 
.................... float read_serial_speed(){
....................   /* 
....................    if (str[0] == 's'){
....................       output_toggle(pin_d4);
....................       
....................       if (str[1] == '0'){
....................       
....................          for(int i=0;i<=8;i++){
....................             if(str[2]==array1[i])
....................             {
....................                delay_s=array2[i];
....................                break;
....................             }
....................          }
.................... 
....................       }
....................       
....................       if (str[1] == '1'){
....................          delay_s=10;
....................       }
....................       
....................    }
.................... 
....................    return delay_s;
....................    */
....................    
....................     if (str[0] == 'h')
*
00B98:  MOVF   29,W
00B9A:  SUBLW  68
00B9C:  BNZ   0C0C
....................    {
....................       output_toggle(pin_d4);
00B9E:  BCF    F95.4
00BA0:  BTG    F8C.4
....................       if (str[1] == '0')
00BA2:  MOVF   2A,W
00BA4:  SUBLW  30
00BA6:  BNZ   0C02
....................       {
....................       
....................          if (str[2] == '1')
00BA8:  MOVF   2B,W
00BAA:  SUBLW  31
00BAC:  BNZ   0BB2
....................          {
....................           delay_s=1;
00BAE:  MOVLW  01
00BB0:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '2')
00BB2:  MOVF   2B,W
00BB4:  SUBLW  32
00BB6:  BNZ   0BBC
....................          {
....................           delay_s=2;
00BB8:  MOVLW  02
00BBA:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '3')
00BBC:  MOVF   2B,W
00BBE:  SUBLW  33
00BC0:  BNZ   0BC6
....................          {
....................           delay_s=3;
00BC2:  MOVLW  03
00BC4:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '4')
00BC6:  MOVF   2B,W
00BC8:  SUBLW  34
00BCA:  BNZ   0BD0
....................          {
....................           delay_s=4;
00BCC:  MOVLW  04
00BCE:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '5')
00BD0:  MOVF   2B,W
00BD2:  SUBLW  35
00BD4:  BNZ   0BDA
....................          {
....................           delay_s=5;
00BD6:  MOVLW  05
00BD8:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '6')
00BDA:  MOVF   2B,W
00BDC:  SUBLW  36
00BDE:  BNZ   0BE4
....................          {
....................           delay_s=6;
00BE0:  MOVLW  06
00BE2:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '7')
00BE4:  MOVF   2B,W
00BE6:  SUBLW  37
00BE8:  BNZ   0BEE
....................          {
....................           delay_s=7;
00BEA:  MOVLW  07
00BEC:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '8')
00BEE:  MOVF   2B,W
00BF0:  SUBLW  38
00BF2:  BNZ   0BF8
....................          {
....................           delay_s=8;
00BF4:  MOVLW  08
00BF6:  MOVWF  20
....................          }
....................          
....................          if (str[2] == '9')
00BF8:  MOVF   2B,W
00BFA:  SUBLW  39
00BFC:  BNZ   0C02
....................          {
....................           delay_s=9;
00BFE:  MOVLW  09
00C00:  MOVWF  20
....................          }
....................        
....................       }
....................       
....................       if (str[1] == '1'){
00C02:  MOVF   2A,W
00C04:  SUBLW  31
00C06:  BNZ   0C0C
....................          delay_s=10;
00C08:  MOVLW  0A
00C0A:  MOVWF  20
....................       }
....................       
....................    }
....................    return delay_s;
00C0C:  CLRF   x73
00C0E:  MOVFF  20,72
00C12:  RCALL  0B62
00C14:  GOTO   1FA6 (RETURN)
.................... 
.................... }
.................... 
.................... void read_serial_mode(){
.................... 
....................    if(str[0]=='m'){
*
00B3C:  MOVF   29,W
00B3E:  SUBLW  6D
00B40:  BNZ   0B5E
....................    output_toggle(pin_d4);
00B42:  BCF    F95.4
00B44:  BTG    F8C.4
....................    
....................       if(str[1]=='0'){
00B46:  MOVF   2A,W
00B48:  SUBLW  30
00B4A:  BNZ   0B52
....................          mode_AUTO = False;
00B4C:  CLRF   25
....................          mode_manuel = True;
00B4E:  MOVLW  01
00B50:  MOVWF  26
....................        }
....................          
....................       if(str[1]=='1'){      
00B52:  MOVF   2A,W
00B54:  SUBLW  31
00B56:  BNZ   0B5E
....................          mode_AUTO = True;
00B58:  MOVLW  01
00B5A:  MOVWF  25
....................          mode_manuel = False;
00B5C:  CLRF   26
....................       }
....................          
....................    }
00B5E:  GOTO   1FA2 (RETURN)
.................... }
.................... 
.................... float read_serial_acc(){
.................... 
....................     if (str[0] == 'a')
*
00C18:  MOVF   29,W
00C1A:  SUBLW  61
00C1C:  BNZ   0C8C
....................    {
....................       output_toggle(pin_d4);
00C1E:  BCF    F95.4
00C20:  BTG    F8C.4
....................       if (str[1] == '0')
00C22:  MOVF   2A,W
00C24:  SUBLW  30
00C26:  BNZ   0C82
....................       {
....................       
....................          if (str[2] == '1')
00C28:  MOVF   2B,W
00C2A:  SUBLW  31
00C2C:  BNZ   0C32
....................          {
....................           accel=1;
00C2E:  MOVLW  01
00C30:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '2')
00C32:  MOVF   2B,W
00C34:  SUBLW  32
00C36:  BNZ   0C3C
....................          {
....................           accel=2;
00C38:  MOVLW  02
00C3A:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '3')
00C3C:  MOVF   2B,W
00C3E:  SUBLW  33
00C40:  BNZ   0C46
....................          {
....................           accel=3;
00C42:  MOVLW  03
00C44:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '4')
00C46:  MOVF   2B,W
00C48:  SUBLW  34
00C4A:  BNZ   0C50
....................          {
....................           accel=4;
00C4C:  MOVLW  04
00C4E:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '5')
00C50:  MOVF   2B,W
00C52:  SUBLW  35
00C54:  BNZ   0C5A
....................          {
....................           accel=5;
00C56:  MOVLW  05
00C58:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '6')
00C5A:  MOVF   2B,W
00C5C:  SUBLW  36
00C5E:  BNZ   0C64
....................          {
....................           accel=6;
00C60:  MOVLW  06
00C62:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '7')
00C64:  MOVF   2B,W
00C66:  SUBLW  37
00C68:  BNZ   0C6E
....................          {
....................           accel=7;
00C6A:  MOVLW  07
00C6C:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '8')
00C6E:  MOVF   2B,W
00C70:  SUBLW  38
00C72:  BNZ   0C78
....................          {
....................           accel=8;
00C74:  MOVLW  08
00C76:  MOVWF  22
....................          }
....................          
....................          if (str[2] == '9')
00C78:  MOVF   2B,W
00C7A:  SUBLW  39
00C7C:  BNZ   0C82
....................          {
....................           accel=9;
00C7E:  MOVLW  09
00C80:  MOVWF  22
....................          }
....................        
....................       }
....................       
....................       if (str[1] == '1'){
00C82:  MOVF   2A,W
00C84:  SUBLW  31
00C86:  BNZ   0C8C
....................          accel=10;
00C88:  MOVLW  0A
00C8A:  MOVWF  22
....................       }
....................       
....................    }
....................    return accel;
00C8C:  CLRF   x73
00C8E:  MOVFF  22,72
00C92:  RCALL  0B62
00C94:  GOTO   1FAA (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... void centerline(delay){
.................... 
....................   lcd_gotoxy(1,4);
*
00EC8:  MOVLW  01
00ECA:  MOVWF  x7F
00ECC:  MOVLW  04
00ECE:  MOVWF  x80
00ED0:  RCALL  07CE
....................   lcd_putc(swoff);
00ED2:  MOVLW  02
00ED4:  MOVWF  x7E
00ED6:  RCALL  080E
....................   lcd_gotoxy(20,4);
00ED8:  MOVLW  14
00EDA:  MOVWF  x7F
00EDC:  MOVLW  04
00EDE:  MOVWF  x80
00EE0:  RCALL  07CE
....................   lcd_putc(swoff);
00EE2:  MOVLW  02
00EE4:  MOVWF  x7E
00EE6:  RCALL  080E
....................   lcd_gotoxy(2,4);
00EE8:  MOVLW  02
00EEA:  MOVWF  x7F
00EEC:  MOVLW  04
00EEE:  MOVWF  x80
00EF0:  RCALL  07CE
....................   lcd_putc("     Homing...    ");
00EF2:  MOVLW  10
00EF4:  MOVWF  FF6
00EF6:  MOVLW  01
00EF8:  MOVWF  FF7
00EFA:  RCALL  0856
....................   speed=6;
00EFC:  MOVLW  06
00EFE:  MOVWF  21
....................   centered=False;
00F00:  CLRF   38
....................   centercounter=0;
00F02:  CLRF   3A
00F04:  CLRF   39
....................   
....................   while (1){
.................... 
....................     if (check_left_proxy()){
00F06:  RCALL  0C98
00F08:  MOVF   01,F
00F0A:  BZ    0F16
....................       stop();
00F0C:  RCALL  0CE6
....................       output_toggle (PIN_D4);
00F0E:  BCF    F95.4
00F10:  BTG    F8C.4
....................       correct = False;
00F12:  CLRF   32
....................       
....................       break;
00F14:  BRA    0F40
....................     }
....................     
....................     if (input (button1) | input (button3) ){
00F16:  BSF    F95.1
00F18:  MOVLW  00
00F1A:  BTFSC  F83.1
00F1C:  MOVLW  01
00F1E:  MOVWF  x75
00F20:  BSF    F94.3
00F22:  MOVLW  00
00F24:  BTFSC  F82.3
00F26:  MOVLW  01
00F28:  IORWF  x75,W
00F2A:  BZ    0F3C
....................       stop();
00F2C:  RCALL  0CE6
....................       lcd_gotoxy(1,4);
00F2E:  MOVLW  01
00F30:  MOVWF  x7F
00F32:  MOVLW  04
00F34:  MOVWF  x80
00F36:  RCALL  07CE
....................       centered=False;
00F38:  CLRF   38
....................       
....................       return;
00F3A:  BRA    10BA
....................       }
....................     
....................       reverse();
00F3C:  RCALL  0E34
00F3E:  BRA    0F06
....................    }
....................    
....................    
....................    while (1){
....................       
....................       center_flag=True;
00F40:  MOVLW  01
00F42:  MOVWF  3D
....................       
....................       if (check_right_proxy()){
00F44:  RCALL  0E3E
00F46:  MOVF   01,F
00F48:  BZ    0F54
....................          stop();
00F4A:  RCALL  0CE6
....................          correct = False;
00F4C:  CLRF   32
....................          step=0;
00F4E:  CLRF   3F
00F50:  CLRF   3E
....................          break;
00F52:  BRA    0F7E
....................       }
....................       
....................       if (input (button1) | input (button3)){
00F54:  BSF    F95.1
00F56:  MOVLW  00
00F58:  BTFSC  F83.1
00F5A:  MOVLW  01
00F5C:  MOVWF  x75
00F5E:  BSF    F94.3
00F60:  MOVLW  00
00F62:  BTFSC  F82.3
00F64:  MOVLW  01
00F66:  IORWF  x75,W
00F68:  BZ    0F7A
....................       stop();
00F6A:  RCALL  0CE6
....................       lcd_gotoxy(1,4);
00F6C:  MOVLW  01
00F6E:  MOVWF  x7F
00F70:  MOVLW  04
00F72:  MOVWF  x80
00F74:  RCALL  07CE
....................       centered=False;
00F76:  CLRF   38
....................       return;
00F78:  BRA    10BA
....................       }
....................       
....................       normal();
00F7A:  RCALL  0E9C
00F7C:  BRA    0F40
....................       
....................       //printf("data: %s", centercounter);
....................      }
....................    
....................    while (step<centercounter/2 ){ 
00F7E:  BCF    FD8.0
00F80:  RRCF   3A,W
00F82:  MOVWF  03
00F84:  RRCF   39,W
00F86:  MOVWF  02
00F88:  MOVWF  01
00F8A:  MOVF   3F,W
00F8C:  SUBWF  03,W
00F8E:  BNC   0FD2
00F90:  BNZ   0F98
00F92:  MOVF   01,W
00F94:  SUBWF  3E,W
00F96:  BC    0FD2
....................      center_flag=False;
00F98:  CLRF   3D
....................      CurrentTick=get_ticks();
00F9A:  CALL   077C
00F9E:  MOVFF  03,67
00FA2:  MOVFF  02,66
00FA6:  MOVFF  01,65
00FAA:  MOVFF  00,64
....................      
....................      if (input (button1) | input (button3) | check_left_proxy()){
00FAE:  BSF    F95.1
00FB0:  MOVLW  00
00FB2:  BTFSC  F83.1
00FB4:  MOVLW  01
00FB6:  MOVWF  x75
00FB8:  BSF    F94.3
00FBA:  MOVLW  00
00FBC:  BTFSC  F82.3
00FBE:  MOVLW  01
00FC0:  IORWF  x75,F
00FC2:  RCALL  0C98
00FC4:  MOVF   x75,W
00FC6:  IORWF  01,W
00FC8:  BZ    0FCE
....................       stop();
00FCA:  RCALL  0CE6
....................       return;
00FCC:  BRA    10BA
....................       }
.................... 
....................     reverse();
00FCE:  RCALL  0E34
00FD0:  BRA    0F7E
....................     
....................    }
....................    
....................    stop();
00FD2:  RCALL  0CE6
....................    lcd_putc("\f");
00FD4:  MOVLW  24
00FD6:  MOVWF  FF6
00FD8:  MOVLW  01
00FDA:  MOVWF  FF7
00FDC:  RCALL  0856
....................    
....................    lcd_gotoxy(1,3);
00FDE:  MOVLW  01
00FE0:  MOVWF  x7F
00FE2:  MOVLW  03
00FE4:  MOVWF  x80
00FE6:  CALL   07CE
....................    centercounter=centercounter+3;
00FEA:  MOVLW  03
00FEC:  ADDWF  39,F
00FEE:  MOVLW  00
00FF0:  ADDWFC 3A,F
....................    printf(lcd_putc,"count: %Lu", centercounter);
00FF2:  MOVLW  26
00FF4:  MOVWF  FF6
00FF6:  MOVLW  01
00FF8:  MOVWF  FF7
00FFA:  MOVLW  07
00FFC:  MOVWF  x75
00FFE:  BRA    0EA8
01000:  MOVLW  10
01002:  MOVWF  FE9
01004:  MOVFF  3A,76
01008:  MOVFF  39,75
0100C:  RCALL  0876
....................    step=centercounter/2;
0100E:  BCF    FD8.0
01010:  RRCF   3A,W
01012:  MOVWF  3F
01014:  RRCF   39,W
01016:  MOVWF  3E
....................    centered=True;
01018:  MOVLW  01
0101A:  MOVWF  38
....................    center_flag=False;
0101C:  CLRF   3D
....................    threshold=(centercounter/20);
0101E:  MOVFF  3A,79
01022:  MOVFF  39,78
01026:  CLRF   x7B
01028:  MOVLW  14
0102A:  MOVWF  x7A
0102C:  RCALL  0CF8
0102E:  MOVFF  01,44
....................    
....................    comm_counter=threshold-1;
01032:  MOVLW  01
01034:  SUBWF  44,W
01036:  MOVWF  45
....................    int8 step_data=step/10;
01038:  MOVFF  3F,79
0103C:  MOVFF  3E,78
01040:  CLRF   x7B
01042:  MOVLW  0A
01044:  MOVWF  x7A
01046:  RCALL  0CF8
01048:  MOVFF  01,73
....................    printf("q%d",step_data);
0104C:  MOVLW  71
0104E:  BTFSS  F9E.4
01050:  BRA    104E
01052:  MOVWF  FAD
01054:  MOVFF  73,78
01058:  MOVLW  18
0105A:  MOVWF  x79
0105C:  RCALL  0A68
....................    
....................    line1=(step/threshold);
0105E:  MOVFF  3F,79
01062:  MOVFF  3E,78
01066:  CLRF   x7B
01068:  MOVFF  44,7A
0106C:  RCALL  0CF8
0106E:  MOVFF  01,42
....................    
....................    
....................    lcd_gotoxy(1,4);
01072:  MOVLW  01
01074:  MOVWF  x7F
01076:  MOVLW  04
01078:  MOVWF  x80
0107A:  CALL   07CE
....................    lcd_putc(swoff);
0107E:  MOVLW  02
01080:  MOVWF  x7E
01082:  CALL   080E
....................    lcd_gotoxy(20,4);
01086:  MOVLW  14
01088:  MOVWF  x7F
0108A:  MOVLW  04
0108C:  MOVWF  x80
0108E:  CALL   07CE
....................    lcd_putc(swoff);
01092:  MOVLW  02
01094:  MOVWF  x7E
01096:  CALL   080E
....................    
....................    for(int i=2;i<=10;i++){
0109A:  MOVLW  02
0109C:  MOVWF  x74
0109E:  MOVF   x74,W
010A0:  SUBLW  0A
010A2:  BNC   10BA
....................      lcd_gotoxy(i,4);
010A4:  MOVFF  74,7F
010A8:  MOVLW  04
010AA:  MOVWF  x80
010AC:  CALL   07CE
....................      lcd_putc(three_dot);
010B0:  CLRF   x7E
010B2:  CALL   080E
010B6:  INCF   x74,F
010B8:  BRA    109E
....................   }
....................    
....................    return;
010BA:  RETURN 0
....................    
.................... }
.................... 
.................... void gogo(){
010BC:  MOVLW  01
010BE:  MOVWF  x72
.................... 
.................... char start=True;
.................... 
.................... output_toggle (PIN_D4);
010C0:  BCF    F95.4
010C2:  BTG    F8C.4
.................... 
.................... while(1){
.................... 
....................     while (1){
....................     
....................        while(start==True){
010C4:  DECFSZ x72,W
010C6:  BRA    113E
....................        c=abs(delay_s-(10-accel));
010C8:  MOVLW  0A
010CA:  BSF    FD8.0
010CC:  SUBFWB 22,W
010CE:  SUBWF  20,W
010D0:  MOVWF  24
....................          for(int i=0;i<10-accel;i++){
010D2:  CLRF   x73
010D4:  MOVLW  0A
010D6:  BSF    FD8.0
010D8:  SUBFWB 22,W
010DA:  SUBWF  x73,W
010DC:  BC    113A
....................             for(int j=0;j<accel_value;j++){
010DE:  CLRF   x74
010E0:  MOVF   23,W
010E2:  SUBWF  x74,W
010E4:  BC    1132
....................             
....................                if(input (button1)| input (button3) | input (button4) ){
010E6:  BSF    F95.1
010E8:  MOVLW  00
010EA:  BTFSC  F83.1
010EC:  MOVLW  01
010EE:  MOVWF  x77
010F0:  BSF    F94.3
010F2:  MOVLW  00
010F4:  BTFSC  F82.3
010F6:  MOVLW  01
010F8:  IORWF  x77,F
010FA:  BSF    F94.2
010FC:  MOVLW  00
010FE:  BTFSC  F82.2
01100:  MOVLW  01
01102:  IORWF  x77,W
01104:  BZ    110A
....................                   stop();
01106:  RCALL  0CE6
....................                   return;
01108:  BRA    124C
....................                   }
....................                   
....................                  if (check_left_proxy()){
0110A:  RCALL  0C98
0110C:  MOVF   01,F
0110E:  BZ    1128
....................                  start=True;
01110:  MOVLW  01
01112:  MOVWF  x72
....................                   stop();
01114:  RCALL  0CE6
....................                   delay_ms(500);
01116:  MOVLW  02
01118:  MOVWF  x77
0111A:  MOVLW  FA
0111C:  MOVWF  x7F
0111E:  CALL   05E4
01122:  DECFSZ x77,F
01124:  BRA    111A
....................                   break;
01126:  BRA    1132
....................                  }
....................                speed=c;     
01128:  MOVFF  24,21
....................                reverse();
0112C:  RCALL  0E34
0112E:  INCF   x74,F
01130:  BRA    10E0
....................                }
....................             c=c+1;  
01132:  MOVLW  01
01134:  ADDWF  24,F
01136:  INCF   x73,F
01138:  BRA    10D4
....................             }
....................             start=False;
0113A:  CLRF   x72
0113C:  BRA    10C4
....................          }
....................          
....................          
....................        if (check_left_proxy()){
0113E:  RCALL  0C98
01140:  MOVF   01,F
01142:  BZ    1162
....................          stop();
01144:  RCALL  0CE6
....................          output_toggle (PIN_D4);
01146:  BCF    F95.4
01148:  BTG    F8C.4
....................          delay_ms(500);
0114A:  MOVLW  02
0114C:  MOVWF  x77
0114E:  MOVLW  FA
01150:  MOVWF  x7F
01152:  CALL   05E4
01156:  DECFSZ x77,F
01158:  BRA    114E
....................          start=True;
0115A:  MOVLW  01
0115C:  MOVWF  x72
....................          correct = False;     
0115E:  CLRF   32
....................          break;
01160:  BRA    118E
....................        }
....................        
....................        if (input (button5) == 1 | input (button1) == 1 | input (button3) == 1)
01162:  BSF    F94.1
01164:  MOVLW  00
01166:  BTFSC  F82.1
01168:  MOVLW  01
0116A:  MOVWF  x78
0116C:  BSF    F95.1
0116E:  MOVLW  00
01170:  BTFSC  F83.1
01172:  MOVLW  01
01174:  IORWF  x78,F
01176:  BSF    F94.3
01178:  MOVLW  00
0117A:  BTFSC  F82.3
0117C:  MOVLW  01
0117E:  IORWF  x78,W
01180:  BZ    1186
....................       {   
....................          stop();
01182:  RCALL  0CE6
....................          return;
01184:  BRA    124C
....................       }
....................          speed=c;
01186:  MOVFF  24,21
....................          reverse();
0118A:  RCALL  0E34
0118C:  BRA    10C4
....................       }
....................       
....................       
....................       while (1){
....................       
....................       while(start==True){
0118E:  DECFSZ x72,W
01190:  BRA    11FE
....................        c=abs(delay_s-(10-accel));
01192:  MOVLW  0A
01194:  BSF    FD8.0
01196:  SUBFWB 22,W
01198:  SUBWF  20,W
0119A:  MOVWF  24
....................          for(int i=0;i<10-accel;i++){
0119C:  CLRF   x75
0119E:  MOVLW  0A
011A0:  BSF    FD8.0
011A2:  SUBFWB 22,W
011A4:  SUBWF  x75,W
011A6:  BC    11FA
....................          
....................               
....................             for(int j=0;j<accel_value;j++){
011A8:  CLRF   x76
011AA:  MOVF   23,W
011AC:  SUBWF  x76,W
011AE:  BC    11F2
....................             
....................                if(input (button1)  | input (button3)){
011B0:  BSF    F95.1
011B2:  MOVLW  00
011B4:  BTFSC  F83.1
011B6:  MOVLW  01
011B8:  MOVWF  x77
011BA:  BSF    F94.3
011BC:  MOVLW  00
011BE:  BTFSC  F82.3
011C0:  MOVLW  01
011C2:  IORWF  x77,W
011C4:  BZ    11CA
....................                   stop();
011C6:  RCALL  0CE6
....................                   return;
011C8:  BRA    124C
....................                   }
....................                       
....................                  if (check_right_proxy()){
011CA:  RCALL  0E3E
011CC:  MOVF   01,F
011CE:  BZ    11E8
....................                   start=True;
011D0:  MOVLW  01
011D2:  MOVWF  x72
....................                   stop();
011D4:  RCALL  0CE6
....................                   delay_ms(500);
011D6:  MOVLW  02
011D8:  MOVWF  x77
011DA:  MOVLW  FA
011DC:  MOVWF  x7F
011DE:  CALL   05E4
011E2:  DECFSZ x77,F
011E4:  BRA    11DA
....................                   break;
011E6:  BRA    11F2
....................                  }
....................                 speed=c;     
011E8:  MOVFF  24,21
....................                normal();
011EC:  RCALL  0E9C
011EE:  INCF   x76,F
011F0:  BRA    11AA
....................                }
....................             c=c+1;  
011F2:  MOVLW  01
011F4:  ADDWF  24,F
011F6:  INCF   x75,F
011F8:  BRA    119E
....................             }
....................             start=False;
011FA:  CLRF   x72
011FC:  BRA    118E
....................          }
....................          
....................       if (check_right_proxy()){
011FE:  RCALL  0E3E
01200:  MOVF   01,F
01202:  BZ    121E
....................          stop();
01204:  RCALL  0CE6
....................          delay_ms(500);
01206:  MOVLW  02
01208:  MOVWF  x77
0120A:  MOVLW  FA
0120C:  MOVWF  x7F
0120E:  CALL   05E4
01212:  DECFSZ x77,F
01214:  BRA    120A
....................          start=True;
01216:  MOVLW  01
01218:  MOVWF  x72
....................          correct = False;
0121A:  CLRF   32
....................          break;
0121C:  BRA    124A
....................       }
....................       
....................        if (input (button5) == 1 | input (button1) == 1 | input (button3) == 1)
0121E:  BSF    F94.1
01220:  MOVLW  00
01222:  BTFSC  F82.1
01224:  MOVLW  01
01226:  MOVWF  x78
01228:  BSF    F95.1
0122A:  MOVLW  00
0122C:  BTFSC  F83.1
0122E:  MOVLW  01
01230:  IORWF  x78,F
01232:  BSF    F94.3
01234:  MOVLW  00
01236:  BTFSC  F82.3
01238:  MOVLW  01
0123A:  IORWF  x78,W
0123C:  BZ    1242
....................       {
....................          stop();
0123E:  RCALL  0CE6
....................          return;
01240:  BRA    124C
....................       }
....................       
....................       speed=c;
01242:  MOVFF  24,21
....................       normal();
01246:  RCALL  0E9C
01248:  BRA    118E
....................       
....................       
....................      }
0124A:  BRA    10C4
....................      
.................... }
0124C:  RETURN 0
.................... }
.................... 
.................... #INT_RDA fast
.................... void serial_comm(){
....................    disable_interrupts (int_rda) ;
*
00132:  BCF    F9D.5
....................    
....................    //lcd_putc ("data received: ") ;
....................    data = getc () ;
00134:  BTFSS  F9E.5
00136:  BRA    0134
00138:  MOVFF  FAE,28
....................    //printf(data);
....................    //lcd_putc (data) ;
....................    str[counter] = data;
0013C:  CLRF   03
0013E:  MOVF   31,W
00140:  ADDLW  29
00142:  MOVWF  FE9
00144:  MOVLW  00
00146:  ADDWFC 03,W
00148:  MOVWF  FEA
0014A:  MOVFF  28,FEF
....................    //lcd_putc (str[counter]) ;
....................    counter++;
0014E:  INCF   31,F
....................    //lcd_putc (str[counter]) ;
.................... 
....................    if (data == '!')
00150:  MOVF   28,W
00152:  SUBLW  21
00154:  BNZ   015C
....................    {
....................   /*
....................       lcd_putc ("Data: ");
....................       for (int i = 0; i < counter - 1; i++)
....................       {
....................          lcd_putc (str[i]);
....................       }
....................   */    
....................       counter = 0;
00156:  CLRF   31
....................       correct = True;
00158:  MOVLW  01
0015A:  MOVWF  32
....................       //output_toggle (PIN_D4);
....................       //printf("OK");
....................         
....................       //lcd_putc ('\f');
....................    }   
0015C:  BCF    F9E.5
0015E:  RETFIE 1
.................... }
.................... 
.................... ////////////////////////////////////////
.................... 
.................... const int8 lcd_custom_chars[] =
.................... {
.................... 
....................   // Char Number 0 -- THREE
....................   0x00,
....................   0x00,
....................   0x15,
....................   0x15,
....................   0x15,
....................   0x15,
....................   0x15,
....................   0x00,
.................... 
.................... // Char Number 1 -- SW on
....................   0x1F,
....................   0x1F,
....................   0x1F,
....................   0x1F,
....................   0x1F,
....................   0x1F,
....................   0x1F,
....................   0x1F,
....................   
....................  //2  Sw off
....................  
....................   0x1F,
....................   0x11,
....................   0x11,
....................   0x11,
....................   0x11,
....................   0x11,
....................   0x11,
....................   0x1F
....................   
.................... };
.................... void lcd_load_custom_chars()
.................... {
.................... int8 i;
.................... 
.................... // Set address counter pointing to CGRAM address 0.
.................... lcd_send_byte(0, 0x40); 
*
0074A:  CLRF   x83
0074C:  MOVLW  40
0074E:  MOVWF  x84
00750:  RCALL  06B6
.................... 
.................... // Load custom lcd character data into CGRAM.
.................... // It can only hold a maximum of 8 custom characters.
.................... for(i = 0; i < sizeof(lcd_custom_chars); i++)
00752:  CLRF   x72
00754:  MOVF   x72,W
00756:  SUBLW  17
00758:  BNC   0770
....................    {
....................     lcd_send_byte(1, lcd_custom_chars[i]);
0075A:  CLRF   03
0075C:  MOVF   x72,W
0075E:  RCALL  00DE
00760:  MOVWF  x73
00762:  MOVLW  01
00764:  MOVWF  x83
00766:  MOVFF  73,84
0076A:  RCALL  06B6
0076C:  INCF   x72,F
0076E:  BRA    0754
....................    }
.................... 
.................... // Set address counter pointing back to the DDRAM.
.................... lcd_send_byte(0, 0x80);
00770:  CLRF   x83
00772:  MOVLW  80
00774:  MOVWF  x84
00776:  RCALL  06B6
00778:  GOTO   1514 (RETURN)
.................... }
.................... 
.................... #int_timer1
.................... void  Timer1_isr(void)
.................... {
....................   //output_toggle(PIN_D4);
....................   
....................   if (dir==0){
*
001A8:  MOVF   49,F
001AA:  BNZ   0278
....................       delay_func (speed) ;
001AC:  MOVFF  21,88
001B0:  RCALL  0180
....................       output_high (A1);
001B2:  BCF    F95.2
001B4:  BSF    F8C.2
....................       output_low (A2);
001B6:  BCF    F93.1
001B8:  BCF    F8A.1
....................       output_low (B1);
001BA:  BCF    F93.0
001BC:  BCF    F8A.0
....................       output_high (B2);
001BE:  BCF    F94.5
001C0:  BSF    F8B.5
....................       delay_func (speed) ;
001C2:  MOVFF  21,88
001C6:  RCALL  0180
....................       
....................       output_low (A1);
001C8:  BCF    F95.2
001CA:  BCF    F8C.2
....................       output_low (A2);
001CC:  BCF    F93.1
001CE:  BCF    F8A.1
....................       output_low (B1);
001D0:  BCF    F93.0
001D2:  BCF    F8A.0
....................       output_high (B2);
001D4:  BCF    F94.5
001D6:  BSF    F8B.5
....................       delay_func (speed) ;
001D8:  MOVFF  21,88
001DC:  RCALL  0180
....................       
....................       output_low (A1);
001DE:  BCF    F95.2
001E0:  BCF    F8C.2
....................       output_high (A2);
001E2:  BCF    F93.1
001E4:  BSF    F8A.1
....................       output_low (B1);
001E6:  BCF    F93.0
001E8:  BCF    F8A.0
....................       output_high (B2);
001EA:  BCF    F94.5
001EC:  BSF    F8B.5
....................       delay_func (speed) ;
001EE:  MOVFF  21,88
001F2:  RCALL  0180
....................       
....................       output_low (A1);
001F4:  BCF    F95.2
001F6:  BCF    F8C.2
....................       output_high (A2);
001F8:  BCF    F93.1
001FA:  BSF    F8A.1
....................       output_low (B1);
001FC:  BCF    F93.0
001FE:  BCF    F8A.0
....................       output_low (B2);
00200:  BCF    F94.5
00202:  BCF    F8B.5
....................       delay_func (speed) ;
00204:  MOVFF  21,88
00208:  RCALL  0180
....................       
....................       output_low (A1);
0020A:  BCF    F95.2
0020C:  BCF    F8C.2
....................       output_high (A2);
0020E:  BCF    F93.1
00210:  BSF    F8A.1
....................       output_high (B1);
00212:  BCF    F93.0
00214:  BSF    F8A.0
....................       output_low (B2);
00216:  BCF    F94.5
00218:  BCF    F8B.5
....................       delay_func (speed) ;
0021A:  MOVFF  21,88
0021E:  RCALL  0180
....................       
....................       output_low (A1);
00220:  BCF    F95.2
00222:  BCF    F8C.2
....................       output_low (A2);
00224:  BCF    F93.1
00226:  BCF    F8A.1
....................       output_high (B1);
00228:  BCF    F93.0
0022A:  BSF    F8A.0
....................       output_low (B2);
0022C:  BCF    F94.5
0022E:  BCF    F8B.5
....................       delay_func (speed) ;
00230:  MOVFF  21,88
00234:  RCALL  0180
....................       
....................       output_high (A1);
00236:  BCF    F95.2
00238:  BSF    F8C.2
....................       output_low (A2);
0023A:  BCF    F93.1
0023C:  BCF    F8A.1
....................       output_high (B1);
0023E:  BCF    F93.0
00240:  BSF    F8A.0
....................       output_low (B2);
00242:  BCF    F94.5
00244:  BCF    F8B.5
....................       delay_func (speed) ;
00246:  MOVFF  21,88
0024A:  RCALL  0180
....................       
....................       output_high (A1);
0024C:  BCF    F95.2
0024E:  BSF    F8C.2
....................       output_low (A2);
00250:  BCF    F93.1
00252:  BCF    F8A.1
....................       output_low (B1);
00254:  BCF    F93.0
00256:  BCF    F8A.0
....................       output_low (B2);
00258:  BCF    F94.5
0025A:  BCF    F8B.5
....................       
....................       
....................       step++;
0025C:  INCF   3E,F
0025E:  BTFSC  FD8.2
00260:  INCF   3F,F
....................       
....................       if(step>centercounter){
00262:  MOVF   3A,W
00264:  SUBWF  3F,W
00266:  BNC   0278
00268:  BNZ   0270
0026A:  MOVF   3E,W
0026C:  SUBWF  39,W
0026E:  BC    0278
....................       step=centercounter;
00270:  MOVFF  3A,3F
00274:  MOVFF  39,3E
....................       } 
....................      
....................   }
....................   if (dir==1){
00278:  DECFSZ 49,W
0027A:  BRA    033E
....................       delay_func (speed) ;
0027C:  MOVFF  21,88
00280:  RCALL  0180
....................       output_high (A1) ;
00282:  BCF    F95.2
00284:  BSF    F8C.2
....................       output_low (A2) ;
00286:  BCF    F93.1
00288:  BCF    F8A.1
....................       output_low (B1) ;
0028A:  BCF    F93.0
0028C:  BCF    F8A.0
....................       output_low (B2) ;
0028E:  BCF    F94.5
00290:  BCF    F8B.5
....................       delay_func (speed) ;
00292:  MOVFF  21,88
00296:  RCALL  0180
....................       
....................       output_high (A1) ;
00298:  BCF    F95.2
0029A:  BSF    F8C.2
....................       output_low (A2) ;
0029C:  BCF    F93.1
0029E:  BCF    F8A.1
....................       output_high (B1) ;
002A0:  BCF    F93.0
002A2:  BSF    F8A.0
....................       output_low (B2) ;
002A4:  BCF    F94.5
002A6:  BCF    F8B.5
....................       delay_func (speed) ;
002A8:  MOVFF  21,88
002AC:  RCALL  0180
....................       
....................       output_low (A1) ;
002AE:  BCF    F95.2
002B0:  BCF    F8C.2
....................       output_low (A2) ;
002B2:  BCF    F93.1
002B4:  BCF    F8A.1
....................       output_high (B1) ;
002B6:  BCF    F93.0
002B8:  BSF    F8A.0
....................       output_low (B2) ;
002BA:  BCF    F94.5
002BC:  BCF    F8B.5
....................       delay_func (speed) ;
002BE:  MOVFF  21,88
002C2:  RCALL  0180
....................       
....................       output_low (A1) ;
002C4:  BCF    F95.2
002C6:  BCF    F8C.2
....................       output_high (A2) ;
002C8:  BCF    F93.1
002CA:  BSF    F8A.1
....................       output_high (B1) ;
002CC:  BCF    F93.0
002CE:  BSF    F8A.0
....................       output_low (B2) ;
002D0:  BCF    F94.5
002D2:  BCF    F8B.5
....................       delay_func (speed) ;
002D4:  MOVFF  21,88
002D8:  RCALL  0180
....................       
....................       output_low (A1) ;
002DA:  BCF    F95.2
002DC:  BCF    F8C.2
....................       output_high (A2) ;
002DE:  BCF    F93.1
002E0:  BSF    F8A.1
....................       output_low (B1) ;
002E2:  BCF    F93.0
002E4:  BCF    F8A.0
....................       output_low (B2) ;
002E6:  BCF    F94.5
002E8:  BCF    F8B.5
....................       delay_func (speed) ;
002EA:  MOVFF  21,88
002EE:  RCALL  0180
....................       
....................       output_low (A1) ;
002F0:  BCF    F95.2
002F2:  BCF    F8C.2
....................       output_high (A2) ;
002F4:  BCF    F93.1
002F6:  BSF    F8A.1
....................       output_low (B1) ;
002F8:  BCF    F93.0
002FA:  BCF    F8A.0
....................       output_high (B2) ;
002FC:  BCF    F94.5
002FE:  BSF    F8B.5
....................       delay_func (speed) ;
00300:  MOVFF  21,88
00304:  RCALL  0180
....................       
....................       output_low (A1) ;
00306:  BCF    F95.2
00308:  BCF    F8C.2
....................       output_low (A2) ;
0030A:  BCF    F93.1
0030C:  BCF    F8A.1
....................       output_low (B1) ;
0030E:  BCF    F93.0
00310:  BCF    F8A.0
....................       output_high (B2) ;
00312:  BCF    F94.5
00314:  BSF    F8B.5
....................       delay_func (speed) ;
00316:  MOVFF  21,88
0031A:  RCALL  0180
....................       
....................       output_high (A1) ;
0031C:  BCF    F95.2
0031E:  BSF    F8C.2
....................       output_low (A2) ;
00320:  BCF    F93.1
00322:  BCF    F8A.1
....................       output_low (B1) ;
00324:  BCF    F93.0
00326:  BCF    F8A.0
....................       output_high (B2) ;
00328:  BCF    F94.5
0032A:  BSF    F8B.5
....................       
....................       
....................       step--;
0032C:  MOVF   3E,W
0032E:  BTFSC  FD8.2
00330:  DECF   3F,F
00332:  DECF   3E,F
.................... 
....................       
....................       if(center_flag){
00334:  MOVF   3D,F
00336:  BZ    033E
....................       centercounter++;;
00338:  INCF   39,F
0033A:  BTFSC  FD8.2
0033C:  INCF   3A,F
....................       }
....................      
....................   }
....................   
....................   
....................   set_timer1(65486);
0033E:  SETF   FCF
00340:  MOVLW  CE
00342:  MOVWF  FCE
....................   
....................    
....................   clear_interrupt(INT_TIMER1); 
00344:  BCF    F9E.0
....................   //disable_interrupts(INT_TIMER1);
.................... }
.................... 
.................... 
00346:  BCF    F9E.0
00348:  GOTO   007C
.................... #INT_HLVD
.................... void  LOWVOLT_isr(void) 
.................... {
....................    disable_interrupts(INT_TIMER1); 
0034C:  BCF    F9D.0
....................    disable_interrupts(INT_RDA); 
0034E:  BCF    F9D.5
....................    
....................    write_eeprom(1,delay_s); //speed
00350:  MOVF   FF2,W
00352:  MOVWF  00
00354:  BCF    FF2.7
00356:  CLRF   FAA
00358:  MOVLW  01
0035A:  MOVWF  FA9
0035C:  MOVFF  20,FA8
00360:  BCF    FA6.6
00362:  BCF    FA6.7
00364:  BSF    FA6.2
00366:  MOVLB  F
00368:  MOVLW  55
0036A:  MOVWF  FA7
0036C:  MOVLW  AA
0036E:  MOVWF  FA7
00370:  BSF    FA6.1
00372:  BTFSC  FA6.1
00374:  BRA    0372
00376:  BCF    FA6.2
00378:  MOVF   00,W
0037A:  IORWF  FF2,F
....................    write_eeprom(2,accel); //accel
0037C:  MOVFF  FF2,00
00380:  BCF    FF2.7
00382:  CLRF   FAA
00384:  MOVLW  02
00386:  MOVWF  FA9
00388:  MOVFF  22,FA8
0038C:  BCF    FA6.6
0038E:  BCF    FA6.7
00390:  BSF    FA6.2
00392:  MOVLW  55
00394:  MOVWF  FA7
00396:  MOVLW  AA
00398:  MOVWF  FA7
0039A:  BSF    FA6.1
0039C:  BTFSC  FA6.1
0039E:  BRA    039C
003A0:  BCF    FA6.2
003A2:  MOVF   00,W
003A4:  IORWF  FF2,F
....................    write_eeprom(3,centered); //centered?
003A6:  MOVFF  FF2,00
003AA:  BCF    FF2.7
003AC:  CLRF   FAA
003AE:  MOVLW  03
003B0:  MOVWF  FA9
003B2:  MOVFF  38,FA8
003B6:  BCF    FA6.6
003B8:  BCF    FA6.7
003BA:  BSF    FA6.2
003BC:  MOVLW  55
003BE:  MOVWF  FA7
003C0:  MOVLW  AA
003C2:  MOVWF  FA7
003C4:  BSF    FA6.1
003C6:  BTFSC  FA6.1
003C8:  BRA    03C6
003CA:  BCF    FA6.2
003CC:  MOVF   00,W
003CE:  IORWF  FF2,F
....................    
....................    step1= make8(step,0);
003D0:  MOVFF  3E,40
....................    step2= make8(step,1);
003D4:  MOVFF  3F,41
....................    write_eeprom(4,step1); //pos1
003D8:  MOVFF  FF2,00
003DC:  BCF    FF2.7
003DE:  CLRF   FAA
003E0:  MOVLW  04
003E2:  MOVWF  FA9
003E4:  MOVFF  40,FA8
003E8:  BCF    FA6.6
003EA:  BCF    FA6.7
003EC:  BSF    FA6.2
003EE:  MOVLW  55
003F0:  MOVWF  FA7
003F2:  MOVLW  AA
003F4:  MOVWF  FA7
003F6:  BSF    FA6.1
003F8:  BTFSC  FA6.1
003FA:  BRA    03F8
003FC:  BCF    FA6.2
003FE:  MOVF   00,W
00400:  IORWF  FF2,F
....................    write_eeprom(5,step2); //pos2
00402:  MOVFF  FF2,00
00406:  BCF    FF2.7
00408:  CLRF   FAA
0040A:  MOVLW  05
0040C:  MOVWF  FA9
0040E:  MOVFF  41,FA8
00412:  BCF    FA6.6
00414:  BCF    FA6.7
00416:  BSF    FA6.2
00418:  MOVLW  55
0041A:  MOVWF  FA7
0041C:  MOVLW  AA
0041E:  MOVWF  FA7
00420:  BSF    FA6.1
00422:  BTFSC  FA6.1
00424:  BRA    0422
00426:  BCF    FA6.2
00428:  MOVF   00,W
0042A:  IORWF  FF2,F
....................    
....................    write_eeprom(6,threshold); //threshold
0042C:  MOVFF  FF2,00
00430:  BCF    FF2.7
00432:  CLRF   FAA
00434:  MOVLW  06
00436:  MOVWF  FA9
00438:  MOVFF  44,FA8
0043C:  BCF    FA6.6
0043E:  BCF    FA6.7
00440:  BSF    FA6.2
00442:  MOVLW  55
00444:  MOVWF  FA7
00446:  MOVLW  AA
00448:  MOVWF  FA7
0044A:  BSF    FA6.1
0044C:  BTFSC  FA6.1
0044E:  BRA    044C
00450:  BCF    FA6.2
00452:  MOVF   00,W
00454:  IORWF  FF2,F
....................    
....................    cc1= make8(centercounter,0);
00456:  MOVFF  39,3B
....................    cc2= make8(centercounter,1);
0045A:  MOVFF  3A,3C
....................    write_eeprom(7,cc1); //cc1
0045E:  MOVFF  FF2,00
00462:  BCF    FF2.7
00464:  CLRF   FAA
00466:  MOVLW  07
00468:  MOVWF  FA9
0046A:  MOVFF  3B,FA8
0046E:  BCF    FA6.6
00470:  BCF    FA6.7
00472:  BSF    FA6.2
00474:  MOVLW  55
00476:  MOVWF  FA7
00478:  MOVLW  AA
0047A:  MOVWF  FA7
0047C:  BSF    FA6.1
0047E:  BTFSC  FA6.1
00480:  BRA    047E
00482:  BCF    FA6.2
00484:  MOVF   00,W
00486:  IORWF  FF2,F
....................    write_eeprom(8,cc2); //cc2
00488:  MOVFF  FF2,00
0048C:  BCF    FF2.7
0048E:  CLRF   FAA
00490:  MOVLW  08
00492:  MOVWF  FA9
00494:  MOVFF  3C,FA8
00498:  BCF    FA6.6
0049A:  BCF    FA6.7
0049C:  BSF    FA6.2
0049E:  MOVLW  55
004A0:  MOVWF  FA7
004A2:  MOVLW  AA
004A4:  MOVWF  FA7
004A6:  BSF    FA6.1
004A8:  BTFSC  FA6.1
004AA:  BRA    04A8
004AC:  BCF    FA6.2
004AE:  MOVF   00,W
004B0:  IORWF  FF2,F
....................    
....................    write_eeprom(9,line1);
004B2:  MOVFF  FF2,00
004B6:  BCF    FF2.7
004B8:  CLRF   FAA
004BA:  MOVLW  09
004BC:  MOVWF  FA9
004BE:  MOVFF  42,FA8
004C2:  BCF    FA6.6
004C4:  BCF    FA6.7
004C6:  BSF    FA6.2
004C8:  MOVLW  55
004CA:  MOVWF  FA7
004CC:  MOVLW  AA
004CE:  MOVWF  FA7
004D0:  BSF    FA6.1
004D2:  BTFSC  FA6.1
004D4:  BRA    04D2
004D6:  BCF    FA6.2
004D8:  MOVF   00,W
004DA:  IORWF  FF2,F
....................    
....................    write_eeprom(10,control_right);
004DC:  MOVFF  FF2,00
004E0:  BCF    FF2.7
004E2:  CLRF   FAA
004E4:  MOVLW  0A
004E6:  MOVWF  FA9
004E8:  MOVFF  37,FA8
004EC:  BCF    FA6.6
004EE:  BCF    FA6.7
004F0:  BSF    FA6.2
004F2:  MOVLW  55
004F4:  MOVWF  FA7
004F6:  MOVLW  AA
004F8:  MOVWF  FA7
004FA:  BSF    FA6.1
004FC:  BTFSC  FA6.1
004FE:  BRA    04FC
00500:  BCF    FA6.2
00502:  MOVF   00,W
00504:  IORWF  FF2,F
....................    write_eeprom(11,control_left);
00506:  MOVFF  FF2,00
0050A:  BCF    FF2.7
0050C:  CLRF   FAA
0050E:  MOVLW  0B
00510:  MOVWF  FA9
00512:  MOVFF  36,FA8
00516:  BCF    FA6.6
00518:  BCF    FA6.7
0051A:  BSF    FA6.2
0051C:  MOVLW  55
0051E:  MOVWF  FA7
00520:  MOVLW  AA
00522:  MOVWF  FA7
00524:  BSF    FA6.1
00526:  BTFSC  FA6.1
00528:  BRA    0526
0052A:  BCF    FA6.2
0052C:  MOVF   00,W
0052E:  IORWF  FF2,F
....................    
....................    output_high(pin_b7);
00530:  BCF    F93.7
00532:  BSF    F8A.7
....................    output_low(pin_b7);
00534:  BCF    F93.7
00536:  BCF    F8A.7
....................    output_high(pin_b7);
00538:  BCF    F93.7
0053A:  BSF    F8A.7
....................    output_low(pin_b7);
0053C:  BCF    F93.7
0053E:  BCF    F8A.7
....................    output_high(pin_b7);
00540:  BCF    F93.7
00542:  BSF    F8A.7
....................    output_low(pin_b7);
00544:  BCF    F93.7
00546:  BCF    F8A.7
....................    output_high(pin_b7);
00548:  BCF    F93.7
0054A:  BSF    F8A.7
....................    output_low(pin_b7);
0054C:  BCF    F93.7
0054E:  BCF    F8A.7
....................    
....................    disable_interrupts(INT_HLVD);
00550:  BCF    FA0.2
00552:  BCF    FA1.2
00554:  MOVLB  0
00556:  GOTO   007C
.................... }
.................... 
.................... 
.................... void main()
*
01404:  CLRF   FF8
01406:  BCF    F9F.0
01408:  BSF    F9F.5
0140A:  BCF    FA2.2
0140C:  BSF    FD0.7
0140E:  BSF    07.7
01410:  MOVLW  70
01412:  MOVWF  FD3
01414:  BSF    F9B.6
01416:  BCF    F9B.7
01418:  CLRF   1C
0141A:  CLRF   1B
0141C:  CLRF   1A
0141E:  CLRF   19
01420:  BCF    FD5.7
01422:  MOVLW  87
01424:  MOVWF  FD5
01426:  CLRF   FD7
01428:  CLRF   FD6
0142A:  BCF    FF2.2
0142C:  BSF    FB8.3
0142E:  MOVLW  82
01430:  MOVWF  FAF
01432:  MOVLW  06
01434:  MOVWF  FB0
01436:  MOVLW  A6
01438:  MOVWF  FAC
0143A:  MOVLW  90
0143C:  MOVWF  FAB
0143E:  MOVLW  05
01440:  MOVWF  20
01442:  CLRF   21
01444:  MOVLW  06
01446:  MOVWF  22
01448:  MOVLW  1E
0144A:  MOVWF  23
0144C:  CLRF   24
0144E:  CLRF   25
01450:  MOVLW  01
01452:  MOVWF  26
01454:  MOVWF  27
01456:  CLRF   31
01458:  CLRF   32
0145A:  CLRF   33
0145C:  CLRF   34
0145E:  CLRF   35
01460:  MOVWF  36
01462:  MOVWF  37
01464:  CLRF   38
01466:  SETF   3A
01468:  SETF   39
0146A:  CLRF   3D
0146C:  MOVWF  3F
0146E:  MOVLW  5E
01470:  MOVWF  3E
01472:  CLRF   42
01474:  CLRF   43
01476:  CLRF   44
01478:  MOVLW  01
0147A:  SUBWF  44,W
0147C:  MOVWF  45
0147E:  MOVLW  01
01480:  MOVWF  46
01482:  CLRF   47
01484:  MOVWF  48
01486:  CLRF   49
01488:  CLRF   x69
0148A:  CLRF   x68
0148C:  MOVLB  F
0148E:  CLRF   x38
01490:  CLRF   x39
01492:  CLRF   x3A
01494:  CLRF   x3B
01496:  CLRF   x3C
01498:  CLRF   F77
0149A:  CLRF   F78
0149C:  CLRF   F79
0149E:  CLRF   1D
014A0:  CLRF   1E
014A2:  MOVLW  31
014A4:  MOVWF  4A
014A6:  MOVLW  32
014A8:  MOVWF  4B
014AA:  MOVLW  33
014AC:  MOVWF  4C
014AE:  MOVLW  34
014B0:  MOVWF  4D
014B2:  MOVLW  35
014B4:  MOVWF  4E
014B6:  MOVLW  36
014B8:  MOVWF  4F
014BA:  MOVLW  37
014BC:  MOVWF  50
014BE:  MOVLW  38
014C0:  MOVWF  51
014C2:  MOVLW  39
014C4:  MOVWF  52
014C6:  MOVLW  01
014C8:  MOVWF  53
014CA:  MOVLW  02
014CC:  MOVWF  54
014CE:  MOVLW  03
014D0:  MOVWF  55
014D2:  MOVLW  04
014D4:  MOVWF  56
014D6:  MOVLW  05
014D8:  MOVWF  57
014DA:  MOVLW  06
014DC:  MOVWF  58
014DE:  MOVLW  07
014E0:  MOVWF  59
014E2:  MOVLW  08
014E4:  MOVWF  5A
014E6:  MOVLW  09
014E8:  MOVWF  5B
.................... {
.................... 
....................    setup_CCP1 (CCP_OFF);
014EA:  MOVLW  F0
014EC:  ANDWF  FBD,F
....................    clear_interrupt(INT_TIMER1); 
014EE:  BCF    F9E.0
....................    
....................    setup_low_volt_detect(LVD_TRIGGER_BELOW | LVD_36 );
014F0:  MOVLW  1A
014F2:  MOVWF  F9C
....................    enable_interrupts(INT_HLVD);
014F4:  BSF    FA0.2
....................    
....................    enable_interrupts(GLOBAL);
014F6:  MOVLW  C0
014F8:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA);
014FA:  BSF    F9D.5
....................    disable_interrupts(INT_TIMER1); 
014FC:  BCF    F9D.0
....................    
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8);      // Timer1 configuration: internal clock source + 8 prescaler
014FE:  MOVLW  37
01500:  MOVWF  FCD
01502:  CLRF   FCC
....................    set_timer1(65486);  //65488 --- 63350
01504:  SETF   FCF
01506:  MOVLW  CE
01508:  MOVWF  FCE
....................    
....................    lcd_init();
0150A:  MOVLB  0
0150C:  GOTO   06F8
.................... 
....................    lcd_load_custom_chars(); 
01510:  GOTO   074A
.................... 
....................    FinishTick = StartTick = CurrentTick = get_ticks(); //timers for centering 
01514:  CALL   077C
01518:  MOVFF  03,67
0151C:  MOVFF  02,66
01520:  MOVFF  01,65
01524:  MOVFF  00,64
01528:  MOVFF  67,5F
0152C:  MOVFF  66,5E
01530:  MOVFF  65,5D
01534:  MOVFF  64,5C
01538:  MOVFF  5F,63
0153C:  MOVFF  5E,62
01540:  MOVFF  5D,61
01544:  MOVFF  5C,60
....................    
....................   if(read_eeprom(1)<=0 | read_eeprom(1)>10){
01548:  MOVFF  FF2,72
0154C:  BCF    FF2.7
0154E:  CLRF   FAA
01550:  MOVLW  01
01552:  MOVWF  FA9
01554:  BCF    FA6.6
01556:  BCF    FA6.7
01558:  BSF    FA6.0
0155A:  MOVF   FA8,W
0155C:  BTFSC  x72.7
0155E:  BSF    FF2.7
01560:  XORLW  00
01562:  BZ    1568
01564:  MOVLW  00
01566:  BRA    156A
01568:  MOVLW  01
0156A:  MOVWF  x73
0156C:  MOVFF  FF2,74
01570:  BCF    FF2.7
01572:  CLRF   FAA
01574:  MOVLW  01
01576:  MOVWF  FA9
01578:  BCF    FA6.6
0157A:  BCF    FA6.7
0157C:  BSF    FA6.0
0157E:  MOVF   FA8,W
01580:  BTFSC  x74.7
01582:  BSF    FF2.7
01584:  SUBLW  0A
01586:  BNC   158C
01588:  MOVLW  00
0158A:  BRA    158E
0158C:  MOVLW  01
0158E:  IORWF  x73,W
01590:  XORLW  00
01592:  BTFSC  FD8.2
01594:  BRA    1776
....................    
....................    write_eeprom(1,5); //speed
01596:  MOVF   FF2,W
01598:  MOVWF  00
0159A:  BCF    FF2.7
0159C:  CLRF   FAA
0159E:  MOVLW  01
015A0:  MOVWF  FA9
015A2:  MOVLW  05
015A4:  MOVWF  FA8
015A6:  BCF    FA6.6
015A8:  BCF    FA6.7
015AA:  BSF    FA6.2
015AC:  MOVLB  F
015AE:  MOVLW  55
015B0:  MOVWF  FA7
015B2:  MOVLW  AA
015B4:  MOVWF  FA7
015B6:  BSF    FA6.1
015B8:  BTFSC  FA6.1
015BA:  BRA    15B8
015BC:  BCF    FA6.2
015BE:  MOVF   00,W
015C0:  IORWF  FF2,F
....................    write_eeprom(2,6); //accel
015C2:  MOVFF  FF2,00
015C6:  BCF    FF2.7
015C8:  CLRF   FAA
015CA:  MOVLW  02
015CC:  MOVWF  FA9
015CE:  MOVLW  06
015D0:  MOVWF  FA8
015D2:  BCF    FA6.6
015D4:  BCF    FA6.7
015D6:  BSF    FA6.2
015D8:  MOVLW  55
015DA:  MOVWF  FA7
015DC:  MOVLW  AA
015DE:  MOVWF  FA7
015E0:  BSF    FA6.1
015E2:  BTFSC  FA6.1
015E4:  BRA    15E2
015E6:  BCF    FA6.2
015E8:  MOVF   00,W
015EA:  IORWF  FF2,F
....................    write_eeprom(3,0); //centered?
015EC:  MOVFF  FF2,00
015F0:  BCF    FF2.7
015F2:  CLRF   FAA
015F4:  MOVLW  03
015F6:  MOVWF  FA9
015F8:  CLRF   FA8
015FA:  BCF    FA6.6
015FC:  BCF    FA6.7
015FE:  BSF    FA6.2
01600:  MOVLW  55
01602:  MOVWF  FA7
01604:  MOVLW  AA
01606:  MOVWF  FA7
01608:  BSF    FA6.1
0160A:  BTFSC  FA6.1
0160C:  BRA    160A
0160E:  BCF    FA6.2
01610:  MOVF   00,W
01612:  IORWF  FF2,F
....................    
....................    write_eeprom(4,100); //pos1
01614:  MOVFF  FF2,00
01618:  BCF    FF2.7
0161A:  CLRF   FAA
0161C:  MOVLW  04
0161E:  MOVWF  FA9
01620:  MOVLW  64
01622:  MOVWF  FA8
01624:  BCF    FA6.6
01626:  BCF    FA6.7
01628:  BSF    FA6.2
0162A:  MOVLW  55
0162C:  MOVWF  FA7
0162E:  MOVLW  AA
01630:  MOVWF  FA7
01632:  BSF    FA6.1
01634:  BTFSC  FA6.1
01636:  BRA    1634
01638:  BCF    FA6.2
0163A:  MOVF   00,W
0163C:  IORWF  FF2,F
....................    write_eeprom(5,100); //pos2
0163E:  MOVFF  FF2,00
01642:  BCF    FF2.7
01644:  CLRF   FAA
01646:  MOVLW  05
01648:  MOVWF  FA9
0164A:  MOVLW  64
0164C:  MOVWF  FA8
0164E:  BCF    FA6.6
01650:  BCF    FA6.7
01652:  BSF    FA6.2
01654:  MOVLW  55
01656:  MOVWF  FA7
01658:  MOVLW  AA
0165A:  MOVWF  FA7
0165C:  BSF    FA6.1
0165E:  BTFSC  FA6.1
01660:  BRA    165E
01662:  BCF    FA6.2
01664:  MOVF   00,W
01666:  IORWF  FF2,F
....................    
....................    write_eeprom(6,0); //threshold
01668:  MOVFF  FF2,00
0166C:  BCF    FF2.7
0166E:  CLRF   FAA
01670:  MOVLW  06
01672:  MOVWF  FA9
01674:  CLRF   FA8
01676:  BCF    FA6.6
01678:  BCF    FA6.7
0167A:  BSF    FA6.2
0167C:  MOVLW  55
0167E:  MOVWF  FA7
01680:  MOVLW  AA
01682:  MOVWF  FA7
01684:  BSF    FA6.1
01686:  BTFSC  FA6.1
01688:  BRA    1686
0168A:  BCF    FA6.2
0168C:  MOVF   00,W
0168E:  IORWF  FF2,F
....................    
....................    write_eeprom(7,0); //cc1
01690:  MOVFF  FF2,00
01694:  BCF    FF2.7
01696:  CLRF   FAA
01698:  MOVLW  07
0169A:  MOVWF  FA9
0169C:  CLRF   FA8
0169E:  BCF    FA6.6
016A0:  BCF    FA6.7
016A2:  BSF    FA6.2
016A4:  MOVLW  55
016A6:  MOVWF  FA7
016A8:  MOVLW  AA
016AA:  MOVWF  FA7
016AC:  BSF    FA6.1
016AE:  BTFSC  FA6.1
016B0:  BRA    16AE
016B2:  BCF    FA6.2
016B4:  MOVF   00,W
016B6:  IORWF  FF2,F
....................    write_eeprom(8,0); //cc2
016B8:  MOVFF  FF2,00
016BC:  BCF    FF2.7
016BE:  CLRF   FAA
016C0:  MOVLW  08
016C2:  MOVWF  FA9
016C4:  CLRF   FA8
016C6:  BCF    FA6.6
016C8:  BCF    FA6.7
016CA:  BSF    FA6.2
016CC:  MOVLW  55
016CE:  MOVWF  FA7
016D0:  MOVLW  AA
016D2:  MOVWF  FA7
016D4:  BSF    FA6.1
016D6:  BTFSC  FA6.1
016D8:  BRA    16D6
016DA:  BCF    FA6.2
016DC:  MOVF   00,W
016DE:  IORWF  FF2,F
....................    
....................    write_eeprom(9,0); //line1 
016E0:  MOVFF  FF2,00
016E4:  BCF    FF2.7
016E6:  CLRF   FAA
016E8:  MOVLW  09
016EA:  MOVWF  FA9
016EC:  CLRF   FA8
016EE:  BCF    FA6.6
016F0:  BCF    FA6.7
016F2:  BSF    FA6.2
016F4:  MOVLW  55
016F6:  MOVWF  FA7
016F8:  MOVLW  AA
016FA:  MOVWF  FA7
016FC:  BSF    FA6.1
016FE:  BTFSC  FA6.1
01700:  BRA    16FE
01702:  BCF    FA6.2
01704:  MOVF   00,W
01706:  IORWF  FF2,F
....................    
....................    write_eeprom(10,1); //check_right
01708:  MOVFF  FF2,00
0170C:  BCF    FF2.7
0170E:  CLRF   FAA
01710:  MOVLW  0A
01712:  MOVWF  FA9
01714:  MOVLW  01
01716:  MOVWF  FA8
01718:  BCF    FA6.6
0171A:  BCF    FA6.7
0171C:  BSF    FA6.2
0171E:  MOVLW  55
01720:  MOVWF  FA7
01722:  MOVLW  AA
01724:  MOVWF  FA7
01726:  BSF    FA6.1
01728:  BTFSC  FA6.1
0172A:  BRA    1728
0172C:  BCF    FA6.2
0172E:  MOVF   00,W
01730:  IORWF  FF2,F
....................    write_eeprom(11,1); //check_left 
01732:  MOVFF  FF2,00
01736:  BCF    FF2.7
01738:  CLRF   FAA
0173A:  MOVLW  0B
0173C:  MOVWF  FA9
0173E:  MOVLW  01
01740:  MOVWF  FA8
01742:  BCF    FA6.6
01744:  BCF    FA6.7
01746:  BSF    FA6.2
01748:  MOVLW  55
0174A:  MOVWF  FA7
0174C:  MOVLW  AA
0174E:  MOVWF  FA7
01750:  BSF    FA6.1
01752:  BTFSC  FA6.1
01754:  BRA    1752
01756:  BCF    FA6.2
01758:  MOVF   00,W
0175A:  IORWF  FF2,F
....................    
....................    lcd_gotoxy(1,3);
0175C:  MOVLW  01
0175E:  MOVLB  0
01760:  MOVWF  x7F
01762:  MOVLW  03
01764:  MOVWF  x80
01766:  CALL   07CE
....................    lcd_putc("Eeprom Fail");
0176A:  MOVLW  5A
0176C:  MOVWF  FF6
0176E:  MOVLW  05
01770:  MOVWF  FF7
01772:  CALL   0856
....................    
....................    
....................   }
....................   
....................   delay_s=read_eeprom(1);
01776:  MOVFF  FF2,72
0177A:  BCF    FF2.7
0177C:  CLRF   FAA
0177E:  MOVLW  01
01780:  MOVWF  FA9
01782:  BCF    FA6.6
01784:  BCF    FA6.7
01786:  BSF    FA6.0
01788:  MOVF   FA8,W
0178A:  BTFSC  x72.7
0178C:  BSF    FF2.7
0178E:  MOVWF  20
....................   accel=read_eeprom(2);
01790:  MOVFF  FF2,72
01794:  BCF    FF2.7
01796:  CLRF   FAA
01798:  MOVLW  02
0179A:  MOVWF  FA9
0179C:  BCF    FA6.6
0179E:  BCF    FA6.7
017A0:  BSF    FA6.0
017A2:  MOVF   FA8,W
017A4:  BTFSC  x72.7
017A6:  BSF    FF2.7
017A8:  MOVWF  22
....................   centered=read_eeprom(3);
017AA:  MOVFF  FF2,72
017AE:  BCF    FF2.7
017B0:  CLRF   FAA
017B2:  MOVLW  03
017B4:  MOVWF  FA9
017B6:  BCF    FA6.6
017B8:  BCF    FA6.7
017BA:  BSF    FA6.0
017BC:  MOVF   FA8,W
017BE:  BTFSC  x72.7
017C0:  BSF    FF2.7
017C2:  MOVWF  38
....................   
....................   control_right=read_eeprom(10);
017C4:  MOVFF  FF2,72
017C8:  BCF    FF2.7
017CA:  CLRF   FAA
017CC:  MOVLW  0A
017CE:  MOVWF  FA9
017D0:  BCF    FA6.6
017D2:  BCF    FA6.7
017D4:  BSF    FA6.0
017D6:  MOVF   FA8,W
017D8:  BTFSC  x72.7
017DA:  BSF    FF2.7
017DC:  MOVWF  37
....................   control_left=read_eeprom(11);
017DE:  MOVFF  FF2,72
017E2:  BCF    FF2.7
017E4:  CLRF   FAA
017E6:  MOVLW  0B
017E8:  MOVWF  FA9
017EA:  BCF    FA6.6
017EC:  BCF    FA6.7
017EE:  BSF    FA6.0
017F0:  MOVF   FA8,W
017F2:  BTFSC  x72.7
017F4:  BSF    FF2.7
017F6:  MOVWF  36
....................   
....................   if(centered){
017F8:  MOVF   38,F
017FA:  BTFSC  FD8.2
017FC:  BRA    198A
....................   
....................   step1=read_eeprom(4);
017FE:  MOVFF  FF2,72
01802:  BCF    FF2.7
01804:  CLRF   FAA
01806:  MOVLW  04
01808:  MOVWF  FA9
0180A:  BCF    FA6.6
0180C:  BCF    FA6.7
0180E:  BSF    FA6.0
01810:  MOVF   FA8,W
01812:  BTFSC  x72.7
01814:  BSF    FF2.7
01816:  MOVWF  40
....................   step2=read_eeprom(5);
01818:  MOVFF  FF2,72
0181C:  BCF    FF2.7
0181E:  CLRF   FAA
01820:  MOVLW  05
01822:  MOVWF  FA9
01824:  BCF    FA6.6
01826:  BCF    FA6.7
01828:  BSF    FA6.0
0182A:  MOVF   FA8,W
0182C:  BTFSC  x72.7
0182E:  BSF    FF2.7
01830:  MOVWF  41
....................   
....................   step=make16(step2,step1);
01832:  MOVFF  41,3F
01836:  MOVFF  40,3E
....................   lcd_gotoxy(1,3);
0183A:  MOVLW  01
0183C:  MOVWF  x7F
0183E:  MOVLW  03
01840:  MOVWF  x80
01842:  CALL   07CE
....................   printf(lcd_putc,"%lu",step);
01846:  MOVLW  10
01848:  MOVWF  FE9
0184A:  MOVFF  3F,76
0184E:  MOVFF  3E,75
01852:  CALL   0876
....................   
....................   threshold=read_eeprom(6);
01856:  MOVFF  FF2,72
0185A:  BCF    FF2.7
0185C:  CLRF   FAA
0185E:  MOVLW  06
01860:  MOVWF  FA9
01862:  BCF    FA6.6
01864:  BCF    FA6.7
01866:  BSF    FA6.0
01868:  MOVF   FA8,W
0186A:  BTFSC  x72.7
0186C:  BSF    FF2.7
0186E:  MOVWF  44
....................   printf(lcd_putc," %d",threshold);
01870:  MOVLW  20
01872:  MOVWF  x7E
01874:  CALL   080E
01878:  MOVFF  44,73
0187C:  MOVLW  18
0187E:  MOVWF  x74
01880:  CALL   0958
....................   
....................   cc1=read_eeprom(7);
01884:  MOVFF  FF2,72
01888:  BCF    FF2.7
0188A:  CLRF   FAA
0188C:  MOVLW  07
0188E:  MOVWF  FA9
01890:  BCF    FA6.6
01892:  BCF    FA6.7
01894:  BSF    FA6.0
01896:  MOVF   FA8,W
01898:  BTFSC  x72.7
0189A:  BSF    FF2.7
0189C:  MOVWF  3B
....................   cc2=read_eeprom(8);
0189E:  MOVFF  FF2,72
018A2:  BCF    FF2.7
018A4:  CLRF   FAA
018A6:  MOVLW  08
018A8:  MOVWF  FA9
018AA:  BCF    FA6.6
018AC:  BCF    FA6.7
018AE:  BSF    FA6.0
018B0:  MOVF   FA8,W
018B2:  BTFSC  x72.7
018B4:  BSF    FF2.7
018B6:  MOVWF  3C
....................   centercounter=make16(cc2,cc1);
018B8:  MOVFF  3C,3A
018BC:  MOVFF  3B,39
....................   
....................   //ine1=step/threshold;
....................   //line1++;
....................   
....................   line1=read_eeprom(9);
018C0:  MOVFF  FF2,72
018C4:  BCF    FF2.7
018C6:  CLRF   FAA
018C8:  MOVLW  09
018CA:  MOVWF  FA9
018CC:  BCF    FA6.6
018CE:  BCF    FA6.7
018D0:  BSF    FA6.0
018D2:  MOVF   FA8,W
018D4:  BTFSC  x72.7
018D6:  BSF    FF2.7
018D8:  MOVWF  42
....................   
....................   lcd_gotoxy(1,4);
018DA:  MOVLW  01
018DC:  MOVWF  x7F
018DE:  MOVLW  04
018E0:  MOVWF  x80
018E2:  CALL   07CE
....................   lcd_putc(swoff);
018E6:  MOVLW  02
018E8:  MOVWF  x7E
018EA:  CALL   080E
....................   lcd_gotoxy(20,4);
018EE:  MOVLW  14
018F0:  MOVWF  x7F
018F2:  MOVLW  04
018F4:  MOVWF  x80
018F6:  CALL   07CE
....................   lcd_putc(swoff);
018FA:  MOVLW  02
018FC:  MOVWF  x7E
018FE:  CALL   080E
....................   
....................   if(step>=threshold){
01902:  MOVF   3F,F
01904:  BNZ   190C
01906:  MOVF   44,W
01908:  SUBWF  3E,W
0190A:  BNC   192C
....................   for(int i=2;i<=line1;i++){
0190C:  MOVLW  02
0190E:  MOVWF  x6A
01910:  MOVF   x6A,W
01912:  SUBWF  42,W
01914:  BNC   192C
....................      lcd_gotoxy(i,4);
01916:  MOVFF  6A,7F
0191A:  MOVLW  04
0191C:  MOVWF  x80
0191E:  CALL   07CE
....................      lcd_putc(three_dot);
01922:  CLRF   x7E
01924:  CALL   080E
01928:  INCF   x6A,F
0192A:  BRA    1910
....................   }
....................   }
....................  
....................   if (input(proxy_left)) {
0192C:  BSF    F95.7
0192E:  BTFSS  F83.7
01930:  BRA    195A
....................   
....................       lcd_gotoxy(1,4);
01932:  MOVLW  01
01934:  MOVWF  x7F
01936:  MOVLW  04
01938:  MOVWF  x80
0193A:  CALL   07CE
....................       lcd_putc(swoff);
0193E:  MOVLW  02
01940:  MOVWF  x7E
01942:  CALL   080E
....................       
....................       lcd_gotoxy(20,4);
01946:  MOVLW  14
01948:  MOVWF  x7F
0194A:  MOVLW  04
0194C:  MOVWF  x80
0194E:  CALL   07CE
....................       lcd_putc(swon);
01952:  MOVLW  01
01954:  MOVWF  x7E
01956:  CALL   080E
....................       
....................   }
....................   
....................   if (input(proxy_right)) {
0195A:  BSF    F95.6
0195C:  BTFSS  F83.6
0195E:  BRA    1988
....................   
....................       lcd_gotoxy(1,4);
01960:  MOVLW  01
01962:  MOVWF  x7F
01964:  MOVLW  04
01966:  MOVWF  x80
01968:  CALL   07CE
....................       lcd_putc(swon);
0196C:  MOVLW  01
0196E:  MOVWF  x7E
01970:  CALL   080E
....................       
....................       lcd_gotoxy(20,4);
01974:  MOVLW  14
01976:  MOVWF  x7F
01978:  MOVLW  04
0197A:  MOVWF  x80
0197C:  CALL   07CE
....................       lcd_putc(swoff);
01980:  MOVLW  02
01982:  MOVWF  x7E
01984:  CALL   080E
....................   }
....................      
....................   }
01988:  BRA    19A0
....................   
....................   else{
....................    lcd_gotoxy(4,4);
0198A:  MOVLW  04
0198C:  MOVWF  x7F
0198E:  MOVWF  x80
01990:  CALL   07CE
....................    lcd_putc("Centee Machine");
01994:  MOVLW  66
01996:  MOVWF  FF6
01998:  MOVLW  05
0199A:  MOVWF  FF7
0199C:  CALL   0856
....................   
....................   }
....................   ////////////////////////////////////////////
....................   
....................    while (TRUE)
....................    {
....................       enable_interrupts (INT_RDA);
019A0:  BSF    F9D.5
....................       //output_toggle (PIN_D4);
....................        
....................       lcd_gotoxy(1,1);
019A2:  MOVLW  01
019A4:  MOVWF  x7F
019A6:  MOVWF  x80
019A8:  CALL   07CE
....................       lcd_putc("Speed: %   ");
019AC:  MOVLW  76
019AE:  MOVWF  FF6
019B0:  MOVLW  05
019B2:  MOVWF  FF7
019B4:  CALL   0856
....................       lcd_gotoxy(9,1);
019B8:  MOVLW  09
019BA:  MOVWF  x7F
019BC:  MOVLW  01
019BE:  MOVWF  x80
019C0:  CALL   07CE
....................       printf(lcd_putc,"%u",delay_s*10);
019C4:  MOVF   20,W
019C6:  MULLW  0A
019C8:  MOVFF  FF3,73
019CC:  MOVLW  1B
019CE:  MOVWF  x74
019D0:  CALL   0A02
....................       
....................       lcd_gotoxy(13,1);
019D4:  MOVLW  0D
019D6:  MOVWF  x7F
019D8:  MOVLW  01
019DA:  MOVWF  x80
019DC:  CALL   07CE
....................       if (mode_manuel){
019E0:  MOVF   26,F
019E2:  BZ    19F0
....................          lcd_putc("<Manuel>");
019E4:  MOVLW  82
019E6:  MOVWF  FF6
019E8:  MOVLW  05
019EA:  MOVWF  FF7
019EC:  CALL   0856
....................       }
....................       
....................       if (mode_auto){
019F0:  MOVF   25,F
019F2:  BZ    1A00
....................          lcd_putc("< Auto >");
019F4:  MOVLW  8C
019F6:  MOVWF  FF6
019F8:  MOVLW  05
019FA:  MOVWF  FF7
019FC:  CALL   0856
....................       }
....................       
....................       lcd_gotoxy(1,2);
01A00:  MOVLW  01
01A02:  MOVWF  x7F
01A04:  MOVLW  02
01A06:  MOVWF  x80
01A08:  CALL   07CE
....................       lcd_putc("Accel: %   ");
01A0C:  MOVLW  96
01A0E:  MOVWF  FF6
01A10:  MOVLW  05
01A12:  MOVWF  FF7
01A14:  CALL   0856
....................       lcd_gotoxy(9,2);
01A18:  MOVLW  09
01A1A:  MOVWF  x7F
01A1C:  MOVLW  02
01A1E:  MOVWF  x80
01A20:  CALL   07CE
....................       printf(lcd_putc,"%u",accel*10);
01A24:  MOVF   22,W
01A26:  MULLW  0A
01A28:  MOVFF  FF3,73
01A2C:  MOVLW  1B
01A2E:  MOVWF  x74
01A30:  CALL   0A02
....................       
....................       if(centered==False){
01A34:  MOVF   38,F
01A36:  BNZ   1A4E
....................          lcd_gotoxy(4,4);
01A38:  MOVLW  04
01A3A:  MOVWF  x7F
01A3C:  MOVWF  x80
01A3E:  CALL   07CE
....................          lcd_putc("Center Machine");
01A42:  MOVLW  A2
01A44:  MOVWF  FF6
01A46:  MOVLW  05
01A48:  MOVWF  FF7
01A4A:  CALL   0856
....................       }
....................      
....................       
.................... ///////////////////>>>>>> MODE CHANGE  <<<<<//////////////////////
.................... 
....................       if (input (button5))
01A4E:  BSF    F94.1
01A50:  BTFSS  F82.1
01A52:  BRA    1F98
....................       {
....................          while(input (button5)){};
01A54:  BSF    F94.1
01A56:  BTFSC  F82.1
01A58:  BRA    1A54
....................          int mode_cursor=1;
....................          char mod_flag=False;
01A5A:  MOVLW  01
01A5C:  MOVWF  x6B
01A5E:  CLRF   x6C
....................          
....................          StartTick=get_ticks();
01A60:  CALL   077C
01A64:  MOVFF  03,5F
01A68:  MOVFF  02,5E
01A6C:  MOVFF  01,5D
01A70:  MOVFF  00,5C
....................          delay_ms(500);
01A74:  MOVLW  02
01A76:  MOVWF  x72
01A78:  MOVLW  FA
01A7A:  MOVWF  x7F
01A7C:  CALL   05E4
01A80:  DECFSZ x72,F
01A82:  BRA    1A78
....................          while(1){
....................          
....................           if(mode_cursor==1){ //SET SPEED
01A84:  DECFSZ x6B,W
01A86:  BRA    1C8E
....................              
....................             CurrentTick=get_ticks();
01A88:  CALL   077C
01A8C:  MOVFF  03,67
01A90:  MOVFF  02,66
01A94:  MOVFF  01,65
01A98:  MOVFF  00,64
....................            
....................             if(CurrentTick-StartTick>2500 & mod_flag==True){
01A9C:  MOVF   5C,W
01A9E:  SUBWF  x64,W
01AA0:  MOVWF  x72
01AA2:  MOVF   5D,W
01AA4:  SUBWFB x65,W
01AA6:  MOVWF  x73
01AA8:  MOVF   5E,W
01AAA:  SUBWFB x66,W
01AAC:  MOVWF  x74
01AAE:  MOVF   5F,W
01AB0:  SUBWFB x67,W
01AB2:  MOVWF  x75
01AB4:  MOVF   x75,F
01AB6:  BNZ   1AD0
01AB8:  MOVF   x74,F
01ABA:  BNZ   1AD0
01ABC:  MOVF   x73,W
01ABE:  SUBLW  08
01AC0:  BC    1ACC
01AC2:  XORLW  FF
01AC4:  BNZ   1AD0
01AC6:  MOVF   x72,W
01AC8:  SUBLW  C4
01ACA:  BNC   1AD0
01ACC:  MOVLW  00
01ACE:  BRA    1AD2
01AD0:  MOVLW  01
01AD2:  MOVWF  x72
01AD4:  DECFSZ x6C,W
01AD6:  BRA    1ADA
01AD8:  BRA    1ADE
01ADA:  MOVLW  00
01ADC:  BRA    1AE0
01ADE:  MOVLW  01
01AE0:  ANDWF  x72,W
01AE2:  BZ    1B1E
....................             
....................             lcd_gotoxy(8,mode_cursor);
01AE4:  MOVLW  08
01AE6:  MOVWF  x7F
01AE8:  MOVFF  6B,80
01AEC:  CALL   07CE
....................             lcd_putc("%");
01AF0:  MOVLW  B2
01AF2:  MOVWF  FF6
01AF4:  MOVLW  05
01AF6:  MOVWF  FF7
01AF8:  CALL   0856
....................             printf(lcd_putc,"%d",delay_s*10);
01AFC:  MOVF   20,W
01AFE:  MULLW  0A
01B00:  MOVFF  FF3,73
01B04:  MOVLW  18
01B06:  MOVWF  x74
01B08:  CALL   0958
....................             
....................             mod_flag=False;
01B0C:  CLRF   x6C
....................             StartTick=CurrentTick;
01B0E:  MOVFF  67,5F
01B12:  MOVFF  66,5E
01B16:  MOVFF  65,5D
01B1A:  MOVFF  64,5C
....................             }
....................             
....................             if(CurrentTick-StartTick>2500 & mod_flag==False){
01B1E:  MOVF   5C,W
01B20:  SUBWF  x64,W
01B22:  MOVWF  x72
01B24:  MOVF   5D,W
01B26:  SUBWFB x65,W
01B28:  MOVWF  x73
01B2A:  MOVF   5E,W
01B2C:  SUBWFB x66,W
01B2E:  MOVWF  x74
01B30:  MOVF   5F,W
01B32:  SUBWFB x67,W
01B34:  MOVWF  x75
01B36:  MOVF   x75,F
01B38:  BNZ   1B52
01B3A:  MOVF   x74,F
01B3C:  BNZ   1B52
01B3E:  MOVF   x73,W
01B40:  SUBLW  08
01B42:  BC    1B4E
01B44:  XORLW  FF
01B46:  BNZ   1B52
01B48:  MOVF   x72,W
01B4A:  SUBLW  C4
01B4C:  BNC   1B52
01B4E:  MOVLW  00
01B50:  BRA    1B54
01B52:  MOVLW  01
01B54:  MOVWF  x72
01B56:  MOVF   x6C,F
01B58:  BZ    1B5E
01B5A:  MOVLW  00
01B5C:  BRA    1B60
01B5E:  MOVLW  01
01B60:  ANDWF  x72,W
01B62:  BZ    1B90
....................             
....................             lcd_gotoxy(8,mode_cursor);
01B64:  MOVLW  08
01B66:  MOVWF  x7F
01B68:  MOVFF  6B,80
01B6C:  CALL   07CE
....................             lcd_putc("    ");
01B70:  MOVLW  B4
01B72:  MOVWF  FF6
01B74:  MOVLW  05
01B76:  MOVWF  FF7
01B78:  CALL   0856
....................             
....................             mod_flag=True;
01B7C:  MOVLW  01
01B7E:  MOVWF  x6C
....................             StartTick=CurrentTick;
01B80:  MOVFF  67,5F
01B84:  MOVFF  66,5E
01B88:  MOVFF  65,5D
01B8C:  MOVFF  64,5C
....................             }
....................             
....................             if(input(button1)){
01B90:  BSF    F95.1
01B92:  BTFSS  F83.1
01B94:  BRA    1C04
....................             delay_s--;
01B96:  DECF   20,F
....................             
....................             if(delay_s<=0){
01B98:  MOVF   20,F
01B9A:  BNZ   1BA0
....................                delay_s=1;
01B9C:  MOVLW  01
01B9E:  MOVWF  20
....................             }
....................             
....................             lcd_gotoxy(8,mode_cursor);
01BA0:  MOVLW  08
01BA2:  MOVWF  x7F
01BA4:  MOVFF  6B,80
01BA8:  CALL   07CE
....................             lcd_putc("%");
01BAC:  MOVLW  BA
01BAE:  MOVWF  FF6
01BB0:  MOVLW  05
01BB2:  MOVWF  FF7
01BB4:  CALL   0856
....................             printf(lcd_putc,"%d ",delay_s*10);
01BB8:  MOVF   20,W
01BBA:  MULLW  0A
01BBC:  MOVFF  FF3,73
01BC0:  MOVLW  18
01BC2:  MOVWF  x74
01BC4:  CALL   0958
01BC8:  MOVLW  20
01BCA:  MOVWF  x7E
01BCC:  CALL   080E
....................             
....................             printf("h0%d ",delay_s);
01BD0:  MOVLW  68
01BD2:  BTFSS  F9E.4
01BD4:  BRA    1BD2
01BD6:  MOVWF  FAD
01BD8:  MOVLW  30
01BDA:  BTFSS  F9E.4
01BDC:  BRA    1BDA
01BDE:  MOVWF  FAD
01BE0:  MOVFF  20,78
01BE4:  MOVLW  18
01BE6:  MOVWF  x79
01BE8:  CALL   0A68
01BEC:  MOVLW  20
01BEE:  BTFSS  F9E.4
01BF0:  BRA    1BEE
01BF2:  MOVWF  FAD
....................             delay_ms(500);
01BF4:  MOVLW  02
01BF6:  MOVWF  x72
01BF8:  MOVLW  FA
01BFA:  MOVWF  x7F
01BFC:  CALL   05E4
01C00:  DECFSZ x72,F
01C02:  BRA    1BF8
....................             
....................             }
....................             
....................             if(input(button3)){
01C04:  BSF    F94.3
01C06:  BTFSS  F82.3
01C08:  BRA    1C8E
....................             delay_s++;
01C0A:  INCF   20,F
....................             
....................             if(delay_s>=10){
01C0C:  MOVF   20,W
01C0E:  SUBLW  09
01C10:  BC    1C16
....................                delay_s=10;
01C12:  MOVLW  0A
01C14:  MOVWF  20
....................             }
....................             
....................             lcd_gotoxy(8,mode_cursor);
01C16:  MOVLW  08
01C18:  MOVWF  x7F
01C1A:  MOVFF  6B,80
01C1E:  CALL   07CE
....................             lcd_putc("%");
01C22:  MOVLW  BC
01C24:  MOVWF  FF6
01C26:  MOVLW  05
01C28:  MOVWF  FF7
01C2A:  CALL   0856
....................             printf(lcd_putc,"%d ",delay_s*10);
01C2E:  MOVF   20,W
01C30:  MULLW  0A
01C32:  MOVFF  FF3,73
01C36:  MOVLW  18
01C38:  MOVWF  x74
01C3A:  CALL   0958
01C3E:  MOVLW  20
01C40:  MOVWF  x7E
01C42:  CALL   080E
....................             
....................             if(delay_s<10){
01C46:  MOVF   20,W
01C48:  SUBLW  09
01C4A:  BNC   1C72
....................                printf("h0%d ",delay_s);
01C4C:  MOVLW  68
01C4E:  BTFSS  F9E.4
01C50:  BRA    1C4E
01C52:  MOVWF  FAD
01C54:  MOVLW  30
01C56:  BTFSS  F9E.4
01C58:  BRA    1C56
01C5A:  MOVWF  FAD
01C5C:  MOVFF  20,78
01C60:  MOVLW  18
01C62:  MOVWF  x79
01C64:  CALL   0A68
01C68:  MOVLW  20
01C6A:  BTFSS  F9E.4
01C6C:  BRA    1C6A
01C6E:  MOVWF  FAD
....................             }
01C70:  BRA    1C7E
....................             else{
....................                printf("h10");
01C72:  MOVLW  BE
01C74:  MOVWF  FF6
01C76:  MOVLW  05
01C78:  MOVWF  FF7
01C7A:  CALL   0B1A
....................             }
....................             
....................             delay_ms(500);
01C7E:  MOVLW  02
01C80:  MOVWF  x72
01C82:  MOVLW  FA
01C84:  MOVWF  x7F
01C86:  CALL   05E4
01C8A:  DECFSZ x72,F
01C8C:  BRA    1C82
....................             
....................             }  
....................          }
....................  
....................  ////////////////////////
....................  
....................          if(mode_cursor==2){ // SET ACCEL
01C8E:  MOVF   x6B,W
01C90:  SUBLW  02
01C92:  BTFSS  FD8.2
01C94:  BRA    1E9C
....................           
....................             CurrentTick=get_ticks();
01C96:  CALL   077C
01C9A:  MOVFF  03,67
01C9E:  MOVFF  02,66
01CA2:  MOVFF  01,65
01CA6:  MOVFF  00,64
....................            
....................             if(CurrentTick-StartTick>2500 & mod_flag==True){
01CAA:  MOVF   5C,W
01CAC:  SUBWF  x64,W
01CAE:  MOVWF  x72
01CB0:  MOVF   5D,W
01CB2:  SUBWFB x65,W
01CB4:  MOVWF  x73
01CB6:  MOVF   5E,W
01CB8:  SUBWFB x66,W
01CBA:  MOVWF  x74
01CBC:  MOVF   5F,W
01CBE:  SUBWFB x67,W
01CC0:  MOVWF  x75
01CC2:  MOVF   x75,F
01CC4:  BNZ   1CDE
01CC6:  MOVF   x74,F
01CC8:  BNZ   1CDE
01CCA:  MOVF   x73,W
01CCC:  SUBLW  08
01CCE:  BC    1CDA
01CD0:  XORLW  FF
01CD2:  BNZ   1CDE
01CD4:  MOVF   x72,W
01CD6:  SUBLW  C4
01CD8:  BNC   1CDE
01CDA:  MOVLW  00
01CDC:  BRA    1CE0
01CDE:  MOVLW  01
01CE0:  MOVWF  x72
01CE2:  DECFSZ x6C,W
01CE4:  BRA    1CE8
01CE6:  BRA    1CEC
01CE8:  MOVLW  00
01CEA:  BRA    1CEE
01CEC:  MOVLW  01
01CEE:  ANDWF  x72,W
01CF0:  BZ    1D2C
....................             
....................             lcd_gotoxy(8,mode_cursor);
01CF2:  MOVLW  08
01CF4:  MOVWF  x7F
01CF6:  MOVFF  6B,80
01CFA:  CALL   07CE
....................             lcd_putc("%");
01CFE:  MOVLW  C2
01D00:  MOVWF  FF6
01D02:  MOVLW  05
01D04:  MOVWF  FF7
01D06:  CALL   0856
....................             printf(lcd_putc,"%d",accel*10);
01D0A:  MOVF   22,W
01D0C:  MULLW  0A
01D0E:  MOVFF  FF3,73
01D12:  MOVLW  18
01D14:  MOVWF  x74
01D16:  CALL   0958
....................             
....................             mod_flag=False;
01D1A:  CLRF   x6C
....................             StartTick=CurrentTick;
01D1C:  MOVFF  67,5F
01D20:  MOVFF  66,5E
01D24:  MOVFF  65,5D
01D28:  MOVFF  64,5C
....................             }
....................             
....................             if(CurrentTick-StartTick>2500 & mod_flag==False){
01D2C:  MOVF   5C,W
01D2E:  SUBWF  x64,W
01D30:  MOVWF  x72
01D32:  MOVF   5D,W
01D34:  SUBWFB x65,W
01D36:  MOVWF  x73
01D38:  MOVF   5E,W
01D3A:  SUBWFB x66,W
01D3C:  MOVWF  x74
01D3E:  MOVF   5F,W
01D40:  SUBWFB x67,W
01D42:  MOVWF  x75
01D44:  MOVF   x75,F
01D46:  BNZ   1D60
01D48:  MOVF   x74,F
01D4A:  BNZ   1D60
01D4C:  MOVF   x73,W
01D4E:  SUBLW  08
01D50:  BC    1D5C
01D52:  XORLW  FF
01D54:  BNZ   1D60
01D56:  MOVF   x72,W
01D58:  SUBLW  C4
01D5A:  BNC   1D60
01D5C:  MOVLW  00
01D5E:  BRA    1D62
01D60:  MOVLW  01
01D62:  MOVWF  x72
01D64:  MOVF   x6C,F
01D66:  BZ    1D6C
01D68:  MOVLW  00
01D6A:  BRA    1D6E
01D6C:  MOVLW  01
01D6E:  ANDWF  x72,W
01D70:  BZ    1D9E
....................             
....................             lcd_gotoxy(8,mode_cursor);
01D72:  MOVLW  08
01D74:  MOVWF  x7F
01D76:  MOVFF  6B,80
01D7A:  CALL   07CE
....................             lcd_putc("    ");
01D7E:  MOVLW  C4
01D80:  MOVWF  FF6
01D82:  MOVLW  05
01D84:  MOVWF  FF7
01D86:  CALL   0856
....................             
....................             mod_flag=True;
01D8A:  MOVLW  01
01D8C:  MOVWF  x6C
....................             StartTick=CurrentTick;
01D8E:  MOVFF  67,5F
01D92:  MOVFF  66,5E
01D96:  MOVFF  65,5D
01D9A:  MOVFF  64,5C
....................             }
....................              
....................               if(input(button1)){
01D9E:  BSF    F95.1
01DA0:  BTFSS  F83.1
01DA2:  BRA    1E12
....................                accel--;
01DA4:  DECF   22,F
....................                
....................                if(accel<=0){
01DA6:  MOVF   22,F
01DA8:  BNZ   1DAE
....................                   accel=1;
01DAA:  MOVLW  01
01DAC:  MOVWF  22
....................                }
....................                
....................                lcd_gotoxy(8,mode_cursor);
01DAE:  MOVLW  08
01DB0:  MOVWF  x7F
01DB2:  MOVFF  6B,80
01DB6:  CALL   07CE
....................                lcd_putc("%");
01DBA:  MOVLW  CA
01DBC:  MOVWF  FF6
01DBE:  MOVLW  05
01DC0:  MOVWF  FF7
01DC2:  CALL   0856
....................                printf(lcd_putc,"%d ",accel*10);
01DC6:  MOVF   22,W
01DC8:  MULLW  0A
01DCA:  MOVFF  FF3,73
01DCE:  MOVLW  18
01DD0:  MOVWF  x74
01DD2:  CALL   0958
01DD6:  MOVLW  20
01DD8:  MOVWF  x7E
01DDA:  CALL   080E
....................                
....................                printf("a0%d ",accel);
01DDE:  MOVLW  61
01DE0:  BTFSS  F9E.4
01DE2:  BRA    1DE0
01DE4:  MOVWF  FAD
01DE6:  MOVLW  30
01DE8:  BTFSS  F9E.4
01DEA:  BRA    1DE8
01DEC:  MOVWF  FAD
01DEE:  MOVFF  22,78
01DF2:  MOVLW  18
01DF4:  MOVWF  x79
01DF6:  CALL   0A68
01DFA:  MOVLW  20
01DFC:  BTFSS  F9E.4
01DFE:  BRA    1DFC
01E00:  MOVWF  FAD
....................                
....................                delay_ms(500);
01E02:  MOVLW  02
01E04:  MOVWF  x72
01E06:  MOVLW  FA
01E08:  MOVWF  x7F
01E0A:  CALL   05E4
01E0E:  DECFSZ x72,F
01E10:  BRA    1E06
....................                
....................                }
....................            
....................             if(input(button3)){
01E12:  BSF    F94.3
01E14:  BTFSS  F82.3
01E16:  BRA    1E9C
....................                accel++;
01E18:  INCF   22,F
....................                
....................                if(accel>=11){
01E1A:  MOVF   22,W
01E1C:  SUBLW  0A
01E1E:  BC    1E24
....................                   accel=10;
01E20:  MOVLW  0A
01E22:  MOVWF  22
....................                }
....................                
....................                lcd_gotoxy(8,mode_cursor);
01E24:  MOVLW  08
01E26:  MOVWF  x7F
01E28:  MOVFF  6B,80
01E2C:  CALL   07CE
....................                lcd_putc("%");
01E30:  MOVLW  CC
01E32:  MOVWF  FF6
01E34:  MOVLW  05
01E36:  MOVWF  FF7
01E38:  CALL   0856
....................                printf(lcd_putc,"%d ",accel*10);
01E3C:  MOVF   22,W
01E3E:  MULLW  0A
01E40:  MOVFF  FF3,73
01E44:  MOVLW  18
01E46:  MOVWF  x74
01E48:  CALL   0958
01E4C:  MOVLW  20
01E4E:  MOVWF  x7E
01E50:  CALL   080E
....................                
....................                if(accel<10){
01E54:  MOVF   22,W
01E56:  SUBLW  09
01E58:  BNC   1E80
....................                printf("a0%d ",accel);
01E5A:  MOVLW  61
01E5C:  BTFSS  F9E.4
01E5E:  BRA    1E5C
01E60:  MOVWF  FAD
01E62:  MOVLW  30
01E64:  BTFSS  F9E.4
01E66:  BRA    1E64
01E68:  MOVWF  FAD
01E6A:  MOVFF  22,78
01E6E:  MOVLW  18
01E70:  MOVWF  x79
01E72:  CALL   0A68
01E76:  MOVLW  20
01E78:  BTFSS  F9E.4
01E7A:  BRA    1E78
01E7C:  MOVWF  FAD
....................                }
01E7E:  BRA    1E8C
....................                else{
....................                   printf("a10");
01E80:  MOVLW  CE
01E82:  MOVWF  FF6
01E84:  MOVLW  05
01E86:  MOVWF  FF7
01E88:  CALL   0B1A
....................                }
....................             
....................                delay_ms(500);
01E8C:  MOVLW  02
01E8E:  MOVWF  x72
01E90:  MOVLW  FA
01E92:  MOVWF  x7F
01E94:  CALL   05E4
01E98:  DECFSZ x72,F
01E9A:  BRA    1E90
....................             
....................             } 
....................          }
....................          
....................          ////////////////////////
....................          
....................          if(input(button4)==1){
01E9C:  BSF    F94.2
01E9E:  BTFSS  F82.2
01EA0:  BRA    1F0C
....................          
....................          lcd_gotoxy(8,1);
01EA2:  MOVLW  08
01EA4:  MOVWF  x7F
01EA6:  MOVLW  01
01EA8:  MOVWF  x80
01EAA:  CALL   07CE
....................          lcd_putc("%");
01EAE:  MOVLW  D2
01EB0:  MOVWF  FF6
01EB2:  MOVLW  05
01EB4:  MOVWF  FF7
01EB6:  CALL   0856
....................          printf(lcd_putc,"%d",delay_s*10);
01EBA:  MOVF   20,W
01EBC:  MULLW  0A
01EBE:  MOVFF  FF3,73
01EC2:  MOVLW  18
01EC4:  MOVWF  x74
01EC6:  CALL   0958
....................          
....................          lcd_gotoxy(8,2);
01ECA:  MOVLW  08
01ECC:  MOVWF  x7F
01ECE:  MOVLW  02
01ED0:  MOVWF  x80
01ED2:  CALL   07CE
....................          lcd_putc("%");
01ED6:  MOVLW  D4
01ED8:  MOVWF  FF6
01EDA:  MOVLW  05
01EDC:  MOVWF  FF7
01EDE:  CALL   0856
....................          printf(lcd_putc,"%d",accel*10);
01EE2:  MOVF   22,W
01EE4:  MULLW  0A
01EE6:  MOVFF  FF3,73
01EEA:  MOVLW  18
01EEC:  MOVWF  x74
01EEE:  CALL   0958
....................          
....................          mode_cursor--;
01EF2:  DECF   x6B,F
....................          
....................          if (mode_cursor<=0){
01EF4:  MOVF   x6B,F
01EF6:  BNZ   1EFC
....................          mode_cursor=2;
01EF8:  MOVLW  02
01EFA:  MOVWF  x6B
....................          }
....................          delay_ms(500);
01EFC:  MOVLW  02
01EFE:  MOVWF  x72
01F00:  MOVLW  FA
01F02:  MOVWF  x7F
01F04:  CALL   05E4
01F08:  DECFSZ x72,F
01F0A:  BRA    1F00
....................          }
....................          
....................          if(input(button2)==1){
01F0C:  BSF    F95.0
01F0E:  BTFSS  F83.0
01F10:  BRA    1F7E
....................                 
....................          lcd_gotoxy(8,1);
01F12:  MOVLW  08
01F14:  MOVWF  x7F
01F16:  MOVLW  01
01F18:  MOVWF  x80
01F1A:  CALL   07CE
....................          lcd_putc("%");
01F1E:  MOVLW  D6
01F20:  MOVWF  FF6
01F22:  MOVLW  05
01F24:  MOVWF  FF7
01F26:  CALL   0856
....................          printf(lcd_putc,"%d",delay_s*10);
01F2A:  MOVF   20,W
01F2C:  MULLW  0A
01F2E:  MOVFF  FF3,73
01F32:  MOVLW  18
01F34:  MOVWF  x74
01F36:  CALL   0958
....................          
....................          lcd_gotoxy(8,2);
01F3A:  MOVLW  08
01F3C:  MOVWF  x7F
01F3E:  MOVLW  02
01F40:  MOVWF  x80
01F42:  CALL   07CE
....................          lcd_putc("%");
01F46:  MOVLW  D8
01F48:  MOVWF  FF6
01F4A:  MOVLW  05
01F4C:  MOVWF  FF7
01F4E:  CALL   0856
....................          printf(lcd_putc,"%d",accel*10);
01F52:  MOVF   22,W
01F54:  MULLW  0A
01F56:  MOVFF  FF3,73
01F5A:  MOVLW  18
01F5C:  MOVWF  x74
01F5E:  CALL   0958
....................                
....................           mode_cursor++;
01F62:  INCF   x6B,F
....................           
....................          if (mode_cursor>=3){
01F64:  MOVF   x6B,W
01F66:  SUBLW  02
01F68:  BC    1F6E
....................          mode_cursor=1;
01F6A:  MOVLW  01
01F6C:  MOVWF  x6B
....................          }
....................          delay_ms(500);
01F6E:  MOVLW  02
01F70:  MOVWF  x72
01F72:  MOVLW  FA
01F74:  MOVWF  x7F
01F76:  CALL   05E4
01F7A:  DECFSZ x72,F
01F7C:  BRA    1F72
....................          }  
....................          
....................          if (input (button5) == 1){
01F7E:  BSF    F94.1
01F80:  BTFSS  F82.1
01F82:  BRA    1F96
....................             delay_ms(500);
01F84:  MOVLW  02
01F86:  MOVWF  x72
01F88:  MOVLW  FA
01F8A:  MOVWF  x7F
01F8C:  CALL   05E4
01F90:  DECFSZ x72,F
01F92:  BRA    1F88
....................          break;
01F94:  BRA    1F98
....................          }
01F96:  BRA    1A84
....................          
....................       }   
....................       }
....................       
.................... 
.................... //////////////>>>>>>>>> SERIAL COMM <<<<<<<<///////////   
....................       if (correct){ // full data received
01F98:  MOVF   32,F
01F9A:  BTFSC  FD8.2
01F9C:  BRA    209C
....................         
....................          read_serial_mode();
01F9E:  GOTO   0B3C
....................           read_serial_speed();
01FA2:  GOTO   0B98
....................           read_serial_acc();
01FA6:  GOTO   0C18
....................           
....................           if(str[0]=='c'){
01FAA:  MOVF   29,W
01FAC:  SUBLW  63
01FAE:  BNZ   1FB8
....................             centerline(6);
01FB0:  MOVLW  06
01FB2:  MOVWF  x72
01FB4:  CALL   0EC8
....................           }
....................           
....................           if(str[0]=='g'){
01FB8:  MOVF   29,W
01FBA:  SUBLW  67
01FBC:  BNZ   1FC2
....................             gogo();
01FBE:  CALL   10BC
....................           }
....................           
....................           if(str[0]=='d'){ //usb connected, send commands to pc
01FC2:  MOVF   29,W
01FC4:  SUBLW  64
01FC6:  BNZ   209A
....................             printf("x");
01FC8:  MOVLW  78
01FCA:  BTFSS  F9E.4
01FCC:  BRA    1FCA
01FCE:  MOVWF  FAD
....................             delay_ms(30);
01FD0:  MOVLW  1E
01FD2:  MOVWF  x7F
01FD4:  CALL   05E4
....................             printf("h0%d",delay_s);
01FD8:  MOVLW  68
01FDA:  BTFSS  F9E.4
01FDC:  BRA    1FDA
01FDE:  MOVWF  FAD
01FE0:  MOVLW  30
01FE2:  BTFSS  F9E.4
01FE4:  BRA    1FE2
01FE6:  MOVWF  FAD
01FE8:  MOVFF  20,78
01FEC:  MOVLW  18
01FEE:  MOVWF  x79
01FF0:  CALL   0A68
....................             delay_ms(30);
01FF4:  MOVLW  1E
01FF6:  MOVWF  x7F
01FF8:  CALL   05E4
....................             printf("a0%d",accel);
01FFC:  MOVLW  61
01FFE:  BTFSS  F9E.4
02000:  BRA    1FFE
02002:  MOVWF  FAD
02004:  MOVLW  30
02006:  BTFSS  F9E.4
02008:  BRA    2006
0200A:  MOVWF  FAD
0200C:  MOVFF  22,78
02010:  MOVLW  18
02012:  MOVWF  x79
02014:  CALL   0A68
....................             delay_ms(30);
02018:  MOVLW  1E
0201A:  MOVWF  x7F
0201C:  CALL   05E4
....................             
....................             if(mode_manuel){
02020:  MOVF   26,F
02022:  BZ    2034
....................                printf("m0");
02024:  MOVLW  6D
02026:  BTFSS  F9E.4
02028:  BRA    2026
0202A:  MOVWF  FAD
0202C:  MOVLW  30
0202E:  BTFSS  F9E.4
02030:  BRA    202E
02032:  MOVWF  FAD
....................             }
....................             
....................             if(mode_auto){
02034:  MOVF   25,F
02036:  BZ    2048
....................                printf("m1");
02038:  MOVLW  6D
0203A:  BTFSS  F9E.4
0203C:  BRA    203A
0203E:  MOVWF  FAD
02040:  MOVLW  31
02042:  BTFSS  F9E.4
02044:  BRA    2042
02046:  MOVWF  FAD
....................             }
....................             
....................             delay_ms(30);
02048:  MOVLW  1E
0204A:  MOVWF  x7F
0204C:  CALL   05E4
....................             
....................             if(centered){
02050:  MOVF   38,F
02052:  BZ    2068
....................                printf("t%d",threshold);
02054:  MOVLW  74
02056:  BTFSS  F9E.4
02058:  BRA    2056
0205A:  MOVWF  FAD
0205C:  MOVFF  44,78
02060:  MOVLW  18
02062:  MOVWF  x79
02064:  CALL   0A68
....................             }
....................             
....................             delay_ms(30);
02068:  MOVLW  1E
0206A:  MOVWF  x7F
0206C:  CALL   05E4
....................             int8 step_data=step/10;
02070:  MOVFF  3F,79
02074:  MOVFF  3E,78
02078:  CLRF   x7B
0207A:  MOVLW  0A
0207C:  MOVWF  x7A
0207E:  CALL   0CF8
02082:  MOVFF  01,6D
....................             printf("q%d",step_data);
02086:  MOVLW  71
02088:  BTFSS  F9E.4
0208A:  BRA    2088
0208C:  MOVWF  FAD
0208E:  MOVFF  6D,78
02092:  MOVLW  18
02094:  MOVWF  x79
02096:  CALL   0A68
....................             
....................             
....................           }
....................           
....................           correct=False;
0209A:  CLRF   32
....................            
....................      }     
....................          
.................... ///////////>>>>>>> SELECT MANUEL or AUTO <<<<<<<<<///////
....................       while(input (button0) )  //select auto
0209C:  BSF    F95.5
0209E:  BTFSS  F83.5
020A0:  BRA    214A
....................       {  
....................          
....................          delay_ms(500);
020A2:  MOVLW  02
020A4:  MOVWF  x72
020A6:  MOVLW  FA
020A8:  MOVWF  x7F
020AA:  CALL   05E4
020AE:  DECFSZ x72,F
020B0:  BRA    20A6
....................          
....................          if (flag)
020B2:  MOVF   27,F
020B4:  BZ    212E
....................          {
....................             flag = False;
020B6:  CLRF   27
....................             mode_AUTO = True;
020B8:  MOVLW  01
020BA:  MOVWF  25
....................             mode_manuel = False;
020BC:  CLRF   26
....................             
....................             lcd_gotoxy(13,1);
020BE:  MOVLW  0D
020C0:  MOVWF  x7F
020C2:  MOVLW  01
020C4:  MOVWF  x80
020C6:  CALL   07CE
....................             lcd_putc("< Auto >");
020CA:  MOVLW  DA
020CC:  MOVWF  FF6
020CE:  MOVLW  05
020D0:  MOVWF  FF7
020D2:  CALL   0856
....................             printf("m1");
020D6:  MOVLW  6D
020D8:  BTFSS  F9E.4
020DA:  BRA    20D8
020DC:  MOVWF  FAD
020DE:  MOVLW  31
020E0:  BTFSS  F9E.4
020E2:  BRA    20E0
020E4:  MOVWF  FAD
....................             
....................             start=True;
020E6:  MOVLW  01
020E8:  MOVWF  46
....................       
....................          while (TRUE)
....................          {  
....................                     
....................             acc_start_normal_auto();
020EA:  CALL   124E
.................... 
....................             if (return_value==False){
020EE:  MOVF   48,F
020F0:  BNZ   20F8
....................                   return_value=True;
020F2:  MOVLW  01
020F4:  MOVWF  48
....................                   break;
020F6:  BRA    212C
....................             }
....................             
....................             normal ();
020F8:  CALL   0E9C
....................             
....................             if (input (button2) | input (button3)  | input (button4) | check_right_proxy())
020FC:  BSF    F95.0
020FE:  MOVLW  00
02100:  BTFSC  F83.0
02102:  MOVLW  01
02104:  MOVWF  x72
02106:  BSF    F94.3
02108:  MOVLW  00
0210A:  BTFSC  F82.3
0210C:  MOVLW  01
0210E:  IORWF  x72,F
02110:  BSF    F94.2
02112:  MOVLW  00
02114:  BTFSC  F82.2
02116:  MOVLW  01
02118:  IORWF  x72,F
0211A:  CALL   0E3E
0211E:  MOVF   x72,W
02120:  IORWF  01,W
02122:  BZ    212A
....................             {
....................                stop();
02124:  CALL   0CE6
....................                break;
02128:  BRA    212C
....................             }
0212A:  BRA    20EA
....................          }
....................       }
0212C:  BRA    2148
....................       
....................        else{
....................             flag = TRUE;
0212E:  MOVLW  01
02130:  MOVWF  27
....................             mode_AUTO = FALSE;
02132:  CLRF   25
....................             mode_manuel = TRUE;
02134:  MOVWF  26
....................             printf("m0");
02136:  MOVLW  6D
02138:  BTFSS  F9E.4
0213A:  BRA    2138
0213C:  MOVWF  FAD
0213E:  MOVLW  30
02140:  BTFSS  F9E.4
02142:  BRA    2140
02144:  MOVWF  FAD
....................             break;
02146:  BRA    214A
....................          }
02148:  BRA    209C
....................     }
....................          
....................       
.................... 
.................... ////////////////>>>>>> MANUEL <<<<< ////////////////////
.................... start=True;
0214A:  MOVLW  01
0214C:  MOVWF  46
.................... q=False;
0214E:  CLRF   47
.................... 
....................       while (input (button1) & mode_manuel)
02150:  BSF    F95.1
02152:  MOVLW  00
02154:  BTFSC  F83.1
02156:  MOVLW  01
02158:  ANDWF  26,W
0215A:  BZ    2196
....................       {
....................          if (check_right_proxy() | input (button3) ){
0215C:  CALL   0E3E
02160:  MOVFF  01,72
02164:  BSF    F94.3
02166:  MOVLW  00
02168:  BTFSC  F82.3
0216A:  MOVLW  01
0216C:  IORWF  01,W
0216E:  BZ    217A
....................             stop();
02170:  CALL   0CE6
....................             correct = False;
02174:  CLRF   32
....................             disable_interrupts(INT_TIMER1);
02176:  BCF    F9D.0
....................             break;
02178:  BRA    2196
....................           }
....................          
....................          acc_start_normal_man();
0217A:  GOTO   12B6
.................... 
....................          if (!(return_value)){
0217E:  MOVF   48,F
02180:  BNZ   2188
....................             return_value=True;
02182:  MOVLW  01
02184:  MOVWF  48
....................             break;
02186:  BRA    2196
....................             }
....................             
....................          speed=delay_s;
02188:  MOVFF  20,21
....................          normal ();
0218C:  CALL   0E9C
....................          quit1=True;
02190:  MOVLW  01
02192:  MOVWF  33
02194:  BRA    2150
....................       }
....................          
....................       while (input (button3) & mode_manuel)
02196:  BSF    F94.3
02198:  MOVLW  00
0219A:  BTFSC  F82.3
0219C:  MOVLW  01
0219E:  ANDWF  26,W
021A0:  BZ    21DC
....................       {
....................          if (check_left_proxy() | input (button1) ){
021A2:  CALL   0C98
021A6:  MOVFF  01,72
021AA:  BSF    F95.1
021AC:  MOVLW  00
021AE:  BTFSC  F83.1
021B0:  MOVLW  01
021B2:  IORWF  01,W
021B4:  BZ    21C0
....................                stop();
021B6:  CALL   0CE6
....................                correct = False;
021BA:  CLRF   32
....................                disable_interrupts(INT_TIMER1);
021BC:  BCF    F9D.0
....................                break;
021BE:  BRA    21DC
....................           }
....................           
....................         acc_start_reverse_man();
021C0:  GOTO   1328
.................... 
....................         if (return_value==False){
021C4:  MOVF   48,F
021C6:  BNZ   21CE
....................             return_value=True;
021C8:  MOVLW  01
021CA:  MOVWF  48
....................             break;
021CC:  BRA    21DC
....................             }
....................             
....................         speed=delay_s;
021CE:  MOVFF  20,21
....................         reverse ();
021D2:  CALL   0E34
....................         quit2=True;
021D6:  MOVLW  01
021D8:  MOVWF  34
021DA:  BRA    2196
....................       }
....................       
....................       while(quit2){
021DC:  MOVF   34,F
021DE:  BZ    222C
....................          for(int i=0;i<10-accel;i++){                
021E0:  CLRF   x6E
021E2:  MOVLW  0A
021E4:  BSF    FD8.0
021E6:  SUBFWB 22,W
021E8:  SUBWF  x6E,W
021EA:  BC    2224
....................             for(int j=0;j<accel_value;j++){
021EC:  CLRF   x6F
021EE:  MOVF   23,W
021F0:  SUBWF  x6F,W
021F2:  BC    221C
....................                
....................                if(input (button1) | check_left_proxy()){
021F4:  BSF    F95.1
021F6:  MOVLW  00
021F8:  BTFSC  F83.1
021FA:  MOVLW  01
021FC:  MOVWF  x72
021FE:  CALL   0C98
02202:  MOVF   x72,W
02204:  IORWF  01,W
02206:  BZ    2210
....................                   stop();
02208:  CALL   0CE6
....................                   disable_interrupts(INT_TIMER1);
0220C:  BCF    F9D.0
....................                   break;
0220E:  BRA    221C
....................                }
....................                
....................                speed=c;
02210:  MOVFF  24,21
....................                reverse();
02214:  CALL   0E34
02218:  INCF   x6F,F
0221A:  BRA    21EE
....................                }
....................                c=c-1;  
0221C:  MOVLW  01
0221E:  SUBWF  24,F
02220:  INCF   x6E,F
02222:  BRA    21E2
....................     
....................          }
....................          quit2=False;
02224:  CLRF   34
....................          stop();
02226:  CALL   0CE6
0222A:  BRA    21DC
....................          }
....................        
....................       while(quit1){
0222C:  MOVF   33,F
0222E:  BZ    227C
....................          for(int i=0;i<10-accel;i++){                
02230:  CLRF   x70
02232:  MOVLW  0A
02234:  BSF    FD8.0
02236:  SUBFWB 22,W
02238:  SUBWF  x70,W
0223A:  BC    2274
....................             for(int j=0;j<accel_value;j++){ 
0223C:  CLRF   x71
0223E:  MOVF   23,W
02240:  SUBWF  x71,W
02242:  BC    226C
....................                
....................                if(input (button3) | check_right_proxy()){
02244:  BSF    F94.3
02246:  MOVLW  00
02248:  BTFSC  F82.3
0224A:  MOVLW  01
0224C:  MOVWF  x72
0224E:  CALL   0E3E
02252:  MOVF   x72,W
02254:  IORWF  01,W
02256:  BZ    2260
....................                   stop();
02258:  CALL   0CE6
....................                   disable_interrupts(INT_TIMER1);
0225C:  BCF    F9D.0
....................                   break;
0225E:  BRA    226C
....................                }
....................                
....................                speed=c;
02260:  MOVFF  24,21
....................                normal();
02264:  CALL   0E9C
02268:  INCF   x71,F
0226A:  BRA    223E
....................                }
....................                c=c-1;  
0226C:  MOVLW  01
0226E:  SUBWF  24,F
02270:  INCF   x70,F
02272:  BRA    2232
....................                    
....................          }
....................          quit1=False;
02274:  CLRF   33
....................          stop();
02276:  CALL   0CE6
0227A:  BRA    222C
....................          }
....................          
....................       stop();
0227C:  CALL   0CE6
....................       
....................       
.................... 
.................... ////////////////////>>>>>> AUTO <<<<</////////////////////
.................... 
....................       if (input (button1)  & mode_auto == TRUE)
02280:  BSF    F95.1
02282:  MOVLW  00
02284:  BTFSC  F83.1
02286:  MOVLW  01
02288:  MOVWF  x72
0228A:  DECFSZ 25,W
0228C:  BRA    2290
0228E:  BRA    2294
02290:  MOVLW  00
02292:  BRA    2296
02294:  MOVLW  01
02296:  ANDWF  x72,W
02298:  BZ    22E6
....................       {
....................       start=True;
0229A:  MOVLW  01
0229C:  MOVWF  46
....................       while(input (button1)){};
0229E:  BSF    F95.1
022A0:  BTFSC  F83.1
022A2:  BRA    229E
....................       
....................          while (TRUE)
....................          {  
....................                     
....................             acc_start_normal_auto();
022A4:  CALL   124E
.................... 
....................             if (return_value==False){
022A8:  MOVF   48,F
022AA:  BNZ   22B2
....................                   return_value=True;
022AC:  MOVLW  01
022AE:  MOVWF  48
....................                   break;
022B0:  BRA    22E6
....................             }
....................             
....................             normal ();
022B2:  CALL   0E9C
....................             
....................             if (input (button2) | input (button3)  | input (button4) | check_right_proxy())
022B6:  BSF    F95.0
022B8:  MOVLW  00
022BA:  BTFSC  F83.0
022BC:  MOVLW  01
022BE:  MOVWF  x72
022C0:  BSF    F94.3
022C2:  MOVLW  00
022C4:  BTFSC  F82.3
022C6:  MOVLW  01
022C8:  IORWF  x72,F
022CA:  BSF    F94.2
022CC:  MOVLW  00
022CE:  BTFSC  F82.2
022D0:  MOVLW  01
022D2:  IORWF  x72,F
022D4:  CALL   0E3E
022D8:  MOVF   x72,W
022DA:  IORWF  01,W
022DC:  BZ    22E4
....................             {
....................                stop();
022DE:  CALL   0CE6
....................                break;
022E2:  BRA    22E6
....................             }
022E4:  BRA    22A4
....................          }
....................       }
.................... 
....................       if (input (button3) == 1 & mode_auto == TRUE)
022E6:  BSF    F94.3
022E8:  MOVLW  00
022EA:  BTFSC  F82.3
022EC:  MOVLW  01
022EE:  MOVWF  x73
022F0:  DECFSZ 25,W
022F2:  BRA    22F6
022F4:  BRA    22FA
022F6:  MOVLW  00
022F8:  BRA    22FC
022FA:  MOVLW  01
022FC:  ANDWF  x73,W
022FE:  BZ    2356
....................       {
....................          start=True;
02300:  MOVLW  01
02302:  MOVWF  46
....................          delay_ms(500);
02304:  MOVLW  02
02306:  MOVWF  x72
02308:  MOVLW  FA
0230A:  MOVWF  x7F
0230C:  CALL   05E4
02310:  DECFSZ x72,F
02312:  BRA    2308
....................          
....................       
....................          while (TRUE)
....................          {  
....................                      
....................              acc_start_reverse_auto();
02314:  GOTO   139A
.................... 
....................             if (return_value==False){
02318:  MOVF   48,F
0231A:  BNZ   2322
....................                   return_value=True;
0231C:  MOVLW  01
0231E:  MOVWF  48
....................                   break;
02320:  BRA    2356
....................             }
.................... 
....................             reverse ();
02322:  CALL   0E34
....................             
....................             if (input (button2) |input (button1) |input (button4)  | check_left_proxy())
02326:  BSF    F95.0
02328:  MOVLW  00
0232A:  BTFSC  F83.0
0232C:  MOVLW  01
0232E:  MOVWF  x72
02330:  BSF    F95.1
02332:  MOVLW  00
02334:  BTFSC  F83.1
02336:  MOVLW  01
02338:  IORWF  x72,F
0233A:  BSF    F94.2
0233C:  MOVLW  00
0233E:  BTFSC  F82.2
02340:  MOVLW  01
02342:  IORWF  x72,F
02344:  CALL   0C98
02348:  MOVF   x72,W
0234A:  IORWF  01,W
0234C:  BZ    2354
....................             {
....................                stop();
0234E:  CALL   0CE6
....................                break;
02352:  BRA    2356
....................             }
02354:  BRA    2314
....................          }
....................       }
.................... 
.................... ////////////////////>>>>>> CENTER <<<<<//////////////////////
....................       if (input (button2) == 1)
02356:  BSF    F95.0
02358:  BTFSS  F83.0
0235A:  BRA    2374
....................       {  
....................          delay_ms (500);
0235C:  MOVLW  02
0235E:  MOVWF  x72
02360:  MOVLW  FA
02362:  MOVWF  x7F
02364:  CALL   05E4
02368:  DECFSZ x72,F
0236A:  BRA    2360
....................          centerline(6);
0236C:  MOVLW  06
0236E:  MOVWF  x72
02370:  CALL   0EC8
....................          
....................       }
....................   
....................      
.................... ////////////////////>>>>>> GOGO <<<<<//////////////////////
.................... 
....................        if (input (button4) == 1)
02374:  BSF    F94.2
02376:  BTFSS  F82.2
02378:  BRA    238E
....................       {
....................          delay_ms (500);
0237A:  MOVLW  02
0237C:  MOVWF  x72
0237E:  MOVLW  FA
02380:  MOVWF  x7F
02382:  CALL   05E4
02386:  DECFSZ x72,F
02388:  BRA    237E
....................          gogo();
0238A:  CALL   10BC
....................          
.................... 
....................       }
0238E:  GOTO   19A0
....................       
....................       
....................    } 
....................    
....................  }
.................... 
02392:  SLEEP 
.................... 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C1E   PUT BROWNOUT BORV19 NOWDT WDT32768
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
